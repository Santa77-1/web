## 框架 面试知识点总结
整理了 VUE、React、jQuery、Node、webpack、Bootstrap、Git工具 面试的部分知识点

### 目录
- [为什么用前端框架](#为什么用前端框架)
- [前端框架优缺点](#前端框架优缺点)
- [前端打包工具](#前端打包工具)
- [为什么要打包](#为什么要打包)
- [webpack打包好处](#webpack打包好处)

- [VUE](#VUE)
  - [vue的生命周期函数](#vue的生命周期函数)
  - [简述每个周期具体适合哪些场景](#简述每个周期具体适合哪些场景)
  - [vue组件间传递参数、传值通信](#vue组件间传递参数传值通信)
  - [Vue中父子组件生命周期执行顺序](#vue中父子组件生命周期执行顺序)
  - [vue双向数据绑定原理](#vue双向数据绑定原理)
  - [v-model双向绑定原理](#v-model双向绑定原理)
  - [v-model中的实现原理及如何自定义v-model](#v-model中的实现原理及如何自定义v-model)
  - [Vue是如何实现双向绑定的](#Vue是如何实现双向绑定的)
  - [vuex](#vuex)
  - [vue和vuex组件通信的区别](#vue和vuex组件通信的区别)
  - [MVVM](#MVVM)
  - [MVVM和MVC的区别](#mvvm和mvc的区别)
  - [vue的优点](#vue的优点)
  - [Vue.js特点](#Vuejs特点)
  - [开发中常用的指令有哪些](#开发中常用的指令有哪些)
  - [vue的响应式原理](#vue的响应式原理)
  - [发布订阅模式和观察者模式](#发布订阅模式和观察者模式)
  - [Object.defineProperty介绍](#objectdefineproperty介绍)
  - [Vue的响应式原理中Object.defineProperty有什么缺陷](#Vue的响应式原理中ObjectdefineProperty有什么缺陷)
  - [使用Object.defineProperty()来进行数据劫持有什么缺点](#使用objectdefineproperty来进行数据劫持有什么缺点)
  - [v-if和v-show的区别](#v-if和v-show的区别)
  - [vue中created和mounted区别](#vue中created和mounted区别)
  - [vue中data和computed区别](#vue中data和computed区别)
  - [vue中watch和computed区别](#vue中watch和computed区别)
  - [vue中methods,watch和computer区别](#vue中methodswatch和computer区别)
  - [为什么vue组件中的data必须是函数](#为什么vue组件中的data必须是函数)
  - [vue的activated和deactivated钩子函数](#vue的activated和deactivated钩子函数)
  - [nextTick用法](#nexttick用法)
  - [vue中key属性的作用](#vue中key属性的作用)
  - [Vue中key属性用index为什么不行](#vue中key属性用index为什么不行)
  - [路由原理](#路由原理)
  - [Vue的路由模式](#vue的路由模式)
  - [Vue的路由实现：hash模式和history模式](#Vue的路由实现hash模式和history模式)
  - [Vue中hash模式和history模式的区别](#Vue中hash模式和history模式的区别)
  - [了解history有哪些方法吗？说下它们的区别](#了解history有哪些方法吗说下它们的区别)
  - [vue路由的钩子函数](#vue路由的钩子函数)
  - [路由之间跳转](#路由之间跳转)
  - [vue路由传参数](#vue路由传参数)
  - [vue中$router和$route的区别](#vue中router和route的区别)
  - [vue3带来的新特性/亮点](#vue3带来的新特性亮点)
  - [VDOM：三个part](#VDOM三个part)
  - [虚拟DOM(Virtual Dom)](#虚拟DOMVirtual-Dom)
  - [为什么使用虚拟DOM(Virtual DOM)](#为什么使用虚拟DOMVirtual-DOM)
  - [vue核心之虚拟DOM(vdom)](#vue核心之虚拟DOMvdom)
  - [Compositon api](#Compositon-api)
  - [Vue diff算法详解](#vue-diff算法详解)
  - [移动端适配的方法](#移动端适配的方法)
  - [rem原理](#rem-原理)
  - [rem和em的区别](#rem和em的区别)
  - [移动端300ms延迟的原因以及解决方案](#移动端300ms延迟的原因以及解决方案)
  - [vue和react技术选型](#vue和react技术选型)
  - [Vue和React数据驱动的区别](#vue和react数据驱动的区别)
  - [jQuery和vue区别](#jQuery和vue区别)
  - [如何让CSS只在当前组件中起作用](#如何让CSS只在当前组件中起作用)
  - [<keep-alive></keep-alive>的作用是什么](#keep-alivekeep-alive的作用是什么)
  - [指令v-el的作用是什么](#指令v-el的作用是什么)
  - [在Vue中使用插件的步骤](#在Vue中使用插件的步骤)
  - [请列举出3个Vue中常用的生命周期钩子函数](#请列举出3个Vue中常用的生命周期钩子函数)
  - [vue-cli工程技术集合介绍](#vue-cli工程技术集合介绍)
  - [实现Vue SSR](#实现Vue-SSR)
  - [Vue组件data为什么必须是函数](#Vue组件data为什么必须是函数)
  - [Vue computed实现](#Vue-computed实现)
  - [Vue complier实现](#Vue-complier实现)
  - [怎么快速定位哪个组件出现性能问题](#怎么快速定位哪个组件出现性能问题)
  - [Proxy相比于defineProperty的优势](#Proxy相比于defineProperty的优势)
  - [vue-router有哪几种导航守卫](#vue-router有哪几种导航守卫)
  - [Vue与Angular以及React的区别](#Vue与Angular以及React的区别)
  - [scoped样式穿透](#scoped样式穿透)
  - [ref的作用](#ref的作用)
  - [vue-router守卫](#vue-router守卫)
  - [vue修饰符](#vue修饰符)
  - [vue项目中的性能优化](#vue项目中的性能优化)
  - [Vue性能优化](#Vue性能优化)
  - [vue.extend和vue.component](#vueextend和vuecomponent)
  - [Vue的SPA如何优化加载速度](#Vue的SPA如何优化加载速度)
  - [移动端如何设计一个比较友好的Header组件](#移动端如何设计一个比较友好的Header组件)
  - [你是如何理解Vue的响应式系统的](#你是如何理解Vue的响应式系统的)
  - [既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异](#既然Vue通过数据劫持可以精准探测数据变化为什么还需要虚拟DOM进行diff检测差异)
  - [Vue为什么没有类似于React中shouldComponentUpdate的生命周期](#Vue为什么没有类似于React中shouldComponentUpdate的生命周期)
  - [说一下vue2.x中如何监测数组变化](#说一下vue2x中如何监测数组变化)
  - [vue中是如何检测数组变化的呢](#vue中是如何检测数组变化的呢)
  - [你的接口请求一般放在哪个生命周期中](#你的接口请求一般放在哪个生命周期中)
  - [Vue事件绑定原理说一下](#Vue事件绑定原理说一下)
  - [Vue模版编译原理知道吗，能简单说一下吗](#Vue模版编译原理知道吗能简单说一下吗)
  - [Vue2.x和Vue3.x渲染器的diff算法分别说一下](#Vue2x和Vue3x渲染器的diff算法分别说一下)
  - [再说一下虚拟Dom以及key属性的作用](#再说一下虚拟Dom以及key属性的作用)
  - [请说出vue.cli项目中src目录每个文件夹和文件的用法](#请说出vuecli项目中src目录每个文件夹和文件的用法)
  - [delete和Vue.delete删除数组的区别](#delete和Vuedelete删除数组的区别)
  - [v-on可以监听多个方法吗](#v-on可以监听多个方法吗)
  - [vue如何兼容ie的问题](#vue如何兼容ie的问题)
  - [Vue改变数组触发视图更新](#Vue改变数组触发视图更新)
  - [DOM渲染在哪个周期中就已经完成](#DOM渲染在哪个周期中就已经完成)
  - [动态绑定class](#动态绑定class)
  - [Vue3.0是如何变得更快的](#Vue30是如何变得更快的)
  - [说说你对proxy的理解](#说说你对proxy的理解)
  - [Composition API](#Composition-API)
  - [为什么Vue采用异步渲染呢](#为什么Vue采用异步渲染呢)
  - [Vuex工作原理](#Vuex工作原理)
  - [如何从真实DOM到虚拟DOM](#如何从真实DOM到虚拟DOM)
  - [为什么要使用异步组件](#为什么要使用异步组件)
  - [action与mutation的区别](#action与mutation的区别)
  - [插槽与作用域插槽的区别](#插槽与作用域插槽的区别)
  - [vue中相同逻辑如何抽离](#vue中相同逻辑如何抽离)
  - [谈谈对keep-alive的了解](#谈谈对keep-alive的了解)
  - [Vue3.0相对于Vue2.x有哪些不同](#Vue30相对于Vue2x有哪些不同)
  - [如何监听pushState和replaceState的变化呢](#如何监听pushState和replaceState的变化呢)
  - [Vue组件内的导航守卫有哪几个](#Vue组件内的导航守卫有哪几个)
  - [beforeRouteEnter和另外两个有什么不同吗](#beforeRouteEnter和另外两个有什么不同吗)
  - [完整的导航解析流程](#完整的导航解析流程)
  - [你是怎么看Vue和React的](#你是怎么看Vue和React的)
  - [Vue性能优化](#Vue性能优化)
    - [vue首屏加载优化有哪些方案么](#vue首屏加载优化有哪些方案么)
    - [编码阶段](#编码阶段)
    - [用户体验：](#用户体验)
    - [SEO优化](#SEO优化)
    - [打包优化](#打包优化)
  - [vue1.X，vue2.X，vue3框架分析性能](#vue1Xvue2Xvue3框架分析性能)
    - [Vue1.x（特点：响应式）](#Vue1x特点响应式)
    - [Vue2.x（特点：组件级响应式，组件内部vdom diff）](#Vue2x特点组件级响应式组件内部vdom-diff)
    - [Vue3（特点：proxy做响应式：静态标记、按需更新）](#Vue3特点proxy做响应式静态标记按需更新)



- [常用设计模式](#常用设计模式)
  - [创建型-工厂模式](#创建型-工厂模式)
    - [简单工厂模式](#简单工厂模式)
    - [抽象工厂模式](#抽象工厂模式)
  - [创建型-单例模式](#创建型-单例模式)
    - [单例模式的实现思路](#单例模式的实现思路)
    - [生产实践：Vuex中的单例模式](#生产实践Vuex中的单例模式)
    - [单例模式——面试真题](#单例模式面试真题)
    - [实现一个全局的模态框](#实现一个全局的模态框)
  - [结构型-装饰器模式](#结构型-装饰器模式)
    - [装饰器模式初相见](#装饰器模式初相见)
    - [深入装饰器原理](#深入装饰器原理)
    - [装饰器语法糖背后的故事](#装饰器语法糖背后的故事)
    - [将“属性描述对象”交到你手里](#将属性描述对象交到你手里)
    - [React中的装饰器：HOC](#React中的装饰器HOC)
    - [使用装饰器改写Redux connect](#使用装饰器改写Redux-connect)
  - [结构型-适配器模式](#结构型-适配器模式)
    - [兼容接口](#兼容接口)
    - [生产实践：axios中的适配器](#生产实践axios中的适配器)
  - [结构型-代理模式](#结构型-代理模式)
    - [ES6中的Proxy](#ES6中的Proxy)
    - [“婚介所”的实现](#婚介所的实现)
    - [事件代理](#事件代理)
    - [虚拟代理](#虚拟代理)
    - [缓存代理](#缓存代理)
  - [行为型-策略模式](#行为型-策略模式)
    - [先来看一个真实场景](#先来看一个真实场景)
    - [if-else侠，人人喊打](#if-else侠人人喊打)
    - [重构询价逻辑](#重构询价逻辑)
    - [总结](#总结)
  - [行为型-状态模式](#行为型-状态模式)
    - [一台咖啡机的诞生](#一台咖啡机的诞生)
    - [改造咖啡机的状态切换机制](#改造咖啡机的状态切换机制)
    - [开放封闭](#开放封闭)
    - [进一步改造](#进一步改造)
    - [状态模式复盘](#状态模式复盘)
  - [行为型-观察者模式](#行为型-观察者模式)
    - [生活中的观察者模式](#生活中的观察者模式)
    - [在实践中理解定义](#在实践中理解定义)
    - [Vue数据双向绑定（响应式系统）的实现原理](#Vue数据双向绑定响应式系统的实现原理)
    - [实现一个Event Bus/Event Emitter](#实现一个Event-BusEvent-Emitter)
    - [观察者模式与发布-订阅模式的区别是什么](#观察者模式与发布-订阅模式的区别是什么)
  - [行为型-迭代器模式](#行为型-迭代器模式)
    - [“公元前”的迭代器模式](#公元前的迭代器模式)
    - [ES6对迭代器的实现](#ES6对迭代器的实现)
    - [实现一个迭代器生成函数](#实现一个迭代器生成函数)
  - [中介者模式](#中介者模式)
  - [享元模式](#享元模式)



- [框架通识](#框架通识)
  - [MVVM](#MVVM)
  - [路由原理](#路由原理)
  - [（虚拟DOM）Virtual Dom](#虚拟DOMVirtual-Dom)
  - [Diff算法](#Diff算法)
    - [React-Diff](#React-Diff)
    - [Vue2.X Diff——双端比较](#Vue2X-Diff双端比较)
    - [Vue3 Diff——最长递增子序列](#Vue3-Diff——最长递增子序列)


- [React](#React)
  - [React生命周期](#React生命周期)
  - [组件之间通信](#组件之间通信)
  - [组件的渲染顺序](#组件的渲染顺序)
  - [React组件和渲染更新过程](#React组件和渲染更新过程)
  - [React都做过哪些优化](#React都做过哪些优化)
  - [React有哪些优化性能的手段](#React有哪些优化性能的手段)
  - [diff算法是怎么运作](#diff算法是怎么运作)
  - [React router](#React router)
  - [](#)  18 redux 中间件
  - [](#)  14 Redux实现原理解析
  - [](#)  17 聊聊 Redux 和 Vuex 的设计思想
  - [](#)  19 redux数据管理
  - [](#)  3. React Fiber是什么
  - [](#)  2 React Fiber架构
  - [](#)  5 React Fiber架构总结
  - [](#)  7 React事务机制
  - [](#)  2. 浏览器一帧都会干些什么以及requestIdleCallback的启示
  - [](#)  3 createElement过程
  - [](#)  5 setState
  - [](#)  6 setState原理分析
  - [](#)  4 调和阶段 setState内部干了什么
  - [](#)  22 如何避免ajax数据请求重新获取
  - [](#)  12 为什么 React 元素有一个 $$typeof 属性
  - [](#)  10 合成事件原理
  - [](#)  16 react hooks，它带来了那些便利
  - [](#)  15 connect组件原理分析
  - [](#)  11 JSX语法糖本质
  - [](#)  20 受控组件和非受控组件
  - [](#)  21 SSR原理



- [jQuery](#jQuery)
  - [针对jQuery的优化方法](#针对jQuery的优化方法)
  - [](#)  2 jQuery 的实现原理
  - [](#)  12 针对 jQuery 的优化方法
  - [](#)  17 jQuery对象的特点
  - [](#)  1 你觉得jQuery或zepto源码有哪些写的好的地方
  - [](#)  11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的
  - [](#)  5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝
  - [](#)  6 jQuery 的队列是如何实现的
  - [](#)  10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来
  - [](#)  9 jQuery 通过哪个方法和 Sizzle 选择器结合的
  - [](#)  3 jQuery.fn 的 init 方法返回的 this 指的是什么对象
  - [](#)  4 jQuery.extend 与 jQuery.fn.extend 的区别
  - [](#)  7 jQuery 中的 bind(), live(), delegate(), on()的区别
  - [](#)  8 是否知道自定义事件
  - [](#)  14 jQuery UI 如何自定义组件
  - [](#)  15 jQuery 与 jQuery UI、jQuery Mobile 区别
  - [](#)  13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢
  - [](#)  16 jQuery 和 Zepto 的区别？ 各自的使用场景


- [webpack相关](#webpack相关)
  - [webpack原理简述](#webpack原理简述)
    - [核心概念](#核心概念)
    - [工作流程(加载-编译-输出)](#工作流程加载-编译-输出)
    - [模块包装](#模块包装)
    - [webpack的打包原理](#webpack的打包原理)
    - [总结](#总结)
  - [webpack热更新原理](#webpack热更新原理)
  - [webpack Loader](#webpack-Loader)
  - [webpack Plugin](#webpack-Plugin)
  - [webpack编译优化](#webpack编译优化)
    - [优化webpack打包速度](#优化webpack打包速度)
  - [webpack import()原理](#webpack-import原理)
    - [动态导入原理](#动态导入原理)
    - [webpack中如何实现动态导入](#webpack中如何实现动态导入)
  - [webpack有哪几种文件指纹](#webpack有哪几种文件指纹)
    - [webpack如果使用了hash命名，那是每次都会重写生成hash吗](#webpack如果使用了hash命名那是每次都会重写生成hash吗)
    - [webpack中如何处理图片的](#webpack中如何处理图片的)
  - [webpack常用插件总结](#webpack常用插件总结)
  - [抽象语法树AST](#抽象语法树AST)
  - [使用babel-loader会有哪些问题？可以怎样优化](#使用babelloader会有哪些问题可以怎样优化)
  - [Babel原理](#Babel原理)
  - [Babel是如何编译Class的](#Babel是如何编译Class的)
  - [babel-polyfill是什么](#babel-polyfill是什么)
  - [Tree Shaking原理是什么](#Tree-Shaking原理是什么)
  - [Vite了解吗](#Vite了解吗)
  - [](#)  1 打包体积 优化思路
  - [](#)  2 打包效率
  - [](#)  3 Loader
  - [](#)  4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化


- [Node](#Node)
  - [package.json版本号规则](#packagejson版本号规则)
  - [npm模块安装机制](#npm模块安装机制)
  - [模块化的差异AMD CMD COMMONJS ESMODULE](#模块化的差异AMD-CMD-COMMONJS-ESMODULE)
  - [Node的Event Loop:6个阶段](#Node的Event-Loop6个阶段)
  - [Koa相关](#Koa相关)
  - [Express、koa实现原理以及对比](#Expresskoa实现原理以及对比)


- [微信小程序](#小程序)
  - [登录](#登录)
  - [图片导出](#图片导出)
  - [数据统计](#数据统计)
  - [工程化](#工程化)
  - [小程序架构](小程序架构)
  - [WXML&&WXSS](#WXMLWXSS)
  - [小程序的问题](#小程序的问题)
  - [授权获取用户信息流程](#授权获取用户信息流程)
  - [性能优化](#性能优化)
  - [wepy vs mpvue](#wepy-vs-mpvue)
  - [mpvue](#mpvue)
  - [](#)  5 微信小程序与vue区别
  - [](#)  1 微信小程序有几个文件
  - [](#)  2 微信小程序怎样跟事件传值
  - [](#)  3 小程序的 wxss 和 css 有哪些不一样的地方？
  - [](#)  4 小程序关联微信公众号如何确定用户的唯一性



- [Bootstrap](#Bootstrap)
  - [](#)  1 什么是Bootstrap？以及为什么要使用Bootstrap？
  - [](#)  2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？
  - [](#)  3 什么是Bootstrap网格系统
  - [](#)  4 Bootstrap 网格系统（Grid System）的工作原理
  - [](#)  5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么
  - [](#)  6 Bootstrap 网格系统列与列之间的间隙宽度是多少
  - [](#)  7 如果需要在一个标题的旁边创建副标题，可以怎样操作
  - [](#)  8 用Bootstrap，如何设置文字的对齐方式？
  - [](#)  9 Bootstrap如何设置响应式表格？
  - [](#)  10 使用Bootstrap创建垂直表单的基本步骤？
  - [](#)  11 使用Bootstrap创建水平表单的基本步骤？
  - [](#)  12 使用Bootstrap如何创建表单控件的帮助文本？
  - [](#)  13 使用Bootstrap激活或禁用按钮要如何操作？
  - [](#)  14 Bootstrap有哪些关于的class？
  - [](#)  15 Bootstrap中有关元素浮动及清除浮动的class？
  - [](#)  16 除了屏幕阅读器外，其他设备上隐藏元素的class？
  - [](#)  17 Bootstrap如何制作下拉菜单？
  - [](#)  18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？
  - [](#)  19 Bootstrap如何设置按钮的下拉菜单？
  - [](#)  20 Bootstrap中的输入框组如何制作？
  - [](#)  21 Bootstrap中的导航都有哪些？
  - [](#)  22 Bootstrap中设置分页的class？
  - [](#)  23 Bootstrap中显示标签的class？
  - [](#)  24 Bootstrap中如何制作徽章？
  - [](#)  25 Bootstrap中超大屏幕的作用是什么？


- [GIT](#git)
  - [git与svn的区别在哪里](#git与svn的区别在哪里)
  - [经常使用的git命令](#经常使用的git命令)
  - [git pull和git fetch的区别](#git-pull和git-fetch的区别)
  - [git rebase和git merge的区别](#git-rebase和git-merge的区别)







### 为什么用前端框架
- 1.前端框架是为了解决什么问题?
  - 前端要做的工作无非就是根据用户的操作将相应的数据展示到视图中。
  - 为保证状态与UI同步，前端工作人员除了将精力放在业务逻辑上，还需要将大量的精力放在操作DOM上。
  - 频繁的操作DOM，这样的结果导致了代码臃肿，不易维护，容易出错，且浏览器渲染开销大。
  - 为了解决UI与状态同步的问题，出现了前端框架。
  - 前端框架帮助我们减少DOM的操作，同时提高了渲染页面的性能。

- 2.DOM的操作昂贵在什么地方?
  - 访问dom的费用高，比较耗时。而且读取dom集合的length比数组消耗大很多。
  - 修改dom引起重排跟重绘，会伴随着重新渲染的巨大代价。

- 3.渲染引擎的工作流程
  - 解析HTML构建dom树=>构建渲染树=>渲染树布局=>绘制渲染树

- 4.什么是重绘和重排？
  - 重排：如果页面元素位置发生变化，就要从布局阶段重新开始渲染，也就是页面重排。页面重排一定会进行后续重绘。
  - 重绘：如果页面元素只是显示样式改变而布局不变，那么页面内容将会从绘制阶段开始。

- 5.什么情况下触发重排？
  - 修改dom元素的几何属性，dom树结构发生变化，改变浏览器大小等会触发重排的操作。

### 前端框架优缺点
- Web前端目前现有的UI框架：Bootstrap、JqueryUi、Foundation、Semantic UI、Pure、UIkit

- UI框架优缺点具体可参考：https://blog.csdn.net/qq_41852103/article/details/79619250

- Web前端目前现有的JS框架：JQuery、Zepto、VueJS、AngularJS、ReactJS、backbone 、ember

一、JQuery
- 优点：  
  - 1、轻量级：大小只有18KB。
  - 2、强大的选择器：JQuery允许开发者使用从CSS1到CSS3几乎所有的选择器，以及JQuery独创的高级而且复杂的选择器，另外还可以加入插件使其支持XPath选择器，甚至开发者可以编写属于自己的选择器。
  - 3、出色的DOM操作的封装：JQuery封装了大量常用的DOM操作
  - 4、可靠的事件处理机制：JQuery的事件处理机制吸收了JavaScript专家Dean Edwards编写的事件处理函数的精华，是的JQuery在处理事件绑定的时候相当可靠。在预留退路、循序渐进以及非入侵式编程思想方面，JQuery也做得非常不错。
  - 5、完善的Ajax：JQuery将所有的Ajax操作封装到一个函数$.ajax()里，使得开发者处理Ajax的时候能够专心处理业务逻辑而无需关心复杂的浏览器兼容性和XMLHttpRequest对象的创建和使用的问题。
  - 6、不污染顶级变量：JQuery只建立一个名为JQuery的对象，其所有的函数方法都在这个对象之下。其别名$也可以随时交流控制权，绝对不会污染其他的对象。该特性是JQuery可以与其他JavaScript库共存，在项目中放心地引用而不需要考虑到后期的冲突。
  - 7、出色的浏览器兼容性：JQuery能够在IE6.0+,FF 2+,Safari2.+和Opera9.0+下正常运行。JQuery同时修复了一些浏览器之间的的差异，使开发者不必在开展项目前建立浏览器兼容库。
  - 8、链式操作方式：JQuery中最有特色的莫过于它的链式操作方式——即对发生在同一个JQuery对象上的一组动作，可以直接接连写无需要重复获取对象。这一特点使得JQuery的代码无比优雅。
  - 9、隐式迭代：当用JQuery找到带有“.myClass”类的全部元素，然后隐藏他们时。无需循环遍历每一个返回的元素。相反，JQuery里的方法都被设计成自动操作的对象集合，而不是单独的对象，这使得大量的循环结构变得不再必要，从而大幅度地减少代码量。
  - 10、行为层与结构层的分离：开发者可以使用选择器选中元素，然后直接给元素添加事件。这种将行为层与结构层完全分离的思想，可以使JQuery开发人员和HTML或其他页面开发人员各司其职，摆脱过去开发冲突或个人单干的开发模式。同时，后期维护也非常方便，不需要在HTML代码中寻找某些函数和重复修改HTML代码。
  - 11、丰富的插件支持：JQuery的易扩展性，吸引了来自全球开发者来编写JQuery的扩展插件。目前已经有超过几百种官方插件支持，而且还不断有新插件面试。
  - 12、完善的文档：JQuery的文档非常丰富，例如JQuery的中文API。
  - 13、开源：JQuery是一个开源的产品，任何人都可以自由地使用并提出修改意见。
 
- 缺点：
  - 1、不能向后兼容：每一个新版本不能兼容早期的版本。举例来说，有些新版本不再支持某些selector，新版jQuery却没有保留对它们的支持，而只是简单的将其移除。这可能会影响到开发者已经编写好的代码或插件。
  - 2、插件兼容性：与上一点类似，当新版jQuery推出后，如果开发者想升级的话，要看插件作者是否支持。通常情况下，在最新版jQuery版本下，现有插件可能无法正常使用。开发者使用的插件越多，这种情况发生的几率也越高。我有一次为了升级到jQuery 1.3，不得不自己动手修改了一个第三方插件。
  - 3、多个插件冲突：在同一页面上使用多个插件时，很容易碰到冲突现象，尤其是这些插件依赖相同事件或selector时最为明显。这虽然不是jQuery自身的问题，但却又确实是一个难于调试和解决的问题。
  - 4、jQuery的稳定性：jQuery没有让浏览器崩溃，这里指的是其版本发布策略。jQuery 1.3版发布后仅过数天，就发布了一个漏洞修正版1.3.1。他们还移除了对某些功能的支持，可能会影响许多代码的正常运行。
  - 5、对动画和特效的支持差：在大型框架中，jQuery核心代码库对动画和特效的支持相对较差。但是实际上这不是一个问题。目前在这方面有一个单独的jQuery UI项目和众多插件来弥补此点。


三、VueJS
- 其实Vue.js不是一个框架，因为它只聚焦视图层，是一个构建数据驱动的Web界面的库。

- Vue.js通过简单的API（应用程序编程接口）提供高效的数据绑定和灵活的组件系统。

- Vue.js的特性如下：
  - 1.轻量级的框架
  - 2.双向数据绑定
  - 3.指令
  - 4.插件化

- 优点： 
  - 1. 简单：官方文档很清晰，比 Angular 简单易学。
  - 2. 快速：异步批处理方式更新 DOM。
  - 3. 组合：用解耦的、可复用的组件组合你的应用程序。
  - 4. 紧凑：~18kb min+gzip，且无依赖。
  - 5. 强大：表达式 & 无需声明依赖的可推导属性 (computed properties)。
  - 6. 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。
 
- 缺点：  
  - 1. 新生儿：Vue.js是一个新的项目，没有angular那么成熟。
  - 2. 影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库。
  - 3. 不支持IE8：

 
四、AngularJS
- angularJS是一款优秀的前端JS框架，已经被用于Google的多款产品当中。
```
　　angularJS的特性如下：

　　　　1.良好的应用程序结构

　　　　2.双向数据绑定

　　　　3.指令

　　　　4.HTML模板

　　　　5.可嵌入、注入和测试

 

　　优点： 1.  模板功能强大丰富，自带了极其丰富的angular指令。

　　　　　 2. 是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；

　　　　    3. 自定义指令，自定义指令后可以在项目中多次使用。

　　　　　 4. ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。

　　　　　 5. angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。
 
　　缺点： 1. angular 入门很容易 但深入后概念很多, 学习中较难理解.

　　            2. 文档例子非常少, 官方的文档基本只写了api, 一个例子都没有, 很多时候具体怎么用都是google来的, 或直接问misko,angular的作者.

　　　　　 3. 对IE6/7 兼容不算特别好, 就是可以用jQuery自己手写代码解决一些.

　　　 　    4. 指令的应用的最佳实践教程少, angular其实很灵活, 如果不看一些作者的使用原则,很容易写出 四不像的代码, 例如js中还是像jQuery的思想有很多dom操作.

　　　　     5. DI 依赖注入 如果代码压缩需要显示声明

                   6. AngularJS的路由机制，很容易出问题

                   7. 验证功能错误信息显示比较薄弱，需要写很多模板标签

                   8. ngView只能有一个，不能嵌套多个视图，虽然有angular-ui/ui-router 解决，但ui-router 对于URL的控制不是很灵活，必须是嵌套式的

                  9. 这次从1.0.X升级到1.2.X，貌似有比较大的调整，没有完美兼容低版本，升级之后可能会导致一个兼容性的BUG

 

五、ReactJS


 React主要用于构建UI。你可以在React里传递多种类型的参数，如声明代码，帮助你渲染出UI、也可以是静态的HTML DOM元素、也可以传递动态变量、甚至是可交互的应用组件。
 
　  React特性如下：　
　　　　1.声明式设计：React采用声明范式，可以轻松描述应用。

　　　　2.高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。

　　　　3.灵活：React可以与已知的库或框架很好地配合。

 

　　优点： 1. 速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。

　　　　　 2. 跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。

　　　　　 3. 模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。

　　　　 　4. 单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。

　　　　　 5. 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。

　　　　　 6. 兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。

 

　　缺点： 1. React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。

 
 
二、Zepto
Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。简单的说，jquery用于电脑端开发，Zepto用于手机端开发。



优点：轻量级，适合移动端开发

缺点： Zepto 不支持旧版本的 Internet Explorer浏览器(<10)。


六、BackboneJS


Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。

Backbone唯一重度依赖的是Underscore.js( >= 1.5.0)（注：Underscore.js 中文文档请查看 http://www.html.cn/doc/underscore/）。基于RESTful（一个架构样式的网络系统）的约束，histroy的支持依赖于Backbone.Router ，DOM处理依赖于 Backbone.View，包括jQuery ( >= 1.11.0), 和 json2.js对旧的IE浏览器的支持。（模仿Underscore 和 jQuery 的APIs，例如 Lo-Dash 和 Zepto，在不同的兼容性下也一样能运行）

~~~~具体等学习到了，再补充~~~~~~

 
七、EmberJS


Ember.js是一个开源的JavaScript客户端框架，用于开发Web应用程序并使用MVC（模型 - 视图 - 控制器）架构模式。在Ember.js中，路由用作模型，句柄模板作为视图，控制器处理模型中的数据。
```

#### 前端打包工具
- gulp是一个前端自动化构建工具，通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。

全局安装
```
npm install --global gulp
```

作为项目的开发依赖(devDependencies)安装
```
npm install --save-dev gulp
```

在项目根目录下创建一个名为 glupfile.js 的文件
```
var gulp = require('gulp');

gulp.task('default', function() {
  // 将你的默认的任务代码放在这
});
```

运行 gulp
```
gulp
```

实验
- 我们使用gulp-uglify来压缩js文件，减少文件大小

在刚才建立的项目里安装 gulp-uplify 插件
```
npm install gulp-uglify --save-dev
```

再安装一个合并文件的插件 gulp-concat
```
npm install gulp-concat --save-dev
```

修改上面的 glupfile.js
```
var gulp = require('gulp'),
uglify = require('gulp-uglify'),
concat = require('gulp-concat');

//建立一个名为jsmin的任务
gulp.task('jsmin',function(){
	// 压缩src目录下(**表示子目录)的所有.js文件，
	// 压缩test/test.js文件，
	// 不包括src目录（**子目录）下的test1.js和test2.js
	// 作为下一个任务的依赖，我们返回这个执行流，这样就可以在本任务执行完后执行下一个任务
	return gulp.src(['src/**/*.js','test/test.js','!src/**/{test1,test2}.js']) //多个文件以数组形式传入
		.pipe(uglify()) //使用相应的工具
		.pipe(gulp.dest('dist/js')) //执行压缩后保存的文件夹
});

//建立一个名为testConcat的任务,在jsmin任务执行完后执行
gulp.task('testConcat',['jsmin'],function(){
	gulp.src('dist/js/**/*.js')
		.pipe(concat('all.js')) //合并之后的文件名
		.pipe(gulp.dest('dist/js2')) //合并之后保存的路径
})

//建立一个默认执行的任务，这个任务顺序执行上面创建的N个任务
gulp.task('default',['testConcat'])
```

- 命令行里运行 gulp 命令，就发现dist/js2/all.js 合并压缩了之前指定的文件，上面的例子本可以在一个任务里完成，我是为了演示多任务依赖而分成了两个任务。

Rollup
- Rollup 是下一代的 javascript 打包器，它使用 tree-shaking 的技术使打包的结果只包括实际用到的 exports。 使用它打包的代码，基本没有冗余的代码，减少了很多的代码体积

###命令行方式###
全局安装Rollup
```
npm install -g rollup
```

打包命令
```
rollup src/index.js -o  bundle.js -f cjs
```

###javascript 调用方式###
新建package.json文件
```
npm init
```

安装依赖
打开package.json文件，增加依赖项
```
"devDependencies": {
    "babel-core": "^6.22.1",
    "babel-preset-es2015-rollup": "^3.0.0",
    "rollup": "^0.41.4",
    "rollup-plugin-babel": "^2.7.1",
    "rollup-plugin-commonjs": "^7.0.0",
    "rollup-plugin-node-resolve": "^2.0.0",
    "rollup-plugin-uglify": "^1.0.1"
  }
```

命令行运行
```
npm install
```

编写打包的代码
建一个build.js文件，内容如下
```
var rollup = require('rollup');
var babel = require('rollup-plugin-babel');
var uglify = require('rollup-plugin-uglify');
var npm = require('rollup-plugin-node-resolve');
var commonjs = require('rollup-plugin-commonjs');

rollup.rollup({
    entry: 'src/index.js', //打包入口文件
    plugins: [
        npm({ jsnext: true, main: true }),
        uglify(), //压缩代码
        commonjs(), //支持CommonJS模块语法
        babel({  //babel配置
            exclude: 'node_modules/**',
            presets: [ "es2015-rollup" ]
        })
    ]
}).then(function(bundle) {
    bundle.write({
    	 // output format - 'amd', 'cjs', 'es6', 'iife', 'umd'
       // amd – 使用像requirejs一样的银木块定义
       // cjs – CommonJS，适用于node和browserify / Webpack
       // es6 (default) – 保持ES6的格式
       // iife – 使用于<script> 标签引用的方式
       // umd – 适用于CommonJs和AMD风格通用模式
        format: 'cjs',  //指定要打包成什么格式
        dest: 'dist/main.js' //编译完的文件需要被存放的路径
    });
});
```

打包
```
node build.js
```

webpack
- webpack是一个前端模块打包器

安装命令
```
npm install webpack -g
```

使用webpack
```
npm init #会生成package.json文件
npm install webpack --save-dev #将webpack增加到package.json文件中
```

配置文件
根目录下新建webpack.config.js
```
module.exports = {
	//页面入口文件配置
	entry:{
		index:'./src/index.js'
	},
	//编译输出配置
	output:{
		filename:'bundle.js'
	}
}
```

根目录下新建 index.html ,内容如下
```
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<script src="bundle.js"></script>
</body>
</html>
```

命令行运行
```
webpack
```

就可以把 src/index.js 的内容打包输出到 bundle.js ，其他主要参数有：
```
webpack --config xxx.js #使用另一份配置文件来打包
webpack --watch  #监听变动并自动打包
webpack -p  #压缩混淆脚本
webpack -d #生成map映射文件，告知哪些模块被最终打包到哪里了
```

###安装webpack-dev-server###
在全局环境中安装 webpack-dev-server
```
npm install webpack-dev-server -g
```

在项目根目录下执行命令：
```
webpack-dev-server
```
打开浏览器 http://localhost:8080/index.html 就可以看到输出了

###安装Babel加载器###
babel可以翻译es6到es5，使用下面命令安装babel-loader
```
npm install babel-loader babel-core babel-preset-es2015 --save-dev
```

配置webpack.config.js,添加babel-loader引导器,在module.exports添加module：
```
module.exports = {
	//页面入口文件配置
	entry:{
		index:'./src/index.js'
	},
	//编译输出配置
	output:{
		filename:'bundle.js'
	},
	module:{
		//模块加载器
		loaders:[{
			test:/\.js$/,
			loaders:['babel-loader?presets[]=es2015'],
			exclude:/node_modules/
		}]
	}
}
```
运行 webpack-dev-server 命令发现支持es6了

###CSS加载器###
- 在webpack里，CSS同样可以模块化，使用import导入，因此我们不再使用 link 标签来引用 CSS，而是通过 webpack 的 style-loader 及 css-loader。前者将 css 文件以标签插入头部，后者负责解读、加载 CSS 文件。

安装CSS相关的加载器
```
npm install style-loader css-loader --save-dev
```

配置webpack.config.js文件
```
module:{
	//模块加载器
	loaders:[{
		test:/\.js$/,
		loaders:['babel-loader?presets[]=es2015'],
		exclude:/node_modules/
	},{
		test:/\.css$/,
		loaders:['style','css']
	}]
},
```

###autoprefixer###
- 我们在写 CSS 时，按 CSS 规范写，构建时利用 autoprefixer 可以输出 -webkit、-moz 这样的浏览器前缀，webpack 同样是通过 loader 提供该功能。

安装 autoprefixer-loader
```
npm install autoprefixer-loader --save-dev
```

配置 webpack.config.js
```
module:{
	//模块加载器
	loaders:[{
		test:/\.js$/,
		loaders:['babel-loader?presets[]=es2015'],
		exclude:/node_modules/
	},{
		test:/\.css$/,
		loaders:['style-loader','css-loader','autoprefixer-loader']
	}]
},
```
重启webpack-dev-server，发现可以为css添加浏览器前缀了。

###代码压缩###
- webpack自带了一个压缩插件 UglifyJsPlugin ,只需要在配置文件中引入即可。
```
plugins:[
	new webpack.optimize.UglifyJsPlugin({
		compress:{
			warnings:false
		}
	})
]
```
加入了这个插件后，编译的速度会明显变慢，所有一般只在生产环境中启用。

gulp与webpack-stream集成配置
- webpack非常强大,但是也有不足的地方,批量式处理依然是gulp更胜一筹.我们是否可以将两者的优点结合起来呢? 这篇文章就是讲述如何集成gulp和webpack

安装
```
npm init #生成package.json
npm install --save-dev webpack-stream vinyl-named #vinyl-named用来保持输入和输出的文件名相同, 否则会自动生成一个hash
npm install --save-dev gulp #安装gulp
npm install babel-loader babel-core babel-preset-es2015 --save-dev #安装babel
touch gulpfile.js  #创建gulp配置文件
touch webpack.config.js #创建webpack配置文件
```

配置gulpfile.js
```
var gulp = require('gulp');
var webpack = require('webpack-stream');
var named = require('vinyl-named');
var webpackConfig = require('./webpack.config.js');

//定义一个webpack任务
gulp.task('webpack',function(){
	return gulp.src('./src/index.js') //目标文件
		.pipe(named())  //vinyl-named用来保持输入和输出的文件名相同, 否则会自动生成一个hash.
		.pipe(webpack(webpackConfig)) //调用webpack来处理流
		.pipe(gulp.dest('./dist/')) //处理完成后保存的目录
})

//定义一个默认任务
gulp.task('default',['webpack']); //定义一个默认gulp任务，让它运行webpack任务
```

配置webpack.config.js
```
module.exports = {
	watch:true,
	devtool:'source-map',
	resolve:{
		extensions:['','.js']
	},
	module:{
		loaders:[{
			test:/\.js$/,
			loader:'babel-loader',
			query:{
				presets:['es2015']
			}
		}]
	}
}
```
注意：用webpack-stream不需要配置entry和output

运行任务
在src目录下新建index.js主入口文件，内容如下
```
import {sum,square,variable,MyClass} from './import';
console.log(square(5));
var cred={
    name:'hello world',
    enrollmentNo:11115078
}
var x = new MyClass(cred);
console.log(x.getName());
index.js文件引入了import.js的文件，内容如下

var sum = (a, b = 6)=>(a + b);
var square = (b)=> {
    "use strict";
    return b * b;
};
var variable = 8;
class MyClass{
    constructor(credentials){
        this.name = credentials.name;
        this.enrollmentNo = credentials.enrollmentNo
    }
    getName(){
        return this.name;
    }
}
export {sum,square,variable, MyClass};
```

现在运行：
```
gulp
```
- gulp已经使用webpack监测了index.js文件的改变，每当index.js有改变的时候，会重新打包生成dist/index.js


#### 为什么要打包
打包是在做什么
- 前端写代码时为了方便会将代码写在许多文件中，但是转化成HTML代码时，会使用<script>标签进行引入js代码，这样会使页面进行的http衍生请求次数的次数增多，页面加载耗能增加。使用打包过后将许多零碎的文件打包成一个整体，页面只需请求一次，js文件中使用模块化互相引用（export、import ），这样能在一定程度上提供页面渲染效率。
- 打包同时会进行编译，将ES6、Sass等高级语法进行转换编译，以兼容高版本的浏览器。

必须要打包吗？
- 上文提到的HTML需要引用有很多文件会导致请求的数量很多，但如果页面请求一次的话页面需要将许多次请求压缩成一次，就会导致页面第一次加载很慢，这也是打包过程中的一个弊端。
- 但是反过来想，假如这个工程很小，那么打包还是必需的吗？为了提升一点点的效率需要多加很多的工作量，这样明显是划不来的。
- 其次，打包另一个重要作用是编译，将浏览器无法识别的ES6等高级语法编辑成浏览器可识别的ES5语法，但假如有一天浏览器可以识别ES6甚至ES7等语法，那么Babel、webpack就不是必须的了。

- 但是目前为止浏览器版本、项目量级导致现在打包还是比较有必要的。

怎么打包
- 现在比较流行的打包工具有Webpack、Gulp、Grunt。
- 但是Gulp、Grunt与其说是打包工具不如说是构建工具。


#### webpack打包好处
介绍webpack，首先记住两个词
- 模块
- 打包

- 如果不打包的话，我们的项目中有很多文件会相互依赖，有几个文件就要发多少次请求来获取文件，如果一个文件因为网络问题延误了整个页面也会延误，而当我们的项目逐渐变大，有几十个到上百个JavaScript文件的时候，那问题会更严重，不但有延迟问题，还会遇到很难维护的问题

- 而webpack就解决了这些问题，把所有JavaScript文件合成一个文件，这样就减少了http请求数量，让我们的页面加载和显示更快。不过这个合并的阶段是在开发完成之后才进行的，也就是说开发阶段我仍然是有a.js，b.js和c.js等等这些文件的，这样才好开发和维护，因为如果开发阶段就合并的话，就相当于我基于一个可能上万行的文件进行开发，这样的代码是没法维护的。

- 在开发后完成的这个合并的过程就是打包，这样你就明白为什么要打包了吧。webpack在打包过程中，会分析各个文件之间的依赖关系，然后生成一个依赖图并用文件的形式保存下来，未来浏览器运行代码的时候就可以读取这个文件，就知道了各个代码块之间的关联以及如何调用了。

- 注意：webpack除了能打包js文件，还可以打包css, scss, jpg, svg等

总结：
- 在webpack中，每个文件都可以看作是一个模块，打包是webpack最核心的功能，webpack其它所有的功能都是为了让打包这个功能更好。我们从一个简单的html页面介绍了通过webpack对模块进行打包，既保留了单个模块的可维护性，又减少了页面的http请求，减少了页面加载时间，从而增加了页面的显示速度，让整个应用的体验更好。



### VUE

  #### vue的生命周期函数
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

生命周期是什么
```
Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、
编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，
我们称这是Vue的生命周期
```

各个生命周期的作用
- 生命周期	描述
- beforeCreate	组件实例被创建之初，组件的属性生效之前
- created	组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用
- beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用
- mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
- beforeUpdate	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前
- update	组件数据更新之后
- activited	keep-alive专属，组件被激活时调用
- deadctivated	keep-alive专属，组件被销毁时调用
- beforeDestory	组件销毁前调用
- destoryed	组件销毁后调用

```
由于Vue会在初始化实例时对属性执行getter/setter转化，
所以属性必须在data对象上存在才能让Vue将它转换为响应式的。
Vue提供了$set方法用来触发视图更新

export default {
    data(){
        return {
            obj: {
                name: 'fei'
            }
        }
    },
    mounted(){
        this.$set(this.obj, 'sex', 'man')
    }

}
```

什么是vue生命周期？
- Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

vue生命周期的作用是什么？
- 它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

vue生命周期总共有几个阶段？
- 它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。

第一次页面加载会触发哪几个钩子？
- 会触发下面这几个beforeCreate、created、beforeMount、mounted 。

DOM 渲染在哪个周期中就已经完成？
- DOM 渲染在 mounted 中就已经完成了

```
beforeCreate:
在实例初始化之后，数据观测 (data observer) 和 event/watcher 
事件配置之前被调用。

在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西
都还没创建。在beforeCreate生命周期执行的时候，data和methods中的
数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法

created:
在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：
数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。
然而，挂载阶段还没开始，\$el property 目前尚不可用。

data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，
或者操作 data 中的数据，最早可以在这个阶段中操作

beforeMount:
在挂载开始之前被调用：相关的 render 函数首次被调用。

执行到这个钩子的时候，在内存中已经编译好了模板了，
但是还没有挂载到页面中，此时，页面还是旧的

mounted:
实例被挂载后调用，这时 el 被新创建的 vm.\$el 替换了。
如果根实例挂载到了一个文档内的元素上，
当 mounted 被调用时 vm.\$el 也在文档内。

执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件
脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作
页面上的DOM节点，最早可以在这个阶段中进行

beforeUpdate:
当执行这个钩子时，页面中的显示的数据还是旧的，
data中的数据是更新后的， 页面还没有和最新的数据保持同步

updated:
页面显示的数据和data中的数据已经保持同步了，都是最新的

beforeDestroy:
Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 
methods，指令，过滤器……都是处于可用状态，还没有真正被销毁

destroyed:
这个时候上所有的 data 和 methods，指令，过滤器……
都是处于不可用状态，组件已经被销毁了。

activated:
被 `keep-alive` 缓存的组件激活时调用。

deactivated:
被 `keep-alive` 缓存的组件停用时调用。
```

```
init：
1.initLifecycle/Event，往vm上挂载各种属性
2.callHook: beforeCreated: 实例刚创建
3.initInjection/initState: 初始化注入和 data 响应性
4.created: 创建完成，属性已经绑定， 但还未生成真实dom`
5.进行元素的挂载： $el / vm.$mount()
6.是否有template: 解析成 render function
    *.vue文件: vue-loader会将<template>编译成render function
7.beforeMount: 模板编译/挂载之前
8.执行render function，生成真实的dom，并替换到dom tree中
9.mounted: 组件已挂载

update：
1.执行diff算法，比对改变是否需要触发UI更新
2.flushScheduleQueue
3.watcher.before: 触发beforeUpdate钩子 - watcher.run(): 
  执行watcher中的 notify，通知所有依赖项更新UI
4.触发updated钩子: 组件已更新
5.actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活
6.destroy
  beforeDestroy: 销毁开始
  销毁自身且递归销毁子组件以及事件监听
    remove(): 删除节点
    watcher.teardown(): 清空依赖
    vm.$off(): 解绑监听
  destroyed: 完成后触发钩子
  
  
Vue2和Vue3对比：
Vue2	                  Vue3
beforeCreate	          setup(替代)
created	                setup(替代)
beforeMount	            onBeforeMount
mounted	                onMounted
beforeUpdate           	onBeforeUpdate
updated	                nUpdated
beforeDestroy	          onBeforeUnmount
destroyed	              onUnmounted
errorCaptured          	onErrorCaptured
-	                      onRenderTracked
-	                      onRenderTriggered


上面是vue的声明周期的简单梳理，
接下来我们直接以代码的形式来完成vue的初始化：
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```

#### 生命周期详解
init
- initLifecycle/Event，往vm上挂载各种属性
- callHook: beforeCreated: 实例刚创建
- initInjection/initState: 初始化注入和 data 响应性
- created: 创建完成，属性已经绑定， 但还未生成真实dom`
- 进行元素的挂载： $el / vm.$mount()
- 是否有template: 解析成 render function
  - *.vue文件: vue-loader会将<template>编译成render function
- beforeMount: 模板编译/挂载之前
- 执行render function，生成真实的dom，并替换到dom tree中
- mounted: 组件已挂载

update
- 执行diff算法，比对改变是否需要触发UI更新
- flushScheduleQueue
- watcher.before: 触发beforeUpdate钩子 - watcher.run(): 执行watcher中的 notify，通知所有依赖项更新UI
- 触发updated钩子: 组件已更新
- actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活
- destroy
  - beforeDestroy: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听
    - remove(): 删除节点
    - watcher.teardown(): 清空依赖
    - vm.$off(): 解绑监听
  - destroyed: 完成后触发钩子

- 上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化
```
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```

  #### 简述每个周期具体适合哪些场景
- beforecreate : 可以在这加个loading事件，在加载实例时触发
- created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
- mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数
- beforeDestroy : 可以做一个确认停止事件的确认框

> 第一次加载会触发哪几个钩子
> 会触发beforeCreate , created ,beforeMount ,mounted
  
  #### vue组件间传递参数、传值通信
> 组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯

父组件与子组件传值
- 父组件传给子组件：子组件通过props方法接受数据；
- 子组件传给父组件： $emit 方法传递参数

非父子组件间的数据传递，兄弟组件传值
- eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求）


- 1. 父组件给子组件传值
使用props，父组件可以使用props向子组件传递数据。
```
父组件vue模板father.vue:
<template>
    <child :msg="message"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    data () {
        return {
            message: 'father message';
        }
    }
}
</script>
```

子组件vue模板child.vue:
```
<template>
    <div>{{msg}}</div>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    }
}
</script>
```

- 2. 子组件向父组件通信
父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件
```
父组件vue模板father.vue:
<template>
    <child @msgFunc="func"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    methods: {
        func (msg) {
            console.log(msg);
        }
    }
}
</script>
```

子组件vue模板child.vue:
```
<template>
    <button @click="handleClick">点我</button>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    methods () {
        handleClick () {
            //........
            this.$emit('msgFunc');
        }
    }
}
</script>
```

- 3. 非父子, 兄弟组件之间通信
```
vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以
用props和$emit()。如何实现非父子组件间的通信，可以通过实例
一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，
然后通过分别调用Bus事件触发和监听来实现通信和参数传递。

Bus.js可以是这样:
import Vue from 'vue'
export default new Vue()
```

在需要通信的组件都引入Bus.js:
```
<template>
	<button @click="toBus">子组件传给兄弟组件</button>
</template>

<script>
import Bus from '../common/js/bus.js'
export default{
	methods: {
	    toBus () {
	        Bus.$emit('on', '来自兄弟组件')
	    }
	  }
}
</script>
```

另一个组件也import Bus.js 在钩子函数中监听on事件
```
import Bus from '../common/js/bus.js'
export default {
    data() {
      return {
        message: ''
      }
    },
    mounted() {
       Bus.$on('on', (msg) => {
         this.message = msg
       })
     }
   }
```

Vue子组件调用父组件的方法
- 第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法
- 第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。
  
  #### Vue中父子组件生命周期执行顺序
```
在单一组件中，钩子的执行顺序是
beforeCreate-> created -> mounted->... ->destroyed
```

父子组件生命周期执行顺序：

加载渲染过程
  ```txt
  父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
  ```

更新过程
  ```txt
  父beforeUpdate->子beforeUpdate->子updated->父updated
  ```

销毁过程
  ```txt
  父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
  ```

常用钩子简易版
  ```txt
  父create->子created->子mounted->父mounted
  ```

  #### vue双向数据绑定原理
```
vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。
vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

首先我们通过 Object.defineProperty() 方法来对 Model 数据各个
属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据
发生变化的时候，我们可以通过配置的 setter 和 getter 方法来
实现对 View 层数据更新的通知。

数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 
value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。

如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中
去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。
然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化
的时候触发该事件，通知 Model 中的对应的属性的值进行更新。

如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来
替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，
属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象
加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，
Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，
订阅者收到通知后更改自己的数据。
```

```
vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，
通过 Object.defineProperty() 来劫持各个属性的setter，getter，
在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 
Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历
它的属性，用 Object.defineProperty() 将它们转为 getter/setter。
用户看不到 getter/setter，但是在内部它们让 Vue追踪依赖，
在属性被访问和修改时通知变化。
vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，
Compile和Watcher三者，通过Observer来监听自己的model的数据变化，
通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终
利用watcher搭起observer和Compile之间的通信桥梁，达到数据
变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
```
  
  #### v-model双向绑定原理
- v-model本质上是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件

- text 和 textarea 元素使用 value 属性和 input 事件
- checkbox 和 radio 使用 checked 属性和 change 事件
- select 字段将 value 作为 prop 并将 change 作为事件

所以我们可以v-model进行如下改写：
```
<input v-model="sth" />
//  等同于
<input :value="sth" @input="sth = $event.target.value" />
```
- 这个语法糖必须是固定的，也就是说属性必须为value，方法名必须为：input。
- 知道了v-model的原理，我们可以在自定义组件上实现v-model
```
//Parent
<template>
    {{num}}
    <Child v-model="num">
</template>
export default {
    data(){
        return {
            num: 0
        }
    }
}

//Child
<template>
    <div @click="add">Add</div>
</template>
export default {
    props: ['value'],
    methods:{
        add(){
            this.$emit('input', this.value + 1)
        }
    }
}
```

说一下v-model的原理
- v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性

#### v-model中的实现原理及如何自定义v-model
- v-model 可以看成是 value+input 方法的语法糖（组件）。原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来

- 自定义：自己写 model 属性，里面放上 prop 和 event

  #### Vue是如何实现双向绑定的
```
利用Object.defineProperty劫持对象的访问器,在属性值发生
变化时我们可以获取变化,然后根据变化进行后续响应,
在vue3.0中通过Proxy代理对象进行类似的操作。
```

```
// 这是将要被劫持的对象
const data = {
  name: '',
};

function say(name) {
  if (name === '古天乐') {
    console.log('给大家推荐一款超好玩的游戏');
  } else if (name === '渣渣辉') {
    console.log('戏我演过很多,可游戏我只玩贪玩懒月');
  } else {
    console.log('来做我的兄弟');
  }
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function(key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      console.log('get');
    },
    set: function(newVal) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`大家好,我系${newVal}`);
      say(newVal);
    },
  });
});

data.name = '渣渣辉';
//大家好,我系渣渣辉
//戏我演过很多,可游戏我只玩贪玩懒月
```

  #### vuex
vuex是什么？怎么使用？哪种功能场景使用它？
- 只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
- 在main.js引入store，注入。新建了一个目录store，… export
- 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车

- state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。
- mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据
- getters：类似vue的计算属性，主要用来过滤一些数据。
- action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action
```
const store = new Vuex.Store({ //store实例
	state : {
            count: 0
	},
	mutations: {
	    increment (state) { 
		state. count++
	    }
	},
	actions: {
	    increment (context) {
		context. commit( ' inc rement ' )
	    }
	}
})
```

- modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理
```
const moduleA = {
	state : { ... },
	mutations : { ... },
	actions: { ... },
	getters: { ... }
}

const moduleB = {
	state: { ... },
	mutations :{ ... },
	actions: { ... }
}

const store = new Vuex.Store({
	modules: {
		a: modu LeA, 
		b: moduleB
	}
})
```

vuex是什么？怎么使用？哪种功能场景使用它？
```
vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源
存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是
响应式的，vue 组件从store 读取数据，若是 store 中的数据发生改变，
依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 
和 getters 映射到当前组件的 computed 计算属性vuex的使用借助官方提供的来说明:
```

Vuex有5种属性: 分别是 state、getter、mutation、action、module;
state
- Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据

mutations
- mutations定义的方法动态修改Vuex 的 store 中的状态或数据。

getters
- 类似vue的计算属性，主要用来过滤一些数据

action
- actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。
- vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。
- 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题
- vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据 2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态
- 一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：
- 开发时，改变数组或者对象的数据，但是页面没有更新如何解决？
- vue弹窗后如何禁止滚动条滚动？
- 如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件

vuex 是什么？ 有哪几种属性？
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。
- 有 5 种，分别是 state、getter、mutation、action、module
vuex 的 store 是什么？
- vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性

vuex 的 getter 是什么？
- getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters

vuex 的 mutation 是什么？
- 更改Vuex的store中的状态的唯一方法是提交mutation

vuex 的 action 是什么？
- action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作
- vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中

vuex 的 module 是什么？
- 面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。
- 如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回


```
Vuex 集中式存储管理应用的所有组件的状态，
并以相应的规则保证状态以可预测的方式发生变化

核心概念：
state: 状态中心
mutations: 更改状态
actions: 异步更改状态
getters: 获取状态
modules: 将state分成多个modules，便于管理

1.状态 - state
state保存应用状态

export default new Vuex.Store({ state: { counter:0 },})

2.状态变更 - mutations
mutations用于修改状态，store.js

export default new Vuex.Store({
    mutations:
    {
      add(state) {
        state.counter++
      }
    }
  })
  
3.派生状态 - getters
从state派生出新状态，类似计算属性

export default new Vuex.Store({
    getters:
    {
      doubleCounter(state) { // 计算剩余数量 return state.counter * 2;
      }
    }
  })
  
4.动作 - actions
加业务逻辑，类似于controller

export default new Vuex.Store({
    actions:
    {
      add({
        commit
      }) {
        setTimeout(() = >{}
      }
    })
测试代码:

<p @click="$store.commit('add')">counter: {{$store.state.counter}}</p>
<p @click="$store.dispatch('add')">async counter: {{$store.state.counter}}</p>
<p>double:{{$store.getters.doubleCounter}}</p>

vuex原理解析
(1)实现一个插件:声明Store类，挂载$store
(2)Store具体实现:
  创建响应式的state，保存mutations、actions和getters
  实现commit根据用户传入type执行对应mutation
  实现dispatch根据用户传入type执行对应action，同时传递上下文
  实现getters，按照getters定义对state做派生
  
// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法
// 目标2：封装一个插件，使用更容易使用
let Vue;

class Store {
  constructor(options) {
    // 定义响应式的state
    // this.$store.state.xx
    // 借鸡生蛋
    this._vm = new Vue({
      data: {
        $$state: options.state
      }
    })
    
    this._mutations = options.mutations
    this._actions = options.actions

    // 绑定this指向
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }

  // 只读
  get state() {
    return this._vm._data.$$state
  }

  set state(val) {
    console.error('不能直接赋值呀，请换别的方式！！天王盖地虎！！');
    
  }
  
  // 实现commit方法，可以修改state
  commit(type, payload) {
    // 拿出mutations中的处理函数执行它
    const entry = this._mutations[type]
    if (!entry) {
      console.error('未知mutaion类型');
      return
    }

    entry(this.state, payload)
  }

  dispatch(type, payload) {
    const entry = this._actions[type]

    if (!entry) {
      console.error('未知action类型');
      return
    }

    // 上下文可以传递当前store实例进去即可
    entry(this, payload)
  }
}

function install(_Vue){
  Vue = _Vue

  // 混入store实例
  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    }
  })
}

// { Store, install }相当于Vuex
// 它必须实现install方法
export default { Store, install }
```

#### vuex总结
- state: 状态中心
- mutations: 更改状态
- actions: 异步更改状态
- getters: 获取状态
- modules: 将state分成多个modules，便于管理

#### Vuex工作原理
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。

状态自管理应用包含以下几个部分：
- state，驱动应用的数据源；
- view，以声明方式将 state 映射到视图；
- actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：

vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：
- 多个视图依赖于同一状态。
- 来自不同视图的行为需要变更同一状态

  #### MVVM
MVVM 由以下三个内容组成
- View：界面
- Model：数据模型
- ViewModel：作为桥梁负责沟通 View 和 Model
```
在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的
DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。
```

MVVM
```
在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的
刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式
就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。
ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，
在这种情况下，View 和 Model 都可以独立出来，任何一方改变了
也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 
ViewModel 中，让多个 View复用这个 ViewModel。
```

- 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

脏数据检测
- 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。

- 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。

数据劫持
- Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。
```
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```
- 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅

```
<div>
    {{name}}
</div>
```
- 在解析如上模板代码时，遇到 {name} 就会给属性 name 添加发布订阅。

```
// 通过 Dep 解耦
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    // sub 是 Watcher 实例
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null

function update(value) {
  document.querySelector('div').innerText = value
}

class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
```
- 接下来,对 defineReactive 函数进行改造

```
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      // 执行 watcher 的 update 方法
      dp.notify()
    }
  })
}
```
- 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加

Proxy 与 Object.defineProperty 对比
```
Object.defineProperty 虽然已经能够实现双向绑定了，
但是他还是有缺陷的。
```
- 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化
- 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack的办法，并且也是有缺陷的。
```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下几个函数
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
methodsToPatch.forEach(function (method) {
  // 获得原生函数
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    // 调用原生函数
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // 触发更新
    ob.dep.notify()
    return result
  })
})
```
- 反观 Proxy就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty
```
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

#### vue和vuex组件通信的区别
- 组件是vue.js中最重要的一个功能，在vue中组件的实例都是相互独立的，但开发过程中组件雨组件之间的数据相互引用是必不可少，下面来阐述vue的几种通信方式

1：父组件->子组件：通过props接受父传递数据
- 步骤1：子通过props键来接受父传递过来的数据 props:[‘变量名1’,…,‘变量名n’]
- 步骤2：父传递给子 父必须在调用子的组件上通过语法 v-bind:子props中的变量名=“父data中的键”
```
// 声明fathertag组件
Vue.component("fathertag", {
    // 声明模型数据
    data() {
        return {
            // 调用的时候注意大小写
            sonName: "赵冠希"  
        }
    },
    // 声明组件内容
    template: `
        <fieldset>
            <legend>父组件</legend>

            <div>
                <p>我是父组件，我儿子叫：{{sonName}}</p> 
                
                <!-- 调用子组件 -->
                <sontag v-bind:myName="sonName"></sontag>
            </div>

        </fieldset>
    `,
    // 声明子组件
    components: {
        // 键就是组件标识
        sontag: {
            // 通过props键来获取父传递的数据
            props: ['myName'],
            // 这里的下props相当于下面data 
            // data() {
            //     return {
            //         // myName: 数据
            //         myName: 6666,
            //     }
            // },
            // 声明子组件内容
            template: `
                <fieldset>
                    <legend>子组件</legend>
                    <p>我是子组件，我爸爸给我取名：{{myName}}</p>
                </fieldset>
            `
        }
    }
})
```

2：子组件->父组件：通过$emit创建自定义事件发送数据
- 步骤1：子创建自定义事件 通过语法this.$emit(事件名称, 数据1, …, 数据n)
- 步骤2：父调用自定义事件 父在调用子组件上通过 @自定义事件名称=“函数名” 你在父定义函数接受数据即可
```
// 声明fathertag组件
Vue.component("fathertag", {
    // 声明模型数据
    data() {
        return {
            // 调用的时候注意大小写
            sonName: "赵冠希",
            mySonData: ""
        }
    },
    // 声明组件内容
    template: `
        <fieldset>
            <legend>父组件</legend>

            <div>
                <p>我是父组件，我儿子叫：{{sonName}}</p> 
                
                <!-- 调用子组件 -->
                <sontag @getSonData="showSonDataFn" v-bind:myName="sonName"></sontag>
                <p>
                    子的数据： {{ mySonData }}
                </p>
            </div>

        </fieldset>
    `,
    // 声明父普通函数
    methods: {
        showSonDataFn(data) {
            // console.log(data)
            this.mySonData = data
        }
    },
    // 声明子组件
    components: {
        // 键就是组件标识
        sontag: {
            // 简单理解：页面加载完毕 -> 组件渲染完毕会触发下面这个键
            mounted() {
                // 在这里面创建自定义事件
                this.$emit("getSonData", this.myName2)
            },
            // 通过props键来获取父传递的数据
            props: ['myName'],
            // 脚下留心：下props相当于下面data 
            data() {
                return {
                    // myName: 数据
                    // myName: 6666,
                    myName2: "xxxxxx"
                }
            },
            // 声明子组件内容
            template: `
                <fieldset>
                    <legend>子组件</legend>
                    <p>我是子组件，我爸爸给我取名：{{myName}}</p>
                </fieldset>
            `
        }
    }
})
```

3：兄弟组件：通过EventBus（事件总线）
- 步骤1：创建所有组件共享数据中心 const eventBus = new Vue()
- 步骤2：传递数据 eventBus.e m i t ( 自 定 义 事 件 名 称 ， 数 据 1 , . . . , 数 据 n ) 步 骤 3 ： 接 受 数 据 e v e n t B u s . emit(自定义事件名称， 数据1,...,数据n) 步骤3：接受数据 eventBus.emit(自定义事件名称，数据1,...,数据n)步骤3：接受数据eventBus.on(自定义事件名称，处理函数)
```
// 创建一个组件数据共享中心
const eventBus = new Vue()

Vue.component("mytag1", {
    // 声明组件模型数据
    data() {
        return {
            msg: "webopenfather",
            other: 66666
        }
    },
    // 声明组件内容
    template: `
        <fieldset>
            <legend>兄弟1</legend>
            <button @click="sendDataFn">点击传递数据</button>
        </fieldset>
    `,
    // 声明普通方法
    methods:{
        sendDataFn() {
            // 发送数据
            eventBus.$emit("mytag1MsgData", this.msg, this.other)
        }
    }
})
Vue.component("mytag2", {
    // 声明组件内容
    template: `
    <fieldset>
        <legend>兄弟2</legend>
        <p>{{data}}</p>
        <p>{{data2}}</p>
    </fieldset>
    `,
    // 声明自己的模型数据
    data() {
        return {
            data: "",
            data2: ""
        }
    },
    // 组件渲染完毕触发函数 
    mounted() {
        eventBus.$on("mytag1MsgData", (data, data2, data3) => {// 推荐写箭头函数
            console.log(data)
            console.log(data2)
            console.log(data3)
            // 将数据保存到自己的模型里面 -> 展示
            this.data = data
            this.data2 = data2
        })
    }
})
```

4：状态管理vuex
- 在实战中组件之间通信麻烦（两三个兄弟无所谓，但是n个兄弟 比较复杂），所以Vuex实现组件数据统一管理
```
const store = new Vuex.Store({
  // 声明仓库数据
  state: {
      // 跟其他组件定义data一样
      键:值,//
      ...
  },
  // 仓库数据过滤
  getters: {
      方法名(state) {
           +return
      },
      ...
  },
  // 更新仓库数据（这里面不允许写异步请求）
  mutations: {
  // 无参数
      get/set方法名(state) {
           
      },
  // 有参数（思考：有几个形参，根据actions调用传递的实参定）
      get/set方法名(state, data1, ..., datan) {
          state.键 = 异步请求数据（data1）
      }
  },
  // 更新仓库数据（这里面专门写异步请求，但是不能直接操作state 操作mutations）
  actions： {
  get/set方法名(context) {
  //不传递参数：context.commit(mutations里面的方法名)
  //传递参数： context.commit(mutations里面的方法名, 数据1,..,数据n)
 
   }
  }
})
//
//在组件中触发仓库里面数据语法
//如果在组件中调用state&getter：
computed: {
  方法名() { // 推荐方法名就是vuex.state中的键名
      return this.$store.state/getters.键
  }

}
// 如何调用mutations
// 如何调用actions
methods: {
  方法名() {
      this.$store.commit(mutations里面方法名)
      this.$store.dispatch(actions里面的方法名)
  }
}
```

辅助函数
- 辅助函数（state）：在组件computed里面写 …Vuex.mapState([键1,…,键n])
- 辅助函数（getters）：在组件computed里面写 …Vuex.mapGetters([方法名1,…,方法名n])
- 辅助函数（mutations）在组件methods等其他 …Vuex.mapMutations([]或者{})
- 辅助函数（actions） 在组件methods等其他 …Vuex.mapActions([]或{}})
- [‘mutations/action方法名里面方法名’] 注：这时候普通方法名 同 数组里面的值

- { 键就是普通方法名，值mutations/action方法名里面方法名 键：值 }
```
const store = new Vuex.Store({
    // 声明仓库数据
    state: { // 计算属性 this.$store.state.键
        age: 19,
        name: 'jack'
    },
    // 声明过滤的仓库数据
    getters: { // 计算属性 this.$store.getters.方法名
        username(state) {
            return 'hello2' + state.name
        }
    },
    // 声明更新仓库数据键
    mutations: { // commit
        setAge(state) {
            state.age++
        }
    },
    // 声明更新仓库数据（异步请求 -> mutations）
    actions: { // dispatch
        setAge(context) {
            context.commit('setAge')
        }
    }
})

// this.$store/$el/$data
let vm = new Vue({
    // 激活
    store,  
    el: '#app',
    data: {
    },
    computed: {
        // 推荐方法名就是vuex.state中的键
        // age() {
        //     return this.$store.state.age
        // },
        // name() {
        //     return this.$store.state.name
        // },
        // username() {
        //     return this.$store.getters.username
        // }
        ...Vuex.mapState(['age', 'name']),
        ...Vuex.mapGetters(['username'])
    },
    methods: {
        // testMutation() {
        //     this.$store.commit('setAge')
        // },
        // 下述数组里面的值 就是 vuex.mutations里面的方法名
        // 默认普通方法名就是 vuex.mutations里面的方法名
        // ...Vuex.mapMutations(['setAge']),
        ...Vuex.mapMutations({
            //前面普通方法名，后面是vuex.mutations里面的方法名
            testMutation: 'setAge'
        }),
        // testAction() {
        //     this.$store.dispatch('setAge')
        // }
        ...Vuex.mapActions({
            testAction: 'setAge'
        })
    }
})
```

模块化思想
- store 在new vue中激活
```
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  // 公共的
  state
  getters
  mutations
  actions

  // 单个模块的
  modules: {
    a: moduleA,
    b: moduleB
  }
})

//调用组件中获取数据
// 它们都是在computed
...mapState({
    方法名: state => state.状态,
    方法名: state => state.moduleA.状态,
    方法名: state => state.moduleB.状态
}),
...mapGetters({
    方法名: '方法名',
    方法名: 'moduleA/方法名',
    方法名: 'moduleB/方法名'
})

// 它们都是在methods
...mapMutations({
    方法名: 'moduleA/方法名',
    方法名: 'moduleB/方法名'
}),
...mapActions({
    方法名: 'moduleA/方法名',
    方法名: 'moduleB/方法名',
})
```

  #### MVVM和MVC的区别
```
MVC: MVC是应用最广泛的软件架构之一,一般MVC分为:
Model(模型),View(视图),Controller(控制器)。 这主要是
基于分层的目的,让彼此的职责分开.View一般用过Controller来
和Model进行联系。Controller是Model和View的协调者,
View和Model不直接联系。基本都是单向联系。

1. View传送指令到Controller。
2. Controller完成业务逻辑后改变Model状态。
3. Model将新的数据发送至View,用户得到反馈。

MVVM: MVVM是把MVC中的Controller改变成了ViewModel。

View的变化会自动更新到ViewModel,ViewModel的变化
也会自动同步到View上显示,通过数据来显示视图层。

MVVM和MVC的区别:
  MVC中Controller演变成MVVM中的ViewModel
  MVVM通过数据来显示视图层而不是节点操作
  MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,
  加载速度变慢,影响用户体验
```

```
MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller
演变成ViewModel。Model层代表数据模型，View代表UI组件，
ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并
自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。
```

- MVVM 是 Model-View-ViewModel 的缩写
- Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为
- View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View
- ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.
- 总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。

  #### vue的优点
```
轻量级框架
简单易学
双向数据绑定
组件化
视图，数据，结构分离
虚拟 DOM
运行速度更快
```

- 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
- 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
- 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写

  #### Vue.js特点
- 简洁：页面由HTML模板+Json数据+Vue实例组成
- 数据驱动：自动计算属性和追踪依赖的模板表达式
- 组件化：用可复用、解耦的组件来构造页面
- 轻量：代码量小，不依赖其他库
- 快速：精确有效批量DOM更新
- 模板友好：可通过npm，bower等多种方式安装，很容易融入

  #### 开发中常用的指令有哪些
- v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定
- v-html: 更新元素的 innerHTML
- v-show 与 v-if: 条件渲染, 注意二者区别：使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏

- v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数
- v-for:基于源数据多次渲染元素或模板块
- v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM语法：v-bind:title="msg"简写：:title="msg"
  
  #### vue的响应式原理
```
数据发生变化后，会重新对页面渲染，这就是 Vue 响应式

想完成这个过程，我们需要：
  侦测数据的变化
  收集视图依赖了哪些数据
  数据变化时，自动“通知”需要更新的视图部分，并进行更新

对应专业俗语分别是：
数据劫持 / 数据代理
依赖收集
发布订阅模式
```

Vue2.x 响应式原理
```
Vue 采用数据劫持结合发布—订阅模式的方法，通过 
Object.defineProperty() 来劫持各个属性的 setter，
getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
```

- Observer 遍历数据对象，给所有属性加上 setter 和 getter，监听数据的变化
- compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
```
Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情
```
- 在自身实例化时往属性订阅器 (dep) 里面添加自己
- 待属性变动 dep.notice() 通知时，调用自身的 update() 方法，并触发 Compile 中绑定的回调

Vue3.x响应式数据原理
```
Vue3.x改用Proxy替代Object.defineProperty。因为Proxy
可以直接监听对象和数组的变化，并且有多达13种拦截方法。
并且作为新标准将受到浏览器厂商重点持续的性能优化。
```

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
```
判断当前Reflect.get的返回值是否为Object，如果是
则再通过reactive方法做代理， 这样就实现了深度观测。
```

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
```
我们可以判断key是否为当前被代理对象target自身属性，也可以判断
旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger
```

```
Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 
中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了
访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 
中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，
观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,
生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和
旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，
将所有记录的不同点，局部修改到真实 DOM树上。

1.虚拟DOM (Virtaul DOM): 用 js 对象模拟的，保存当前视图内所有 
  DOM 节点对象基本描述属性和节点间关系的树结构。用 js 对象，
  描述每个节点，及其父子关系，形成虚拟 DOM 对象树结构。
2.因为只要在 data 中声明的基本数据类型的数据，基本不存在
  数据不响应问题，所以重点介绍数组和对象在vue中的数据响应问题，
  vue可以检测对象属性的修改，但无法监听数组的所有变动及
  对象的新增和删除，只能使用数组变异方法及$set方法。

总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过
Object.defineProperty() 来劫持各个属性的 setter，getter，
在数据变动时发布消息给订阅者，触发相应的监听回调。

1.Observer 遍历数据对象，给所有属性加上 setter 和 getter，监听数据的变化
2.compile 解析模板指令，将模板中的变量替换成数据，
  然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，
  添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
  
  Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情

1.在自身实例化时往属性订阅器 (dep) 里面添加自己
2.待属性变动 dep.notice() 通知时，调用自身的 update() 方法，
  并触发 Compile 中绑定的回调
  
Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？
  1.可以检测对象中数据发生的修改
  2.对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，
    这样子就需要递归到底，这也是它的缺点。
  3.对于一个对象中，如果你新增加属性，删除属性，
    **Object.defineProperty()**是不能观测到的，那么应该如何解决呢？
    可以通过Vue.set()和Vue.delete()来实现。
// 模拟 Vue 中的 data 选项 
let data = {
    msg: 'hello'
}
// 模拟 Vue 的实例 
let vm = {}
// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作
Object.defineProperty(vm, 'msg', {
  // 可枚举(可遍历)
  enumerable: true,
  // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) 
  configurable: true,
  // 当获取值的时候执行 
  get () {
    console.log('get: ', data.msg)
    return data.msg 
  },
  // 当设置值的时候执行 
  set (newValue) {
    console.log('set: ', newValue) 
    if (newValue === data.msg) {
      return
    }
    data.msg = newValue
    // 数据更改，更新 DOM 的值 
    document.querySelector('#app').textContent = data.msg
  } 
})

// 测试
vm.msg = 'Hello World' 
console.log(vm.msg)

Vue3.x响应式数据原理：
Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以
直接监听对象和数组的变化，并且有多达13种拦截方法。
并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
判断当前Reflect.get的返回值是否为Object，如果是则
再通过reactive方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
我们可以判断key是否为当前被代理对象target自身属性，也可以判断
旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger

// 模拟 Vue 中的 data 选项 
let data = {
  msg: 'hello',
  count: 0 
}
// 模拟 Vue 实例
let vm = new Proxy(data, {
  // 当访问 vm 的成员会执行
  get (target, key) {
    console.log('get, key: ', key, target[key])
    return target[key]
  },
  // 当设置 vm 的成员会执行
  set (target, key, newValue) {
    console.log('set, key: ', key, newValue)
    if (target[key] === newValue) {
      return
    }
    target[key] = newValue
    document.querySelector('#app').textContent = target[key]
  }
})

// 测试
vm.msg = 'Hello World'
console.log(vm.msg)

Proxy 相比于 defineProperty 的优势
数组变化也能监听到
不需要深度遍历监听

Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作

let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` 用来自定义对象中的操作
// 可以很方便的使用 Proxy 来实现一个数据绑定和监听

let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2

总结：
Vue
  记录传入的选项，设置 $data/$el
  把 data 的成员注入到 Vue 实例
  负责调用 Observer 实现数据响应式处理(数据劫持)
  负责调用 Compiler 编译指令/插值表达式等
Observer
  数据劫持
    负责把 data 中的成员转换成 getter/setter
    负责把多层属性转换成 getter/setter
    如果给属性赋值为新对象，把新对象的成员设置为 getter/setter
    添加 Dep 和 Watcher 的依赖关系
    数据变化发送通知
Compiler
  负责编译模板，解析指令/插值表达式
  负责页面的首次渲染过程
  当数据变化后重新渲染
Dep
  收集依赖，添加订阅者(watcher)
  通知所有订阅者
Watcher
  自身实例化的时候往dep对象中添加自己
  当数据变化dep通知所有的 Watcher 实例更新视图
```

  #### 发布订阅模式和观察者模式
```
1. 发布/订阅模式
  发布/订阅模式
    订阅者
    发布者
    信号中心
我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心
"发布"(publish)一个信 号，其他任务可以向信号中心"订阅"(subscribe)
这个信号，从而知道什么时候自己可以开始执行。
这就叫做"发布/订阅模式"(publish-subscribe pattern)

Vue 的自定义事件：
let vm = new Vue()
vm.$on('dataChange', () => { console.log('dataChange')})
vm.$on('dataChange', () => { 
  console.log('dataChange1')
}) 
vm.$emit('dataChange')

兄弟组件通信过程：
// eventBus.js
// 事件中心
let eventHub = new Vue()

// ComponentA.vue
// 发布者
addTodo: function () {
  // 发布消息(事件)
  eventHub.$emit('add-todo', { text: this.newTodoText }) 
  this.newTodoText = ''
}
// ComponentB.vue
// 订阅者
created: function () {
  // 订阅消息(事件)
  eventHub.$on('add-todo', this.addTodo)
}

模拟 Vue 自定义事件的实现：
class EventEmitter {
  constructor(){
    // { eventType: [ handler1, handler2 ] }
    this.subs = {}
  }
  // 订阅通知
  $on(eventType, fn) {
    this.subs[eventType] = this.subs[eventType] || []
    this.subs[eventType].push(fn)
  }
  // 发布通知
  $emit(eventType) {
    if(this.subs[eventType]) {
      this.subs[eventType].forEach(v=>v())
    }
  }
}

// 测试
var bus = new EventEmitter()

// 注册事件
bus.$on('click', function () {
  console.log('click')
})

bus.$on('click', function () {
  console.log('click1')
})

// 触发事件 
bus.$emit('click')

2. 观察者模式
  观察者(订阅者) -- Watcher
    update():当事件发生时，具体要做的事情
  目标(发布者) -- Dep
    subs 数组:存储所有的观察者
    addSub():添加观察者
    notify():当事件发生，调用所有观察者的 update() 方法
  没有事件中心
// 目标(发布者) 
// Dependency
class Dep {
  constructor () {
    // 存储所有的观察者
    this.subs = []
  }
  // 添加观察者
  addSub (sub) {
    if (sub && sub.update) {
      this.subs.push(sub)
    }
  }
  // 通知所有观察者
  notify () {
    this.subs.forEach(sub => sub.update())
  }
}

// 观察者(订阅者)
class Watcher {
  update () {
    console.log('update')
  }
}

// 测试
let dep = new Dep()
let watcher = new Watcher()
dep.addSub(watcher) 
dep.notify()

3. 总结
1.观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用
观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的
2.发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在

```

  #### Object.defineProperty介绍
```
Object.defineProperty 函数一共有三个参数，第一个参数是需要
定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。

一个属性的描述符有一下属性，分别是：
value 属性的值，
writable 属性是否可写，
enumerable 属性是否可枚举，
configurable 属性是否可配置修改。
get属性 当访问该属性时，会调用此函数
set属性 当属性值被修改时，会调用此函数。
```

#### Vue的响应式原理中Object.defineProperty有什么缺陷
- Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
- Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象
- Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性

  #### 使用Object.defineProperty()来进行数据劫持有什么缺点
```
有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改
数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行
代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到
任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。
```

  #### v-if和v-show的区别
```
v-if：每次都会重新删除或创建元素来控制 DOM 结点的存在与否

v-show:是切换了元素的样式 display:none，display: block

因而 v-if 有较高的切换性能消耗，v-show 有较高的初始渲染消耗
```

- v-if按照条件是否渲染，v-show是display的block或none；

  #### vue中created和mounted区别
- created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
- mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

```
其实两者比较好理解，通常created使用的次数多，而mounted通常是
在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: 
var ctx = document.getElementById(ID); 通常会有这一步，
而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，
一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。
```

  #### vue中data和computed区别
data 和 computed都是响应式的，先看看官方的说法：
```
Data:
Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 
getter/setter，从而让 data 的属性能够响应数据变化。

深入理解响应式原理：
当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，
Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 
把这些属性全部转为 getter/setter。

每个组件实例都有相应的 watcher 实例对象，它会在组件渲染
的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，
会通知 watcher 重新计算，从而致使它关联的组件得以更新。
```

2.两者的区别：
```
data中的属性并不会随赋值变量的改动而改动，(赋值变量类似：
num1: aaa.bbb这种，而这种是直接赋值：num1: "aaa")
```

```
当需要这种随赋值变量的改动而改动的时候，还是用计算属性
computed合适如果实在要在data里面声明属性，可以先赋一个值，
然后在methods里面定义方法操作该属性，效果等同，也会有响应式
```

computed:
- 1、基本使用：
```
在computed中定义一个函数(看起来是一个函数，其实是一个属性)，
命名按照属性规范命名(一般为名词)。
```

  - 1.1 应用场景：
```
当数据A的逻辑很复杂时，把A这个数据写在计算属性中。
```

  - 1.2 代码位置：
```
通过选项computed：{计算属性a:值}
```

  - 1.3 值：
```
带有返回值return的函数。
```

```
计算属性a和data中的数据用法一样。计算属性在computed中进行定义，
无需再在data中定义，在template中直接可进行使用，
使用方式与data中定义的数据一样。

{{msg}}
{{str}}

var vm = new Vue({
el: '#app',

data: {
msg: 'abc'
},

computed: {
str: function () {
return this.msg
}
},

methods: {
}

})
```

- 2、复杂操作-结合data中数据：
```
当计算属性b依赖了data中的数据a时，当a变化时，b会自动变化。
这也是在开发中通常用到的情况。比如在购物的时候，下某一订单时，
每选择一件商品(对应data中的数据a)，
合计费用(对应计算属性b)就会跟着变化。
```

```
总价格：{{totalPrice}}
var vm = new Vue({
el: '#app',

data: {
books: [
{ id: 1000, name: 'Linux编程之美', price: 50 },
{ id: 1001, name: 'Java疯狂讲义', price: 60 },
{ id: 1002, name: '深入理解计算机原理', price: 80 },
{ id: 1003, name: '操作系统', price: 30 },
{ id: 1004, name: '数据结构导论', price: 60 },
]
},

computed: {
totalPrice() {
let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;
}

return result
}
},

methods: {
}
})
```

- 3、计算属性写法演变：
  - 3.1 计算属性的setter和getter：
```
computed：{
//computed里面是大括号，本身就是对象。
}
```

完整的计算属性写法：属性+方法
```
computed: {
//定义属性

totalPrice: {
//totalPrice 属性对应的是对象，不是字符串。对象就会有方法。

//该属性对应的set方法 和get方法

//计算属性一般是没有set方法的，是只读属性。

//【此处set测试失败 没有出现预期效果】

set: function (newValue) {
console.log('get方法调用啦', newValue);
},

get: function () {
console.log('计算属性完整写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;
}

return result
}
}
},
```

计算属性一般只有get方法，是只读属性。所以一般写法为：
```
computed: {
totalPrice: function () {
//后面对应的即为get方法。totalPrice就是一个属性，调用时采用属性调用的方式，区别于方法调用()

console.log('计算属性一般写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;

}

return result

}

},
```

语法糖—简化写法：
```
computed: {
totalPrice() {
console.log('计算属性语法糖写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;

}

return result

}

},
```

- 4、项目中实例：
```
以上即为计算属性computed的使用方式。最近在项目开发中，
有个需求为:【考试配题模块】配置某一题型(例如选择题/简答题等
某类试题)个数或者每一小题分数时，会实时计算出当前选择的
某类试题拥有的个数和当前题目个数所对应的小题分数的总分之和。
```
```
template中代码：

课程名称：{{ courseName }}
总题数：{{ allQuestion }}个
当前总分：{{ allValue }}分
computed中代码：

allQuestion: function() {
var num = 0;

this.selectedObj.forEach((item) => {
num += item.questionNum; //questionNum为拿到的selectedObj对象中的需要使用的属性

});

return num;

},

//计算总分

allValue: function() {
var source = 0;

this.selectedObj.forEach((item) => {
source += item.questionValue * item.questionNum; //questionValue 为拿到的selectedObj对象中的需要使用的属性

});

return source;

},

},

computed中依赖的data中数据部分：

// 子组件给父组件传过来的对象

selectedObj: [],
```

  #### vue中watch和computed区别
```
watch主要是监听数据变化，可以监听数据来源的三个部分：props,data,computed内的数据，然后它还提供两个参数
（new,old）,顺序一定是新值、旧值。

computed主要是处理逻辑运算，computed来存储需要处理的数据值，
它有存储的机制，只有改变时才执行。
```

computed:
- computed是计算属性,也就是计算值,它更多用于计算值的场景
- computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景

watch:
- 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作
- 无缓存性，页面重新渲染时值不变化也会执行

小结:
- 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed
- 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化


- 当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed
```
Computed本质是一个具备缓存的watcher，依赖的属性发生变化
就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式
过于复杂时，在模板中放入过多逻辑会让模板难以维护，
可以将复杂的逻辑放入计算属性中处理
```

```
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'yu fei',
        }
    },
    computed:{
        fullName: function(){
            return this.firstName + ' ' + this.lastName
        }
    }
}
```

- watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择
```
Watch没有缓存性，更多的是观察的作用，可以监听某些数据
执行回调。当我们需要深度监听对象中的属性时，可以打开
deep：true选项，这样便会对对象中的每一项进行监听。这样会
带来性能问题，优化的话可以使用字符串形式监听，
如果没有写到组件中，不要忘记使用unWatch手动注销
```

```
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'xiao fei',
            fullName: 'xie xiao fei'
        }
    },
    watch:{
        firstName(val) {
            this.fullName = val + ' ' + this.lastName
        },
        lastName(val) {
            this.fullName = this.firstName + ' ' + val
        }
    }
}
```

  #### vue中methods,watch和computer区别
methods,watch和computed都是以函数为基础的，但各自却都不同。

- 一、作用机制上
  - 1.watch和computed都是以Vue的依赖追踪机制为基础的，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
  - 2.对methods:methods里面是用来定义函数的，很显然，它需要手动调用才能执行。而不像watch和computed那样，“自动执行”预先定义的函数。
```

- 二、从性质上
  - 1.methods里面定义的是函数，你显然需要像"fuc()"这样去调用它（假设函数为fuc）。
  - 2.computed是计算属性，事实上和和data对象里的数据属性是同一类的（使用上）。
  - 3.watch:类似于监听机制+事件机制。
```
例如：
watch: {
   firstName: function(val) {this.fullName = val +this.lastName }
}

firstName的改变是这个特殊“事件”被触发的条件，
而firstName对应的函数就相当于监听到事件发生后执行的方法
```

- 三、watch和computed的对比
```
首先它们都是以Vue的依赖追踪机制为基础的，它们的共同点是：
都是希望在依赖数据发生改变的时候，被依赖的数据根据预先定义
好的函数，发生“自动”的变化。我们当然可以自己写代码完成这一切，
但却很可能造成写法混乱，代码冗余的情况。
```
 
但watch和computed也有明显不同的地方：
```
watch和computed各自处理的数据关系场景不同

1.watch擅长处理的场景：一个数据影响多个数据

2.computed擅长处理的场景：一个数据受多个数据影响

相比于watch/computed，methods不处理数据逻辑关系，只提供可调用的函数
```

```
在vue中处理复杂的逻辑的时候，我们经常使用计算属性computer，
但是很多时候，我们会把计算属性、方法和侦听器搞混淆，
在 w3cplus.com的一篇文章中是这样总结这三者的。
```
- methods：正如他的名字一样，它们是挂载在对象上的函数，通常是Vue实例本身或Vue组件。
- computed：属性最初看起来像一个方法，但事实却又不是方法。在Vue中，我们使用data来跟踪对特定属性的更改，得到一定的反应。计算属性允许我们定义一个与数据使用相同方式的属性，但也可以有一些基于其依赖关系的自定义逻辑。你可以考虑计算属性的另一个视图到你的数据。
- watchers：这些可以让你了解反应系统（Reactivity System）。我们提供了一些钩子来观察Vue存储的任何属性。如果我们想在每次发生变化时添加一些功能，或者响应某个特定的变化，我们可以观察一个属性并应用一些逻辑。这意味着观察者的名字必须与我们所观察到的相符。
如果仅仅只是看这段话，可能还是不能很清除的明白三者的区别，我们可以通过相关的实例来对三者进行区分。

computed
计算属性是根据依赖关系进行缓存的计算，并且只在需要的时候进行更新。
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <p>原数据{{message}}</p>
        <p>反转后的数据{{reversedMessage}}</p>
        <button @click="add()">补充货物1</button>
        <div>总价为：{{price}}</div>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘abcdefg‘,
                package: {
                    count: 5,
                    price: 5
                },
              },
              computed:{
                  reversedMessage:function(){
                      return this.message.split(‘‘).reverse().join(‘‘)
                  },
                price: function(){
                     return this.package.count*this.package.price　　
                 }
            },
             methods: {   
                add: function(){
                    this.package.count++
                }
            }    
        })
    </script>    
</body>
</html>
```

```
上面的例子中展示了计算属性的两种用法：一个计算属性里面可以完成
各种复杂的逻辑，最终返回一个结果；计算属性可以依赖多个vue实例的
数据，只要其中一个任何一个数据发生变化，计算属性就会重新执行，视图
也会更新。除此之外，计算属性还可以依赖其他计算属性和其他实例的数据。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="app1">{{text}}</div>
    <div id="app2">{{ reverseText}}</div>
    <script>
        var app1 = new Vue({
           el: ‘#app1‘,
             data: {
                  text: ‘computed‘
            }
        });

        var app2 = new Vue({
            el: ‘#app2‘,
            computed: {
                reverseText: function(){
                    return app1.text.split(‘‘).reverse().join(‘‘);  
                }
            }
        });
    </script>    
</body>
</html>
```

methods
```
在使用vue的时候，可能会用到很多的方法，它们可以将功能连接到
事件的指令，甚至只是创建一个小的逻辑就像其他函数一样被重用。
接下来我们用方法实现上面的字符串反转。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <p>原数据{{message}}</p>
        <p>反转后的数据{{ reversedMessage() }}</p>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘abcdefg‘,
                num:5
              },
              methods:{
                reversedMessage(){
                    return this.message.split(‘‘).reverse().join(‘‘)
                },
            }
        })
    </script>    
</body>
</html>
```

``
虽然使用计算属性和methods方法来实现反转，两种方法得到的结果
是相同的，但本质是不一样的，计算属性是基于它们的依赖进行缓存的。
计算属性只有在它的相关依赖发生改变的时候才会重新求值，这就意味
着只要message还没有发生改变，多次访问reversedMessage计算属性
立即返回的是之前计算的结果，而不会再次执行计算函数，
而对于methods方法，只要发生重新渲染，methods调用总会执行该函数。

如果某个计算属性a需要的遍历一个极大的数组和做大量的计算，
可以减小性能开销，如果不希望有缓存，则用methods。
```

watch
```
watch属性是一个对象，键是需要观察的表达式，值是对应回调函数，
回调函数得到的参数为新值和旧值。值也可以是方法名，或者包含选项
的对象。侦察器对于任何更新的东西都有用——无论是表单输入、异步更新
还是动画。vue实例在实例化时调用$watch()，遍历watch对象的每一个属性。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <button @click=‘a++‘>a加1</button>
        <p>{{message}}</p>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘‘,
                a:1
              },
              
              watch:{
              a:function(val,oldval){
                this.message = ‘a的旧值为‘ + oldval + ‘,新值为‘ + val;
              }
            }
        })
    </script>    
</body>
</html>
```

- computed：默认computed也是一个watcher具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用computed
- watch：每次都需要执行函数。 watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。
- method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大

  #### 为什么vue组件中的data必须是函数
```
<!-- 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例
用的都是同一个构造函数，如果data是对象的话，对象属性引用类型，
会影响到所有的实例，为了保证组件不同的实例之间的data互不冲突，
data必须是一个函数。 -->

当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，
因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，
则所有的实例将共享引用同一个数据对象！通过提供 data 函数，
每次创建一个新实例后，我们能够调用 data 函数，
从而返回初始数据的一个全新副本数据对象。

简而言之，就是 data 中数据可能会被复用，
要保证不同组件调用的时候数据是相同的。
```

- 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数

  #### vue的activated和deactivated钩子函数
```html
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```

```
`keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

当组件在 `<keep-alive>` 内被切换，它的 `activated` 
和 `deactivated` 这两个生命周期钩子函数将会被对应执行。

`activated`在`keep-alive`组件激活时调用，
该钩子函数在服务器端渲染期间不被调用。
`deactivated`在`keep-alive`组件停用时调用，
该钩子函数在服务端渲染期间不被调用。
```

  #### nextTick用法
- nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
  
官网解释：
```
将回调延迟到下次 DOM 更新循环之后执行。
在修改数据之后立即使用它，然后等待 DOM 更新。
```

```html
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
```

```vue
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```

```
nextTick 可以让我们在下次 DOM 更新循环结束之后
执行延迟回调，用于获得更新后的 DOM

nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

Promise
MutationObserver
setImmediate
如果以上都不行则采用setTimeout
定义了一个异步方法，多次调用nextTick会将方法
存入队列中，通过这个异步方法清空当前队列
```

```
nextTick 可以让我们在下次 DOM 更新循环结束之后
执行延迟回调，用于获得更新后的 DOM
```

nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用
- Promise
- MutationObserver
- setImmediate
- 如果以上都不行则采用setTimeout
```
定义了一个异步方法，多次调用nextTick会将方法
存入队列中，通过这个异步方法清空当前队列
```

  #### vue中key属性的作用
```
一句话 key 的作用主要是为了高效的更新虚拟 DOM

key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 
对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少
动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，
它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。
```

Vue中的key到底有什么用？
- key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速
- diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.

  - diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.

  - 准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1).

  #### Vue中key属性用index为什么不行
这是由于diff算法的机制所决定的，话不多说，直接上反例：
当我们选中某一个（比如第3个），再添加或删除内容的时候就能发现bug了

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

</head>
<body>
    <div id="app">
        <span>ID:</span><input type="text" v-model="id">
        <span>Name:</span><input type="text" v-model="name">
        <button @click="handleClick">添加</button>

        <div v-for="(item, index) in list" :key="index">
            <input type="checkbox" />
            <span @click="handleDelete(index)">{{item.id}} --- {{item.name}}</span>
        </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data: {
                id: '',
                name: '',
                list: [
                    {id: 1, name: '张三'},
                    {id: 2, name: '李四'},
                    {id: 3, name: '王五'},
                    {id: 4, name: '赵六'},
                ]
            },
            methods: {
                handleClick() {
                    this.list.unshift({
                        id: this.id,
                        name: this.name
                    })
                },
                handleDelete(index) {
                    this.list.splice(index, 1)
                }
            },
        })
    </script>
</body>
</html>
```

  #### 路由原理
- 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

  - hash 模式
  - history 模式
- www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。

- History模式是 HTML5 新推出的功能，比之 Hash URL 更加美观

  #### Vue的路由模式
> hash模式 与 history模式
> 
- hash（即地址栏 URL 中的 # 符号)。

```txt
比如这个 URL：www.123.com/#/test，hash 的值为 #/test。

特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP，因为我们hash每次页面切换其实切换的是#之后的内容，而#后内容的改变并不会触发地址的改变，
所以不存在向后台发出请求，对后端完全没有影响，因此改变 hash 不会重新加载页面。

每次hash发生变化时都会调用 onhashchange事件

优点：可以随意刷新
```

- history（利用了浏览器的历史记录栈）

```txt
特点：利用了 HTML5 History Interface 中新增的 
pushState() 和 replaceState() 方法。（需要特定浏览器支持）

在当前已有的 back、forward、go的基础之上，它们提供了对
历史记录进行修改的功能。只是当它们执行修改时，虽然改变了
当前的URL，但浏览器不会立即向后端发送请求。

history：可以通过前进 后退控制页面的跳转，刷新是真是的改变url。

缺点：不能刷新，需要后端进行配置。由于history模式下是可以
自由修改请求url，当刷新时如果不对对应地址进行匹配就会返回404。
但是在hash模式下是可以刷新的，前端路由修改的是#中的信息，
请求时地址是不会变的
```

  #### Vue的路由实现：hash模式和history模式
- hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。

- history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更

#### Vue中hash模式和history模式的区别
- 最明显的是在显示上，hash模式的URL中会夹杂着#号，而history没有。
- Vue底层对它们的实现方式不同。hash模式是依靠onhashchange事件(监听location.hash的改变)，而history模式是主要是依靠的HTML5 history中新增的两个方法，pushState()可以改变url地址且不会发送请求，replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改。
- 当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持。因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。

hash:
```
window.onhashchange = function(event){
  // location.hash获取到的是包括#号的，如"#heading-3"
  // 所以可以截取一下
	let hash = location.hash.slice(1);
}
```

#### 了解history有哪些方法吗？说下它们的区别
- history 这个对象在html5的时候新加入两个api history.pushState() 和 history.repalceState() 这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。

从参数上来说：
```
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录
```

另外还有：
- window.history.back() 后退
- window.history.forward()前进
- window.history.go(1) 前进或者后退几步

从触发事件的监听上来说：
- pushState()和replaceState()不能被popstate事件所监听
- 而后面三者可以，且用户点击浏览器前进后退键时也可以

  #### vue路由的钩子函数
```
首页可以控制导航跳转，beforeEach，afterEach等，一般用于
页面title的修改。一些需要登录才能调整页面的重定向功能。
```

- beforeEach主要有3个参数to，from，next。
- to：route即将进入的目标路由对象。
- from：route当前导航正要离开的路由。
- next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转

  #### 路由之间跳转
> 声明式（标签跳转）
> <router-link :to="index">

> 编程式（ js跳转）
> router.push('index')

  #### vue路由传参数
- 使用query方法传入的参数使用this.$route.query接受
- 使用params方式传入的参数使用this.$route.params接受

  #### vue中$router和$route的区别
- this.\$route：当前激活的路由的信息对象。每个对象都是局部的，
  可以获取当前路由的 path, name, params, query 等属性。
- this.\$router：全局的 router 实例。通过 vue 根实例中注入 
  router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。
  其中包含了很多属性和对象（比如 history 对象），
  任何页面也都可以调用其 push(), replace(), go() 等方法。

- $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
- 而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等

  #### vue3带来的新特性/亮点
1. 压缩包体积更小
```
当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。
Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！
```

2. Object.defineProperty -> Proxy
- Object.defineProperty是一个相对比较昂贵的操作，因为它
  直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，
  在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。
  这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。
- javascript引擎在解析的时候希望对象的结构越稳定越好，
  如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。

3. Virtual DOM 重构
```
vdom的本质是一个抽象层，用javascript描述界面渲染成什么样子。
react用jsx，没办法检测出可以优化的动态代码，所以做时间分片，
vue中足够快的话可以不用时间分片
```

- 传统vdom的性能瓶颈：
  - 虽然 Vue 能够保证触发更新的组件最小化，但在单个组件
    内部依然需要遍历该组件的整个 vdom 树。
  - 传统 vdom 的性能跟模版大小正相关，跟动态节点的数量无关。
    在一些组件整个模版内只有少量动态节点的情况下，
    这些遍历都是性能的浪费。
  - JSX 和手写的 render function 是完全动态的，
    过度的灵活性导致运行时可以用于优化的信息不足

- 那为什么不直接抛弃vdom呢？
  - 高级场景下手写 render function 获得更强的表达力
  - 生成的代码更简洁
  - 兼容2.x
```
vue的特点是底层为Virtual DOM，上层包含有大量静态信息的模版。
为了兼容手写 render function，最大化利用模版静态信息，
vue3.0采用了动静结合的解决方案，将vdom的操作颗粒度变小，
每次触发更新不再以组件为单位进行遍历，主要更改如下
```

- 将模版基于动态节点指令切割为嵌套的区块
- 每个区块内部的节点结构是固定的
- 每个区块只需要以一个 Array 追踪自身包含的动态节点
```
vue3.0将 vdom 更新性能由与模版整体大小相关提升为
与动态内容的数量相关
```

Vue 3.0 动静结合的 Dom diff：
- Vue3.0 提出动静结合的 DOM diff 思想，动静结合的 DOM diff
  其实是在预编译阶段进行了优化。之所以能够做到预编译优化，
  是因为 Vue core 可以静态分析 template，在解析模版时，
  整个 parse 的过程是利用正则表达式顺序解析模板，当解析到
  开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，
  来达到构造 AST 树的目的。
- 借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在
  预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff 时
  就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。
  这也就是动静结合的 DOM diff 将 diff 成本与模版大小正相关
  优化到与动态节点正相关的理论依据。
  
4. Performance
```
vue3在性能方面比vue2快了2倍。
```
- 重写了虚拟DOM的实现
- 运行时编译
- update性能提高
- SSR速度提高

5. Tree-shaking support
```
vue3中的核心api都支持了tree-shaking，这些api都是通过包引入的方式
而不是直接在实例化时就注入，只会对使用到的功能或特性进行打包
（按需打包），这意味着更多的功能和更小的体积。
```

6. Composition API
```
vue2中，我们一般会采用mixin来复用逻辑代码，用倒是挺好用的，不过
也存在一些问题：例如代码来源不清晰、方法属性等冲突。基于此在vue3
中引入了Composition API（组合API），使用纯函数分隔复用代码。
和React中的hooks的概念很相似
```
- 更好的逻辑复用和代码组织
- 更好的类型推导

```
<template>
    <div>X: {{ x }}</div>
    <div>Y: {{ y }}</div>
</template>

<script>
import { defineComponent, onMounted, onUnmounted, ref } from "vue";

const useMouseMove = () => {
    const x = ref(0);
    const y = ref(0);

    function move(e) {
        x.value = e.clientX;
        y.value = e.clientY;
    }

    onMounted(() => {
        window.addEventListener("mousemove", move);
    });

    onUnmounted(() => {
        window.removeEventListener("mousemove", move);
    });

    return { x, y };
};

export default defineComponent({
    setup() {
        const { x, y } = useMouseMove();

        return { x, y };
    }
});
</script>
```

7. 新增的三个组件Fragment、Teleport、Suspense
Fragment
```
在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些
没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的
（这和React中的Fragment组件是一样的）。
```

这意味着现在可以这样写组件了。
```
/* App.vue */
<template>
  <header>...</header>
  <main v-bind="$attrs">...</main>
  <footer>...</footer>
</template>

<script>
export default {};
</script>
```

或者这样
```
// app.js
import { defineComponent, h, Fragment } from 'vue';

export default defineComponent({
    render() {
        return h(Fragment, {}, [
            h('header', {}, ['...']),
            h('main', {}, ['...']),
            h('footer', {}, ['...']),
        ]);
    }
});
```

Teleport
```
Teleport其实就是React中的Portal。Portal 提供了一种将
子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
```

一个 portal 的典型用例是当父组件有 overflow: hidden 或 
z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。
例如，对话框、悬浮卡以及提示框。
```
/* App.vue */
<template>
    <div>123</div>
    <Teleport to="#container">
        Teleport
    </Teleport>
</template>

<script>
import { defineComponent } from "vue";

export default defineComponent({
    setup() {}
});
</script>

/* index.html */
<div id="app"></div>
<div id="container"></div>
```

Suspense
同样的，这和React中的Supense是一样的。
```
Suspense 让你的组件在渲染之前进行“等待”，
并在等待时显示 fallback 的内容
```

```
// App.vue
<template>
    <Suspense>
        <template #default>
            <AsyncComponent />
        </template>
        <template #fallback>
            Loading...
        </template>
    </Suspense>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import AsyncComponent from './AsyncComponent.vue';

export default defineComponent({
    name: "App",
    
    components: {
        AsyncComponent
    }
});
</script>

// AsyncComponent.vue
<template>
    <div>Async Component</div>
</template>

<script lang="ts">
import { defineComponent } from "vue";

const sleep = () => {
    return new Promise(resolve => setTimeout(resolve, 1000));
};

export default defineComponent({
    async setup() {
        await sleep();
    }
});
</script>
```

8. Better TypeScript support
```
在vue2中使用过TypesScript的童鞋应该有过体会，写起来实在是有点难受。
vue3则是使用ts进行了重写，开发者使用vue3时拥有更好的类型支持和更好的编写体验。
```
  
  #### VDOM：三个part
- 虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，
并提供 render 方法，将虚拟节点渲染成真实 DOM
- 节点 diff 比较：对虚拟节点进行 js 层面的计算，
并将不同的操作都记录到 patch 对象
- re-render：解析 patch 对象，进行 re-render

补充1：VDOM 的必要性？
- 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 
仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。
- 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，
让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，
然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，
以减少浏览器的重绘及回流。

补充2：vue 为什么采用 vdom？
```
引入 Virtual DOM 在性能方面的考量仅仅是一方面。
```

- 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。
- Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是：
```
不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高
运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，
运行时效率可以进一步提升；
可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，
Weex等框架应用的就是这一特性。

综上，Virtual DOM 在性能上的收益并不是最主要的，
更重要的是它使得 Vue 具备了现代框架应有的高级特性。
 ``` 
  
  #### 虚拟DOM(Virtual Dom)
为什么需要 Virtual Dom
- 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多
```
// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这里替换上面的 li
[1, 2, 5, 4]
```
- 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。

- 如果以上操作对应到 DOM 中，那么就是以下代码
```
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
```
- 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。

- 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM
- 以下是一个 JS 对象模拟 DOM 对象的简单实现
```
export default class Element {
  /**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */
  constructor(tag, props, children, key) {
    this.tag = tag
    this.props = props
    if (Array.isArray(children)) {
      this.children = children
    } else if (isString(children)) {
      this.key = children
      this.children = null
    }
    if (key) this.key = key
  }
  // 渲染
  render() {
    let root = this._createElement(
      this.tag,
      this.props,
      this.children,
      this.key
    )
    document.body.appendChild(root)
    return root
  }
  create() {
    return this._createElement(this.tag, this.props, this.children, this.key)
  }
  // 创建节点
  _createElement(tag, props, child, key) {
    // 通过 tag 创建节点
    let el = document.createElement(tag)
    // 设置节点属性
    for (const key in props) {
      if (props.hasOwnProperty(key)) {
        const value = props[key]
        el.setAttribute(key, value)
      }
    }
    if (key) {
      el.setAttribute('key', key)
    }
    // 递归添加子节点
    if (child) {
      child.forEach(element => {
        let child
        if (element instanceof Element) {
          child = this._createElement(
            element.tag,
            element.props,
            element.children,
            element.key
          )
        } else {
          child = document.createTextNode(element)
        }
        el.appendChild(child)
      })
    }
    return el
  }
}
```

- Virtual Dom 算法简述
既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。
- DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React团队优化了算法，实现了 O(n) 的复杂度来对比差异。
- 实现O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素

所以判断差异的算法就分为了两步
- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

Virtual Dom 算法实现
树的递归
- 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况
- 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了
- 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树
- 没有新的节点，那么什么都不用做
```
import { StateEnums, isString, move } from './util'
import Element from './element'

export default function diff(oldDomTree, newDomTree) {
  // 用于记录差异
  let pathchs = {}
  // 一开始的索引为 0
  dfs(oldDomTree, newDomTree, 0, pathchs)
  return pathchs
}

function dfs(oldNode, newNode, index, patches) {
  // 用于保存子树的更改
  let curPatches = []
  // 需要判断三种情况
  // 1.没有新的节点，那么什么都不用做
  // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
  // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  if (!newNode) {
  } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) {
    // 判断属性是否变更
    let props = diffProps(oldNode.props, newNode.props)
    if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props })
    // 遍历子树
    diffChildren(oldNode.children, newNode.children, index, patches)
  } else {
    // 节点不同，需要替换
    curPatches.push({ type: StateEnums.Replace, node: newNode })
  }

  if (curPatches.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(curPatches)
    } else {
      patches[index] = curPatches
    }
  }
}
```
判断属性的更改
判断属性的更改也分三个步骤
- 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
- 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
- 在第二步中同时查看是否有属性不存在与旧的属性列列表中
```
function diffProps(oldProps, newProps) {
  // 判断 Props 分以下三步骤
  // 先遍历 oldProps 查看是否存在删除的属性
  // 然后遍历 newProps 查看是否有属性值被修改
  // 最后查看是否有属性新增
  let change = []
  for (const key in oldProps) {
    if (oldProps.hasOwnProperty(key) && !newProps[key]) {
      change.push({
        prop: key
      })
    }
  }
  for (const key in newProps) {
    if (newProps.hasOwnProperty(key)) {
      const prop = newProps[key]
      if (oldProps[key] && oldProps[key] !== newProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      } else if (!oldProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      }
    }
  }
  return change
}
```

判断列表差异算法实现
```
这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 
这里的主要步骤其实和判断属性差异是类似的，也是分为三步
```
- 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
- 遍历新的节点列表，判断是否有新的节点
- 在第二步中同时判断节点是否有移动
PS：该算法只对有 key 的节点做处理
```
function listDiff(oldList, newList, index, patches) {
  // 为了遍历方便，先取出两个 list 的所有 keys
  let oldKeys = getKeys(oldList)
  let newKeys = getKeys(newList)
  let changes = []

  // 用于保存变更后的节点数据
  // 使用该数组保存有以下好处
  // 1.可以正确获得被删除节点索引
  // 2.交换节点位置只需要操作一遍 DOM
  // 3.用于 `diffChildren` 函数中的判断，只需要遍历
  // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要
  // 再去判断一遍
  let list = []
  oldList &&
    oldList.forEach(item => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找新的 children 中是否含有当前节点
      // 没有的话需要删除
      let index = newKeys.indexOf(key)
      if (index === -1) {
        list.push(null)
      } else list.push(key)
    })
  // 遍历变更后的数组
  let length = list.length
  // 因为删除数组元素是会更改索引的
  // 所有从后往前删可以保证索引不变
  for (let i = length - 1; i >= 0; i--) {
    // 判断当前元素是否为空，为空表示需要删除
    if (!list[i]) {
      list.splice(i, 1)
      changes.push({
        type: StateEnums.Remove,
        index: i
      })
    }
  }
  // 遍历新的 list，判断是否有节点新增或移动
  // 同时也对 `list` 做节点新增和移动节点的操作
  newList &&
    newList.forEach((item, i) => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找旧的 children 中是否含有当前节点
      let index = list.indexOf(key)
      // 没找到代表新节点，需要插入
      if (index === -1 || key == null) {
        changes.push({
          type: StateEnums.Insert,
          node: item,
          index: i
        })
        list.splice(i, 0, key)
      } else {
        // 找到了，需要判断是否需要移动
        if (index !== i) {
          changes.push({
            type: StateEnums.Move,
            from: index,
            to: i
          })
          move(list, index, i)
        }
      }
    })
  return { changes, list }
}

function getKeys(list) {
  let keys = []
  let text
  list &&
    list.forEach(item => {
      let key
      if (isString(item)) {
        key = [item]
      } else if (item instanceof Element) {
        key = item.key
      }
      keys.push(key)
    })
  return keys
}
```
遍历子元素打标识
对于这个函数来说，主要功能就两个
- 判断两个列表差异
  - 给节点打上标记
  - 总体来说，该函数实现的功能很简单
```
function diffChildren(oldChild, newChild, index, patches) {
  let { changes, list } = listDiff(oldChild, newChild, index, patches)
  if (changes.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(changes)
    } else {
      patches[index] = changes
    }
  }
  // 记录上一个遍历过的节点
  let last = null
  oldChild &&
    oldChild.forEach((item, i) => {
      let child = item && item.children
      if (child) {
        index =
          last && last.children ? index + last.children.length + 1 : index + 1
        let keyIndex = list.indexOf(item.key)
        let node = newChild[keyIndex]
        // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
        if (node) {
          dfs(item, node, index, patches)
        }
      } else index += 1
      last = item
    })
}
```
渲染差异
```
通过之前的算法，我们已经可以得出两个树的差异了。
既然知道了差异，就需要局部去更新 DOM 了，
下面就让我们来看看 Virtual Dom 算法的最后一步骤
```
这个函数主要两个功能
- 深度遍历树，将需要做变更操作的取出来
- 局部更新 DOM
```
let index = 0
export default function patch(node, patchs) {
  let changes = patchs[index]
  let childNodes = node && node.childNodes
  // 这里的深度遍历和 diff 中是一样的
  if (!childNodes) index += 1
  if (changes && changes.length && patchs[index]) {
    changeDom(node, changes)
  }
  let last = null
  if (childNodes && childNodes.length) {
    childNodes.forEach((item, i) => {
      index =
        last && last.children ? index + last.children.length + 1 : index + 1
      patch(item, patchs)
      last = item
    })
  }
}

function changeDom(node, changes, noChild) {
  changes &&
    changes.forEach(change => {
      let { type } = change
      switch (type) {
        case StateEnums.ChangeProps:
          let { props } = change
          props.forEach(item => {
            if (item.value) {
              node.setAttribute(item.prop, item.value)
            } else {
              node.removeAttribute(item.prop)
            }
          })
          break
        case StateEnums.Remove:
          node.childNodes[change.index].remove()
          break
        case StateEnums.Insert:
          let dom
          if (isString(change.node)) {
            dom = document.createTextNode(change.node)
          } else if (change.node instanceof Element) {
            dom = change.node.create()
          }
          node.insertBefore(dom, node.childNodes[change.index])
          break
        case StateEnums.Replace:
          node.parentNode.replaceChild(change.node.create(), node)
          break
        case StateEnums.Move:
          let fromNode = node.childNodes[change.from]
          let toNode = node.childNodes[change.to]
          let cloneFromNode = fromNode.cloneNode(true)
          let cloenToNode = toNode.cloneNode(true)
          node.replaceChild(cloneFromNode, toNode)
          node.replaceChild(cloenToNode, fromNode)
          break
        default:
          break
      }
    })
}
```
Virtual Dom 算法的实现也就是以下三步
- 通过 JS 来模拟创建 DOM 对象
- 判断两个对象的差异
- 渲染差异
```
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])

let test1 = new Element('div', { class: 'my-div' }, [test4])

let test2 = new Element('div', { id: '11' }, [test5, test4])

let root = test1.render()

let pathchs = diff(test1, test2)
console.log(pathchs)

setTimeout(() => {
  console.log('开始更新')
  patch(root, pathchs)
  console.log('结束更新')
}, 1000)
```
  
  #### 为什么使用虚拟DOM(Virtual DOM)
- 手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 
jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升
- 为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题
- 为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是Virtual DOM 出现了
- Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述DOM，Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM
- 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态
- 通过比较前后两次状态的差异更新真实 DOM

虚拟 DOM 的作用
- 维护视图和状态的关系
- 复杂视图情况下提升渲染性能
- 除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等
img

#### vue核心之虚拟DOM(vdom)
一、真实DOM和其解析流程？
- 浏览器渲染引擎工作流程都差不多，大致分为5步，创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting
  - 第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。
  - 第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。
  - 第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。
  - 第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
  - 第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。 

- DOM树的构建是文档加载完成开始的？构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后才开始构建render数和布局。

- Render树是DOM树和CSSOM树构建完毕才开始构建的吗？这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。

- CSS的解析是从右往左逆向解析的(从DOM树的下－上解析比上－下解析效率高)，嵌套标签越多，解析越慢。

二、JS操作真实DOM的代价！
- 用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。

三、为什么需要虚拟DOM，它有什么好处?
- Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，

- 虚拟DOM就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。

四、实现虚拟DOM
例如一个真实的DOM节点。
```
<div id=" rea l-container">
	<p>Real DOM</p>
	<div>cannot update</div>
	<ul>
		<li className="item">Item 1</li>
		<li className="item">Item 2</li>
		<li className="item">Item 3</li>
	</ul>
</div>
```

- 我们用JS来模拟DOM节点实现虚拟DOM。
```
const tree = Element('div', { id: 'virtual-container' }，[
	ELement('p', {}, ['Virtual DOM']),
	Element('div', {}, ['before update'l),
	Element('ut', {}, [
		Element('li', { class: 'item' }, ['Item 1'])，
		Element('li', { class : item' }, ['Item 2']),
		Element('li', { class: 'item' }, ['Item 3']),
	]),
]);

const root = tree。render();
document . getE LementById( 'virtua LDom' ) . appendChild( root) ;

```

- 其中的Element方法具体怎么实现的呢？
```
function Element (tagName, props, children) {
	if (!(this instanceof Element)) {
		return new Element(tagName, props, children);
	}
	this. tagName = tagName ;
	this.props = props | {};
	this. children = children |1 [];
	this.key = props ? props.key : undefined;
	
	let count = 0;
	this. children. forEach((child) => {
		if (child instanceof ELement) {
		count += child. count ;
		count++;
	});
	this. count = count ;
}

```

- 第一个参数是节点名（如div），第二个参数是节点的属性（如class），第三个参数是子节点（如ul的li）。除了这三个参数会被保存在对象上外，还保存了key和count。其相当于形成了虚拟DOM树。

- 有了JS对象后，最终还需要将其映射成真实DOM
```
Element . prototype. render = function() {
	const el = document. createElement(this . tagName) ;
	const props = this. props ;
	
	for (const propName in props) {
		setAttr(el, propName, props [propName]);
	}
	
	this. children. forEach((child) => {
		const childEl = (child instanceof ELement) ? child. render() : document . Create();
		el. appendChild(childEl);
	});
	
	return el;
};

```

- 我们已经完成了创建虚拟DOM并将其映射成真实DOM，这样所有的更新都可以先反应到虚拟DOM上，如何反应？需要用到Diff算法。

- 两棵树如果完全比较时间复杂度是O(n^3)，但参照《深入浅出React和Redux》一书中的介绍，React的Diff算法的时间复杂度是O(n)。要实现这么低的时间复杂度，意味着只能平层的比较两棵树的节点，放弃了深度遍历。这样做，似乎牺牲掉了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层移动DOM元素，这样做是最优的。

- 我们会有两个虚拟DOM(js对象，new/old进行比较diff)，用户交互我们操作数据变化new虚拟DOM，old虚拟DOM会映射成实际DOM(js对象生成的DOM文档)通过DOM fragment操作给浏览器渲染。当修改new虚拟DOM，会把newDOM和oldDOM通过diff算法比较，得出diff结果数据表(用4种变换情况表示)。再把diff结果表通过DOM fragment更新到浏览器DOM中。

- 虚拟DOM的存在的意义？vdom 的真正意义是为了实现跨平台，服务端渲染，以及提供一个性能还算不错 Dom 更新策略。vdom 让整个 mvvm 框架灵活了起来

- Diff算法只是为了虚拟DOM比较替换效率更高，通过Diff算法得到diff算法结果数据表(需要进行哪些操作记录表)。原本要操作的DOM在vue这边还是要操作的，只不过用到了js的DOM fragment来操作dom（统一计算出所有变化后统一更新一次DOM）进行浏览器DOM一次性更新。其实DOM fragment我们不用平时发开也能用，但是这样程序员写业务代码就用把DOM操作放到fragment里，这就是框架的价值，程序员才能专注于写业务代码。

  #### Compositon api
Composition API也叫组合式API，是Vue3.x的新特性。
```
通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到
可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和
灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能
是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。
在处理如此大的应用程序时，共享和重用代码变得尤为重要
```

通俗的讲：
```
没有Composition API之前vue相关业务的代码需要配置到option的
特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的
维护性比较复杂，同时代码可复用性不高。Vue3.x中的
composition-api就是为了解决这个问题而生的
```

compositon api提供了以下几个函数：
- setup
- ref
- reactive
- watchEffect
- watch
- computed
- toRefs
- 生命周期的hooks

  #### Vue diff算法详解
- updateChildren
- 
> 这个函数是用来比较两个结点的子节点

```js
updateChildren(parentElm, oldCh, newCh) {
    let oldStartIdx = 0,
        newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx
    let idxInOld
    let elmToMove
    let before
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) { // 只有 oldS>oldE 或者 newS>newE 才会终止循环
        if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null
            oldStartVnode = oldCh[++oldStartIdx]
        } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx]
        } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx]
        } else if (newEndVnode == null) { // 到这里是找到第一个不为null的oldStartVnode oldEndVnode newStartVnode newEndVnode
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldStartVnode, newStartVnode)) { // oldS指针和newS指针对应的结点相同时，将oldS和newS指针同时向后移一位
            patchVnode(oldStartVnode, newStartVnode)
            oldStartVnode = oldCh[++oldStartIdx]
            newStartVnode = newCh[++newStartIdx]
        } else if (sameVnode(oldEndVnode, newEndVnode)) { // oldE指针和newE指针对应的结点相同时，将oldE和newE指针同时向前移一位
            patchVnode(oldEndVnode, newEndVnode)
            oldEndVnode = oldCh[--oldEndIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // oldS指针和newE指针对应的结点相同时，将oldS指针对应结点移动到oldE指针之后，同时将oldS指针向后移动一位，newE指针向前移动一位
            patchVnode(oldStartVnode, newEndVnode)
            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
            oldStartVnode = oldCh[++oldStartIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // oldE指针和newS指针对应的结点相同时，将oldE指针对应的结点移动到oldS指针之前，同时将oldE指针向前移动一位，newS指针想后移动一位
            patchVnode(oldEndVnode, newStartVnode)
            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
            oldEndVnode = oldCh[--oldEndIdx]
            newStartVnode = newCh[++newStartIdx]
        } else { // 使用key时的比较
            if (oldKeyToIdx === undefined) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
            }
            idxInOld = oldKeyToIdx[newStartVnode.key]
            if (!idxInOld) {
                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                newStartVnode = newCh[++newStartIdx]
            } else {
                elmToMove = oldCh[idxInOld]
                if (elmToMove.sel !== newStartVnode.sel) {
                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                } else {
                    patchVnode(elmToMove, newStartVnode)
                    oldCh[idxInOld] = null
                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
                }
                newStartVnode = newCh[++newStartIdx]
            }
        }
    }
    if (oldStartIdx > oldEndIdx) { // oldVnode遍历结束了，那就将newVnode里newS指针和newE指针之间的结点添加到oldVnode里
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
    } else if (newStartIdx > newEndIdx) { // newVnode遍历结束了，那就将oldVnonde里oldS指针和oldE指针之间的结点删除
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
    }
}
```

- 时间复杂度： 个树的完全diff 算法是一个时间复杂度为O(n*3） ，vue进行优化转化成O(n) 。

- 理解：
  - 最小量更新，key 很重要。这个可以是这个节点的唯一标识，告诉diff 算法，在更改前后它们是同一个DOM节点
    - 扩展v-for 为什么要有key ，没有key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加key 只会移动减少操作DOM。
  - 只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。
  - 只进行同层比较，不会进行跨层比较。

- diff算法的优化策略：四种命中查找，四个指针
  - 旧前与新前（先比开头，后插入和删除节点的这种情况）
  - 旧后与新后（比结尾，前插入或删除的情况）
  - 旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）
  - 旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）

  #### 移动端适配的方法
```
起因:手机设备屏幕尺寸不一，做移动端的Web页面，需要考虑安卓/IOS的
各种尺寸设备上的兼容，针对移动端设备的页面，设计与前端实现怎样做
能更好地适配不同屏幕宽度的移动设备；
```

- 1. flex 弹性布局
- 2. viewport 适配

    ```html
    <meta name="viewport" content="width=750,initial-scale=0.5">
    ```

    initial-scale = 屏幕的宽度 / 设计稿的宽度

- 3. rem 弹性布局
- 4. rem + viewport 缩放

```
这也是淘宝使用的方案，根据屏幕宽度设定 rem 值，需要适配的元素都
使用 rem 为单位，不需要适配的元素还是使用 px 为单位。（1em = 16px）
```

  #### rem原理
```
rem 布局的本质是等比缩放

rem 是（根）字体大小相对单位，也就是说跟当前元素的 
font-size 没有关系，而是跟整个 body 的 font-size 有关系。
```

  #### rem和em的区别
> 一句话概括：em相对于父元素，rem相对于根元素。

- em
  ```css
  子元素字体大小的 em 是相对于父元素字体大小
  元素的width/height/padding/margin用em的话是
  相对于该元素的font-size
  ```

- rem
  ```js
  rem 是全部的长度都相对于根元素，根元素是谁？<html>元素。
  通常做法是给html元素设置一个字体大小，
  然后其他元素的长度单位就为rem。
  ```

  #### 移动端300ms延迟的原因以及解决方案
```
移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，
因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，
来判断这次操作是不是双击。
```

有三种办法来解决这个问题：
- 1. 通过 meta 标签禁用网页的缩放。

    ```html
    <meta name="viewport" content="user-scalable=no">
    ```

- 2. 更改默认的视口宽度
    ```html
    <meta name="viewport" content="width=device-width">
    ```

- 3. 调用一些 js 库，比如 FastClick
```
   FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒
   点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是
   在检测到 touchend 事件的时候，会通过 DOM 自定义事件
   立即出发模拟一个 click 事件，
   并把浏览器在 300ms 之后的click 事件阻止掉。
```

  #### vue和react技术选型
相同点：
- 数据驱动页面，提供响应式的试图组件
- 都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
- 数据流动单向，都支持服务器的渲染SSR
- 都有支持native的方法，react有React native， vue有wexx

不同点：
- 数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
- 数据渲染：大规模的数据渲染，react更快
- 使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目

```
vue是采用webpack +vue-loader单文件组件格式，html, js, css同一个文件
```

  #### Vue和React数据驱动的区别
```
在数据绑定上来说，vue的特色是双向数据绑定，
而在react中是单向数据绑定。

vue中实现数据绑定靠的是
数据劫持（Object.defineProperty()）+发布-订阅模式
```

vue中实现双向绑定
```html
<input v-model="msg" />
```

react中实现双向绑定
```html
<input value={this.state.msg} onChange={() => this.handleInputChange()} />
```

#### jQuery和vue区别
A、两者的未来发展的区别
- ● jquery介绍：jquery是一个类库，提供了很多方法，不能算框架。在过去和现在Jquery是最流行的web前端js库，可是现在无论国内还是国外，他的使用率正在渐渐被其他的js库所替代。随着浏览器厂商对H5规范统一遵循以及ECMA6在浏览器端的实现，jquery的使用率会越来越低。

- ● vue的介绍：vue是一个刚兴起不久的前端框架，有一套完整的体系，是一个精简的MVVM。从技术角度讲，vue.js专注于MVVM模型的ViewModel层，通过双向数据绑定把view层和Model层连接起来，通过对数据的操作就可以完成对页面视图的渲染。vue以它独特的优势简单、快速、组合、紧凑、强大而迅速崛起。

 为什么说“通过对数据的操作就可以完成对页面视图的渲染”？
- vue.js是一种基于MVVM方式的框架，专注于MVVM模型的ViewModel层，通过双向数据绑定的方式将Model层和View层连接起来。而在vue中实现双向数据绑定的原理是：采用数据劫持结合发布者-订阅者的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时，发布消息给订阅者，触发相应的监听回调。通俗的讲，就是利用observe监听Model层的数据变化；利用Compile来编译解析模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 (model)-》视图更新(view)；视图变化(view)-》数据(model)变更的双向绑定效果。

B、在操作思想上有本质的区别：
- ● jquery是直接操作DOM；使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作；和原生的js区别只在于可以更方便的选取和操作DOM对象；数据和界面是在一起，比如获取input标签的内容
```
$('input').val();
```
还是依赖DOM元素的值。

- ● vue基于一种MVVM模式，使用数据驱动的方式，通过Vue对象将数据和View完全分离开来。对数据进行操作，不在需要引用相应的DOM对象，通过vue对象，将数据和相应的DOM对象相互绑定起来。



C、应用场景的区别
- ● Jquery适用的场景：jquery侧重样式操作，比如一些H5的动画页面；需要js来操作页面样式的页面

- ● Vue适用的场景：vue侧重数据绑定，比如复杂数据操作的后台页面；表单填写页面

有vue之后的改变?
- 改变一：有了前端工程师，而不是随便一个会点html的美工就能跟你抢饭碗！
  - 为什么这么说呢？之前开发都是前端做静态页面，把页面给到后台程序员改成jsp、php、asp等等...一顿乱改，一顿塞变量，做完以后页面样式乱七八糟，最后你再调整css。说白了你会html，css就行了，基本没什么门槛，可以这么说。有了Vue和Node的前端工程化以后，前端工程师能做的事情越来越多，后台人员只需要抛过来一个Api，剩下的就可以都交给前端了

- 改变二：服务端渲染VS客户端渲染
  - 传统的jsp、php或是模板渲染也好，都是服务端渲染，就是客户端一个请求，服务器直接把整个页面返回给你，简单粗暴。但是vue开发是前后端分离开发，通过api进行交互，客户端请求服务器返回json数据，由客户端进行渲染。不仅减轻了服务器的压力速度更快而且渲染更加优雅，代码更容易维护。

  - 当然客户端渲染面临一个首屏加载慢的问题，服务端渲染则刚好能解决这个问题，因此现在ssr并没有没落，一个项目更好的技术选择才是王道。

- 改变三：渲染优雅，代码易维护
  - jQuery是通过DOM来控制数据，不仅笨重而且渲染数据特别麻烦，而 Vue是通过数据来控制状态，通过控制数据来控制渲染，变量可以直接写在标签中，渲染更加优雅。因为前端代码和后台代码都是分开的，所以项目更容易维护，开发效率更高。

- 改变四：项目工程化，结合npm直接安装第三方库
Vue让前端项目更加工程化，同时也规范了前端工程师的代码，而node和npm的加入才是vue能蓬勃发展的重要原因，node为vue提供了本地server和模块化开发的思路，npm更能安装vue项目需要的模块，配合vue使用，比如Moment.js Element ui vuex等等，这些第三方库让Vue有了无限的可能。

- 改变五：跨平台
  - 随着前端技术水平的越来越高，跨平台这件事儿已经变得越来越靠谱，从之前的react native 到现在的weex和uniapp，许多大厂越来越倾向基于Vue的更高级框架开发，uniapp是我们公司一直使用的框架之一，它基于Vue语法，不仅能编译小程序、H5还能一套代码编译成原生App，未来跨平台的趋势是必然的，学好Vue等于做好了准备！


  #### 如何让CSS只在当前组件中起作用
- 将当前组件的<style>修改为<style scoped>

  #### <keep-alive></keep-alive>的作用是什么
```
keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载

<keep-alive></keep-alive> 包裹动态组件时，会缓存
不活动的组件实例,主要用于保留组件状态或避免重新渲染
比如有一个列表和一个详情，那么用户就会
经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情
都是一个频率很高的页面，那么就可以对列表组件
使用<keep-alive></keep-alive>进行缓存，这样用户每次
返回列表的时候，都能从缓存中快速渲染，而不是重新渲染

常用的两个属性include/exclude，允许组件有条件的进行缓存
两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态
```

  #### 指令v-el的作用是什么
- 提供一个在页面上已存在的 DOM元素作为 Vue实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例,

  #### 在Vue中使用插件的步骤
- 采用ES6的import ... from ...语法或CommonJS的require()方法引入插件
- 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })

  #### 请列举出3个Vue中常用的生命周期钩子函数
- created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见
- mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted被调用时 vm.$el 也在文档内。
- activated: keep-alive组件激活时调用

  ##### vue-cli工程技术集合介绍
问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？
- vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。
- vue-router：vue官方推荐使用的路由框架。
- vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。
- axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。
- vuex等：一个专为vue设计的移动端UI组件库。
- 创建一个emit.js文件，用于vue事件机制的管理。
- webpack：模块加载和vue-cli工程打包器。

问题二：vue-cli 工程常用的 npm 命令有哪些？
- 下载 node_modules 资源包的命令：
```
npm install
```

- 启动 vue-cli 开发环境的 npm命令：
```
npm run dev
```

- vue-cli 生成 生产环境部署资源 的 npm命令：
```
npm run build
```

- 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：
```
npm run build --report
```

```
在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、
manifest.js、vendor.js 文件里面所包含代码的页面。可以
具此优化 vue-cli 生产环境部署的静态资源，提升页面的加载速度
```

  #### 实现Vue SSR
SSR了解吗
- SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

- SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求

其基本实现原理
- app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。
- webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。
- 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。
- 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store里取数据。首屏的动态数据通过 window.__INITIAL_STATE__发送到客户端
```
Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的
```

- Vue SSR需要做的事多点（输出完整 HTML），除了complier -> vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。 相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点

  #### Vue组件data为什么必须是函数
- 每个组件都是 Vue 的实例。
- 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他

 #### Vue computed实现
- 建立与其他属性（如：data、 Store）的联系；
- 属性改变后，通知计算属性重新计算

实现时，主要如下
- 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。
- 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。
- Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。
- 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集

  #### Vue complier实现
- 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。
- 总的来说，Vue complier 是将 template 转化成一个 render 字符串。

可以简单理解成以下步骤：
- parse 过程，将 template 利用正则转化成AST 抽象语法树。
- optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。
- generate 过程，生成 render 字符串

  #### 怎么快速定位哪个组件出现性能问题
- 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题

  #### Proxy相比于defineProperty的优势
Object.defineProperty() 的问题主要有三个：
- 不能监听数组的变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套的对象

Proxy 在 ES2015 规范中被正式加入，它有以下几个特点
- 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题
- 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。

除了上述两点之外，Proxy 还拥有以下优势：
- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富
- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。

Proxy的优势如下:
- Proxy可以直接监听对象而非属性
- Proxy可以直接监听数组的变化
- Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

Object.defineProperty的优势如下:
- 兼容性好,支持IE9

Proxy相比于defineProperty的优势
- 数组变化也能监听到
- 不需要深度遍历监听
```
let data = { a: 1 }
let reactiveData = new Proxy(data, {
	get: function(target, name){
		// ...
	},
	// ...
})
```

#### vue-router
mode
- hash
- history

跳转
- this.$router.push()
- <router-link to=""></router-link>

占位
```
<router-view></router-view>
```

  #### vue-router有哪几种导航守卫
- 全局守卫
- 路由独享守卫
- 路由组件内的守卫

全局守卫
```
vue-router全局有三个守卫
```
- router.beforeEach 全局前置守卫 进入路由之前
- router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
- router.afterEach 全局后置钩子 进入路由之后
```
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

路由独享守卫
```
如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫
```
```
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => { 
        // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
        // ...
      }
    }
  ]
})
```

路由组件内的守卫
- beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建
- beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this
- beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this

  #### Vue与Angular以及React的区别
Vue与AngularJS的区别
- Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript
- AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。
- AngularJS社区完善, Vue的学习成本较小

Vue与React的区别
- vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；
- props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；
- 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；
- 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；
- 使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；
- 多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；
- Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；
- react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。
- react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。
- react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin

  #### scoped样式穿透
- scoped虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除scoped属性

- 使用/deep/
```
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
.wrap /deep/ .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

- 使用两个style标签
```
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
//其他样式
</style>
<style lang="scss">
.wrap .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

  #### ref的作用
- 获取dom元素this.$refs.box
- 获取子组件中的datathis.$refs.box.msg
- 调用子组件中的方法this.$refs.box.open()

  #### vue-router守卫
导航守卫 router.beforeEach 全局前置守卫
- to: Route: 即将要进入的目标（路由对象）
- from: Route: 当前导航正要离开的路由
- next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）
- 执行效果依赖 next 方法的调用参数。
- next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
- next(false):取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)
```
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫
```
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

组件内的守卫你可以在路由组件内直接定义以下路由导航守卫
```
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}
```

  #### vue修饰符
- stop：阻止事件的冒泡
- prevent：阻止事件的默认行为
- once：只触发一次
- self：只触发自己的事件行为时，才会执行

  #### vue项目中的性能优化
- 不要在模板里面写过多表达式
- 循环调用子组件时添加key
- 频繁切换的使用v-show，不频繁切换的使用v-if
- 尽量少用float，可以用flex
- 按需加载，可以用require或者import()按需加载需要的组件
- 路由懒加载

代码层面：
- 合理使用 v-if 和 v-show
- 区分 computed 和 watch 的使用
- v-for 遍历为 item 添加 key
- v-for 遍历避免同时使用 v-if
- 通过 addEventListener添加的事件在组件销毁时要用 removeEventListener 手动移除这些事件的监听
- 图片懒加载
- 路由懒加载
- 第三方插件按需引入
- SSR服务端渲染，首屏加载速度快，SEO效果好

Webpack 层面优化：
- 对图片进行压缩
- 使用 CommonsChunkPlugin 插件提取公共代码
- 提取组件的 CSS
- 优化 SourceMap
- 构建结果输出分析，利用 webpack-bundle-analyzer 可视化分析工具

你都做过哪些Vue的性能优化
- 编码阶段
  - 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
  - v-if和v-for不能连用
  - 如果需要使用v-for给每项元素绑定事件时使用事件代理
  - SPA 页面采用keep-alive缓存组件
  - 在更多的情况下，使用v-if替代v-show
  - key保证唯一
  - 使用路由懒加载、异步组件
  - 防抖、节流
  - 第三方模块按需导入
  - 长列表滚动到可视区域动态加载
  - 图片懒加载

- SEO优化
  - 预渲染
  - 服务端渲染SSR

- 打包优化
  - 压缩代码
  - Tree Shaking/Scope Hoisting
  - 使用cdn加载第三方模块
  - 多线程打包happypack
  - splitChunks抽离公共文件
  - sourceMap优化

- 用户体验
  - 骨架屏
  - PWA
```
还可以使用缓存(客户端缓存、服务端缓存)优化、
服务端开启gzip压缩等。
```

#### Vue性能优化
编码优化：
- 事件代理
- keep-alive
- 拆分组件
- key 保证唯一性
- 路由懒加载、异步组件
- 防抖节流

Vue加载性能优化
- 第三方模块按需导入（babel-plugin-component ）
- 图片懒加载

用户体验
- app-skeleton 骨架屏
- shellap p壳
- pwa

SEO优化
- 预渲染

  #### vue.extend和vue.component
- extend是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。
- Vue.component你可以创建 ，也可以取组件。

  #### Vue的SPA如何优化加载速度
- 减少入口文件体积
- 静态资源本地缓存
- 开启Gzip压缩
- 使用SSR,nuxt.js

  #### 移动端如何设计一个比较友好的Header组件
- 当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格

  #### 你是如何理解Vue的响应式系统的
响应式系统简述:
- 任何一个 Vue Component 都有一个与之对应的 Watcher 实例。
- Vue 的 data 上的属性会被添加 getter 和 setter 属性。
- 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)
- data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。

  #### 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异
现代前端框架有两种方式侦测变化,一种是pull一种是push
- pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。
- push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的

  #### Vue为什么没有类似于React中shouldComponentUpdate的生命周期
考点: Vue的变化侦测原理
前置知识: 依赖收集、虚拟DOM、响应式系统
```
根本原因是Vue与React的变化侦测方式有所不同
```
- React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.
- Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.

  #### 说一下vue2.x中如何监测数组变化
- 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

#### vue中是如何检测数组变化的呢
- 数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解

- 是用函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新
- 数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

- vue3：改用 proxy ，可直接监听对象数组的变化

  #### 你的接口请求一般放在哪个生命周期中
- 接口请求一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中

  #### Vue事件绑定原理说一下
- 原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的

#### Vue的事件绑定原理
- 原生 DOM 的绑定：Vue在创建真实DOM时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMLListeners方法，内部会传入 add（） 方法
- 组件绑定事件，原生事件，自定义事件；组件绑定之间是通过Vue中自定义的 $on 方法实现的

- 可以理解为：组件的 nativeOnOn 等价于 普通元素on 组件的on会单独处理

  #### Vue模版编译原理知道吗，能简单说一下吗
```简单说，Vue的编译过程就是将template转化为
render函数的过程。会经历以下阶段：
```
- 生成AST树
- 优化
- codegen
- 首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
- Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
- 编译的最后一步是将优化后的AST树转换为可执行的代码

  #### Vue2.x和Vue3.x渲染器的diff算法分别说一下
简单来说，diff算法有以下过程
- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心diff)
- 递归比较子节点
- 正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。
- Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅
- 在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升

  #### 再说一下虚拟Dom以及key属性的作用
- 由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因
- Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象
- VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段

key的作用是尽可能的复用 DOM 元素
- 新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的
- 需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识

  #### Vue中组件生命周期调用顺序说一下
- 组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。
- 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。

加载渲染过程
```
父beforeCreate->父created->父beforeMount->子beforeCreate->
子created->子beforeMount- >子mounted->父mounted
```

子组件更新过程
```
父beforeUpdate->子beforeUpdate->子updated->父updated
```

父组件更新过程
```
父 beforeUpdate -> 父 updated
```

销毁过程
```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

  #### 请说出vue.cli项目中src目录每个文件夹和文件的用法
- assets文件夹是放静态资源；
- components是放组件；
- router是定义路由相关的配置;
- view视图；
- app.vue是一个应用主组件；
- main.js是入口文件

  #### delete和Vue.delete删除数组的区别
- delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
- Vue.delete直接删除了数组 改变了数组的键值。
```
var a=[1,2,3,4]
var b=[1,2,3,4]
delete a[0]
console.log(a)  //[empty,2,3,4]
this.$delete(b,0)
console.log(b)  //[2,3,4]
```

  #### v-on可以监听多个方法吗
可以
```
<input type="text" :value="name" @input="onInput" @focus="onFocus" @blur="onBlur" />
```

v-on 常用修饰符
- .stop 该修饰符将阻止事件向上冒泡。同理于调用 event.stopPropagation() 方法
- .prevent 该修饰符会阻止当前事件的默认行为。同理于调用 event.preventDefault() 方法
- .self 该指令只当事件是从事件绑定的元素本身触发时才触发回调
- .once 该修饰符表示绑定的事件只会被触发一次

  #### vue如何兼容ie的问题
- babel-polyfill插件

  #### Vue改变数组触发视图更新
- 以下方法调用会改变原始数组：push(), pop(), shift(), unshift(), splice(), sort(), reverse(),Vue.set( target, key, value )

- 调用方法：Vue.set( target, key, value )
  - target：要更改的数据源(可以是对象或者数组)
  - key：要更改的具体数据
  - value ：重新赋的值

  #### DOM渲染在哪个周期中就已经完成
- 在mounted

- 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted
```
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

  #### 动态绑定class
- active classname， isActive 变量
```
<div :class="{ active: isActive }"></div>
```

#### Vue3.0是如何变得更快的
diff方法优化
- Vue2.x 中的虚拟 dom 是进行全量的对比。
- Vue3.0 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化

hoistStatic 静态提升
- Vue2.x : 无论元素是否参与更新，每次都会重新创建。
- Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用

cacheHandlers 事件侦听器缓存
- 默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可

#### 说说你对proxy的理解
vue 的数据劫持有两个缺点
- 无法监听通过索引修改数组的值的变化
- 无法监听 object 也就是对象的值的变化
- 所以 vue2.x 中才会有$set 属性的存在
- proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。

#### Composition API
- Composition API出现就是为了解决Options API导致相同功能代码分散的现象

compositon api提供了以下几个函数：
- setup
- ref
- reactive
- watchEffect
- watch
- computed
- toRefs
- 生命周期的hooks

#### 为什么Vue采用异步渲染呢
- Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick

- dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）

#### 如何从真实DOM到虚拟DOM
涉及到Vue中的模板编译原理，主要过程：
- 将模板转换成ast 树，ast 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）
- 优化树
- 将ast树生成代码

#### 为什么要使用异步组件
- 节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题。
- 核心就是包组件定义变成一个函数，依赖import（） 语法，可以实现文件的分割加载。

#### action与mutation的区别
- mutation 是同步更新，$watch 严格模式下会报错
- action 是同步操作，可以获取数据后调用mutation 提交最终数据

#### 插槽与作用域插槽的区别
插槽
- 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类{a:[vnode],b[vnode]}
- 渲染组件时会拿对应的slot 属性的节点进行替换操作。（插槽的作用域为父组件）

作用域插槽
- 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。
- 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。

#### vue中相同逻辑如何抽离
- 其实就是考察vue.mixin 用法，给组件每个生命周期，函数都混入一些公共逻辑。

#### 谈谈对keep-alive的了解
- keep-alive 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性include/exclude ，2个生命周期activated ，deactivated

#### Vue3.0相对于Vue2.x有哪些不同
performance
- 首先在性能(performance)上有了更多的优化，一方面表现在virtual dom的生成上更快了，另外在底层还做了一些监听的缓存，也就是事件在被创建的时候会被推进一个缓存中，后续没有改变会直接取缓存。

tree-shaking
- tree-shaking它表示的是在打包的时候会去除一些无用的代码。而在Vue3中对它的支持更加友好了，例如像transition、v-model、computed等功能没有用到的话，那么最后打包产生的代码就会将它们去除。也就是说，如果你的Vue项目只写了一个Hello Word的话，那么最后打包的代码中就只有一些核心的代码，如更新算法、响应式等，打包生成的文件可能就只有13.5kb。

Fragments
- 碎片(Fragments)，原本在Vue2.x中每个template下只能允许有一个根节点，但是在Vue3中它可以允许你有多个，用尤大大的话来说就是会将这些内容自动变为一个碎片。

TS
- 再者就是对TS的支持度很好。虽然Vue3本来就是用TS写的，但是不一定要用TS。另外它也支持Class Component，不过不是第一推荐。

Component API
- 语法上，对模版语法是零改变的。只不过更加推荐用Component API来写JS部分。Component API它并不是语法，而是新增的API。它带来的好处一个是逻辑重用，方便我们把一些功能的部分抽离出来。另一个它相对于options来说更加集中，用options来写代码想要追寻一个变量的变化比较麻烦。

关于兼容性
- 目前的Vue3.beta版本是不支持IE11的，因为核心的响应式原理用到了ES6的Proxy，但是以后会去兼容IE11。后面我们在创建一个Vue项目的时候，可以选择不同的版本，支持IE11和不支持IE11的。

什么时候能使用
- 现在的beta版本其实已经可以用了，对于一些新的小的项目可以试试水，这个可以自己评估。正式能够投入到生产使用中可能要等到年中 (终？)。


#### 如何监听pushState和replaceState的变化呢
利用自定义事件new Event()创建这两个事件，并全局监听：
```
<body>
  <button onclick="goPage2()">去page2</button>
  <div>Page1</div>
  <script>
    let count = 0;
    function goPage2 () {
      history.pushState({ count: count++ }, `bb${count}`,'page1.html')
      console.log(history)
    }
    // 这个不能监听到 pushState
    // window.addEventListener('popstate', function (event) {
    //   console.log(event)
    // })
    function createHistoryEvent (type) {
      var fn = history[type]
      return function () {
        // 这里的 arguments 就是调用 pushState 时的三个参数集合
        var res = fn.apply(this, arguments)
        let e = new Event(type)
        e.arguments = arguments
        window.dispatchEvent(e)
        return res
      }
    }
    history.pushState = createHistoryEvent('pushState')
    history.replaceState = createHistoryEvent('replaceState')
    window.addEventListener('pushState', function (event) {
      // { type: 'pushState', arguments: [...], target: Window, ... }
      console.log(event)
    })
    window.addEventListener('replaceState', function (event) {
      console.log(event)
    })
  </script>
</body>
```

#### Vue组件内的导航守卫有哪几个
- beforeRouteEnter
- beforeRouteUpdate
- beforeLeave

#### beforeRouteEnter和另外两个有什么不同吗
- beforeRouteEnter是支持给next传递参数的唯一守卫，因为在这个路由守卫中还不能访问this，而为了能让我们访问组件实例，可以通过传一个回调给next：
```
beforeRouteEnter(to, from, next) {
	next(vm => {
		// vm 就是组件实例
	})	
}
```

而对于另外两个，this已经可用，所以不支持传递回调：
```
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
```
- 离开守卫beforeRouteLeave通常用来禁止用户还未保存修改之前离开，可以通过next(false)来取消：
```
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

#### 完整的导航解析流程
- 导航被触发。
- 在失活的组件里调用离开守卫。
- 调用全局的 beforeEach 守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
- 在路由配置里调用 beforeEnter。
- 解析异步路由组件。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫 (2.5+)。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 触发 DOM 更新。
- 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

#### 你是怎么看Vue和React的
首先它们都是当今比较流行的前端框架。

相同点：
- Virtual DOM。其中最大的一个相似之处就是都使用了Virtual DOM。(当然Vue是在Vue2.x才引用的)也就是能让我们通过操作数据的方式来改变真实的DOM状态。因为其实Virtual DOM的本质就是一个JS对象，它保存了对真实DOM的所有描述，是真实DOM的一个映射，所以当我们在进行频繁更新元素的时候，改变这个JS对象的开销远比直接改变真实DOM要小得多。
- 组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。
- Props。Vue和React中都有props的概念，允许父组件向子组件传递数据。
- 构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，React中可以使用CRA，Vue中可以使用对应的脚手架vue-cli。对于配套框架Vue中有vuex、vue-router，React中有react-router、redux。

不同点
- 模版的编写。最大的不同就是模版的编写，Vue鼓励你去写近似常规HTML的模板，React推荐你使用JSX去书写。
- 状态管理与对象属性。在React中，应用的状态是比较关键的概念，也就是state对象，它允许你使用setState去更新状态。但是在Vue中，state对象并不是必须的，数据是由data属性在Vue对象中进行管理。
- 虚拟DOM的处理方式不同。Vue中的虚拟DOM控制了颗粒度，组件层面走watcher通知，而组件内部走vdom做diff，这样，既不会有太多watcher，也不会让vdom的规模过大。而React走了类似于CPU调度的逻辑，把vdom这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做diff。

#### Vue性能优化
#### vue首屏加载优化有哪些方案么
- Vue-Router路由懒加载（利用Webpack的代码切割）
- 使用CDN加速，将通用的库从vendor进行抽离
- Nginx的gzip压缩
- Vue异步组件
- 服务端渲染SSR
- 如果使用了一些UI库，采用按需加载
- Webpack开启gzip压缩
- Service Worker缓存文件处理
- 使用link标签的rel属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

#### 编码阶段
- 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；
- 如果需要使用v-for给每项元素绑定事件时使用事件代理；
- SPA 页面采用keep-alive缓存组件；
- 在更多的情况下，使用v-if替代v-show；
- key保证唯一；
- 使用路由懒加载、异步组件；
- 防抖、节流；
- 第三方模块按需导入；
- 长列表滚动到可视区域动态加载；
- 图片懒加载；

#### 用户体验：
- 骨架屏；
- PWA；
- 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

#### SEO优化
- 预渲染；
- 服务端渲染SSR；

#### 打包优化
- 压缩代码；
- Tree Shaking/Scope Hoisting；
  - scope hoisting 是 webpack3 的新功能，直译过来就是「作用域提升」。熟悉 JavaScript 都应该知道「函数提升」和「变量提升」，JavaScript 会把函数和变量声明提升到当前作用域的顶部。「作用域提升」也类似于此，webpack 会把引入的 js 文件“提升到”它的引入者顶部
- 使用cdn加载第三方模块；
- 多线程打包happypack；
- splitChunks抽离公共文件；
- sourceMap优化；

#### vue1.X，vue2.X，vue3框架分析性能
#### Vue1.x（特点：响应式）
- 没有vdom，完全的响应式，每个数据变化，都通过响应式通知机制来新建Watcher干活，项目规模变大后，过多的Watcher，会导致性能的瓶颈。

#### Vue2.x（特点：组件级响应式，组件内部vdom diff）
- 引入vdom，控制了颗粒度，组件层面走watcher通知， 组件内部走vdom做diff，既不会有太多watcher，也不会让vdom的规模过大，diff超过16ms，真是优秀。

#### Vue3（特点：proxy做响应式：静态标记、按需更新）
- 先说结论，静态标记，upadte性能提升1.3~2倍，ssr提升2~3倍。
- Vue3通过Proxy响应式+组件内部vdom+静态标记，把任务颗粒度控制的足够细致，所以也不太需要time-slice了。





### 常用设计模式
#### 创建型-工厂模式
#### 简单工厂模式
- 其实就是将创建对象的过程单独封装，同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了
```
// 给不同工种分配职责说明
function User(name, age, career, work) {
    this.name = name;
    this.age = age;
    this.career = career;
    this.work = work;
}

function Factory(name, age, career) {
    let work;
    switch (career) {
        case 'coder': {
            work = ['写代码', '写系分', '修bug']
            break;
        }
        case 'product-manager': {
            work = ['订会议室', '写PRD', '催更']
            break;
        }
        case 'boss': {
            work = ['喝茶', '看报', '见客户']
            break;
        }
    }
    return new User(name, age, career, work)
}

const wang = new Factory('wang', 50, 'boss');
const sun = new Factory('sun', 25, 'coder');
const li = new Factory('li', 30, 'product-manager');

console.log(wang)
console.log(sun)
console.log(li)
```

#### 抽象工厂模式
```
// 定义操作系统这类产品的抽象产品类
class OS {
    constructor() {
        if (new.target === OS) {
            throw new Error('不能实例化抽象类');
        }
    }
}

// 定义具体操作系统的具体产品类
class AndroidOS extends OS {
    constructor() {
        super();
    }

    controlHardware() {
        console.log('我会用安卓的方式去操作硬件');
    }
}

class AppleOS extends OS {
    constructor() {
        super();
    }

    controlHardware() {
        console.log('我会用苹果的方式去操作硬件');
    }
}

// 定义手机硬件这类产品的抽象产品类
class Hardware {
    constructor() {
        if (new.target === Hardware) {
            throw new Error('不能实例化抽象类');
        }
    }

    // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性
    operateByOrder() {
        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');
    }
}

// 定义具体硬件的具体产品类
class QualcommHardware extends Hardware {
    constructor() {
        super();
    }

    operateByOrder() {
        console.log('我会用高通的方式去运转')
    }
}

class MiWare extends Hardware {
    constructor() {
        super();
    }

    operateByOrder() {
        console.log('我会用小米的方式去运转')
    }
}

class MobilePhoneFactory {
    // 提供操作系统的接口
    createOS() {
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }

    // 提供硬件的接口
    createHardware() {
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }
}

// 具体工厂继承自抽象工厂
class FakeStarFactory extends MobilePhoneFactory {
    constructor() {
        super()
    }

    createOS() {
        // 提供安卓系统实例
        return new AndroidOS()
    }

    createHardware() {
        // 提供高通硬件实例
        return new QualcommHardware()
    }
}

// 这是我的手机
const myPhone = new FakeStarFactory()
// 让它拥有操作系统
const myOS = myPhone.createOS()
// 让它拥有硬件
const myHardWare = myPhone.createHardware()
// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)
myOS.controlHardware()
// 唤醒硬件(输出‘我会用高通的方式去运转’)
myHardWare.operateByOrder()
```
抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？
- 它们的共同点，在于都尝试去分离一个系统中变与不变的部分。
- 它们的不同在于场景的复杂度。

- 在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分

#### 创建型-单例模式
- 保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。

#### 单例模式的实现思路
- 单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。
- 要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。我们现在把这段判断逻辑写成一个静态方法(其实也可以直接写入构造函数的函数体里）：
```
// 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
class Singleton {
    constructor(name) {
        this.name = name;
        this.instance = null;
    }

    getName(){
        console.log(this.name);
    }

    getInstance(name){
        if(!this.instance){
            this.instance = new Singleton(name);
        }

        return this.instance;
    }
}

const singleton = new Singleton();

const a = singleton.getInstance('a');
const b = singleton.getInstance('b');

console.log(a);
console.log(b);
console.log(a === b);
```

```class SingleDog {
    show() {
        console.log('我是一个单例对象')
    }
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!SingleDog.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            SingleDog.instance = new SingleDog()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return SingleDog.instance
    }
}

const s1 = SingleDog.getInstance()
const s2 = SingleDog.getInstance()

// true
s1 === s2
```
除了楼上这种实现方式之外，getInstance的逻辑还可以用闭包来实现：
```
SingleDog.getInstance = (function() {
    // 定义自由变量instance，模拟私有变量
    let instance = null
    return function() {
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new SingleDog()
        }
        return instance
    }
})()
```
- 可以看出，在getInstance方法的判断和拦截下，我们不管调用多少次，SingleDog都只会给我们返回一个实例，s1和s2现在都指向这个唯一的实例

##### 生产实践：Vuex中的单例模式
- Redux 和 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。这个 Store 的实现，正是单例模式的典型应用

1.理解 Vuex 中的 Store
- Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档

- 当组件非常多、组件间关系复杂、且嵌套层级很深的时候，这种原始的通信方式会使我们的逻辑变得复杂难以维护。这时最好的做法是将共享的数据抽出来、放在全局，供组件们按照一定的的规则去存取数据，保证状态以一种可预测的方式发生变化。于是便有了 Vuex，这个用来存放共享数据的唯一数据源，就是 Store。

2. Vuex如何确保Store的唯一性
- 我们先来看看如何在项目中引入 Vuex：
```
// 安装vuex插件
Vue.use(Vuex)

// 将store注入到Vue实例中
new Vue({
    el: '#app',
    store
})
```
- 通过调用Vue.use()方法，我们安装了 Vuex 插件。Vuex 插件是一个对象，它在内部实现了一个 install 方法，这个方法会在插件安装时被调用，从而把 Store 注入到Vue实例里去。也就是说每 install 一次，都会尝试给 Vue 实例注入一个 Store

- 在install方法里，有一段逻辑和我们楼上的 getInstance 非常相似的逻辑：
```
let Vue // 这个Vue的作用和楼上的instance作用一样
...

export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```
- 楼上便是 Vuex 源码中单例模式的实现办法了，套路可以说和我们的getInstance如出一辙。通过这种方式，可以保证一个 Vue 实例（即一个 Vue 应用）只会被 install 一次 Vuex 插件，所以每个 Vue 实例只会拥有一个全局的 Store

3. 思考时间
- 思考一下：如果我在 install 里没有实现单例模式，会带来什么样的麻烦？

- 我们通过上面的源码解析可以看出，每次 install 都会为Vue实例初始化一个 Store。假如 install 里没有单例模式的逻辑，那我们如果在一个应用里不小心多次安装了插件：
```
// 在主文件里安装Vuex
Vue.use(Vuex)

...(中间添加/修改了一些store的数据)

// 在后续的逻辑里不小心又安装了一次
Vue.use(Vuex)
```
- 失去了单例判断能力的 install 方法，会为当前的Vue实例重新注入一个新的 Store，也就是说你中间的那些数据操作全都没了，一切归 0。因此，单例模式在此处是非常必要的。

- 除了说在 Vuex 中大展身手，我们在 Redux、jQuery 等许多优秀的前端库里也都能看到单例模式的身影

#### 单例模式——面试真题
实现一个 Storage
1. 描述
- 实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)

2. 思路
- 具体实现上，把判断逻辑写入静态方法或者构造函数里都没关系，最好能把闭包的版本也写出来

3. 实现：静态方法版
```
// 定义Storage
class Storage {
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!Storage.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            Storage.instance = new Storage()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return Storage.instance
    }
    getItem (key) {
        return localStorage.getItem(key)
    }
    setItem (key, value) {
        return localStorage.setItem(key, value)
    }
}

const storage1 = Storage.getInstance()
const storage2 = Storage.getInstance()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

4. 实现： 闭包版
```
// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上
function StorageBase () {}
StorageBase.prototype.getItem = function (key){
    return localStorage.getItem(key)
}
StorageBase.prototype.setItem = function (key, value) {
    return localStorage.setItem(key, value)
}

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function(){
    let instance = null
    return function(){
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new StorageBase()
        }
        return instance
    }
})()

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 
const storage1 = new Storage()
const storage2 = new Storage()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

#### 实现一个全局的模态框
实现一个全局唯一的Modal弹框

思路
- 这道题比较经典，基本上所有讲单例模式的文章都会以此为例，同时它也是早期单例模式在前端领域的最集中体现。

- 万变不离其踪，记住getInstance方法、记住instance变量、记住闭包和静态方法，这个题除了要多写点 HTML 和 CSS 之外，对大家来说完全不成问题。

实现
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>打开弹框</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    const Modal = (function() {
    	let modal = null
    	return function() {
            if(!modal) {
            	modal = document.createElement('div')
            	modal.innerHTML = '我是一个全局唯一的Modal'
            	modal.id = 'modal'
            	modal.style.display = 'none'
            	document.body.appendChild(modal)
            }
            return modal
    	}
    })()
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
    	const modal = new Modal()
    	modal.style.display = 'block'
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
    	const modal = new Modal()
    	if(modal) {
    	    modal.style.display = 'none'
    	}
    })
</script>
</html>
```
- 是不是发现又是熟悉的套路？又可以默写了？（ES6 版本的实现大家自己尝试默写一下，相信对现在的你来说已经非常简单了）。

- 这就是单例模式面试题的特点，准确地说，是所有设计模式相关面试题的特点——牢记核心思路，就能举一反三。所以说设计模式的学习是典型的一分耕耘一分收获，性价比极高。

#### 结构型-装饰器模式
- 装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。

#### 装饰器模式初相见
- 为了不被已有的业务逻辑干扰，当务之急就是将旧逻辑与新逻辑分离，把旧逻辑抽出去：
```
// 将展示Modal的逻辑单独封装
function openModal() {
    const modal = new Modal()
    modal.style.display = 'block'
}
```

编写新逻辑：
```
// 按钮文案修改逻辑
function changeButtonText() {
    const btn = document.getElementById('open')
    btn.innerText = '快去登录'
}

// 按钮置灰逻辑
function disableButton() {
    const btn =  document.getElementById('open')
    btn.setAttribute("disabled", true)
}

// 新版本功能逻辑整合
function changeButtonStatus() {
    changeButtonText()
    disableButton()
}
```
然后把三个操作逐个添加open按钮的监听函数里：
```
document.getElementById('open').addEventListener('click', function() {
    openModal()
    changeButtonStatus()
})
```
- 如此一来，我们就实现了“只添加，不修改”的装饰器模式，使用changeButtonStatus的逻辑装饰了旧的按钮点击逻辑。以上是ES5中的实现，ES6中，我们可以以一种更加面向对象化的方式去写：
```
// 定义打开按钮
class OpenButton {
    // 点击后展示弹框（旧逻辑）
    onClick() {
        const modal = new Modal()
    	modal.style.display = 'block'
    }
}

// 定义按钮对应的装饰器
class Decorator {
    // 将按钮实例传入
    constructor(open_button) {
        this.open_button = open_button
    }
    
    onClick() {
        this.open_button.onClick()
        // “包装”了一层新逻辑
        this.changeButtonStatus()
    }
    
    changeButtonStatus() {
        this.changeButtonText()
        this.disableButton()
    }
    
    disableButton() {
        const btn =  document.getElementById('open')
        btn.setAttribute("disabled", true)
    }
    
    changeButtonText() {
        const btn = document.getElementById('open')
        btn.innerText = '快去登录'
    }
}

const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```
- 大家这里需要特别关注一下 ES6 这个版本的实现，这里我们把按钮实例传给了 Decorator，以便于后续 Decorator 可以对它为所欲为进行逻辑的拓展。在 ES7 中，Decorator 作为一种语法被直接支持了，它的书写会变得更加简单，但背后的原理其实与此大同小异

#### 深入装饰器原理
- 在 ES7 中，我们可以像写 python 一样通过一个@语法糖轻松地给一个类装上装饰器：
```
// 装饰器函数，它的第一个参数是目标类
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}

// 验证装饰器是否生效
console.log('Button 是否被装饰了：', Button.hasDecorator)
```
也可以用同样的语法糖去装饰类里面的方法：
```
// 具体的参数意义，在下个小节，这里大家先感知一下操作
function funcDecorator(target, name, descriptor) {
  let originalMethod = descriptor.value
  descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}

// 验证装饰器是否生效
const button = new Button()
button.onClick()
```

#### 装饰器语法糖背后的故事
- 所谓语法糖，往往意味着“美好的表象”。正如 class 语法糖背后是大家早已十分熟悉的 ES5 构造函数一样，装饰器语法糖背后也是我们的老朋友，不信我们一起来看看@decorator都帮我们做了些什么：

- 上一节我们使用 ES6 实现装饰器模式时曾经将按钮实例传给了 Decorator，以便于后续 Decorator 可以对它进行逻辑的拓展。这也正是装饰器的最最基本操作——定义装饰器函数，将被装饰者“交给”装饰器。这也正是装饰器语法糖首先帮我们做掉的工作 —— 函数传参&调用。

1. 类装饰器的参数
当我们给一个类添加装饰器时：
```
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}
```
此处的 target 就是被装饰的类本身。

2. 方法装饰器的参数
而当我们给一个方法添加装饰器时：
```
function funcDecorator(target, name, descriptor) {
    let originalMethod = descriptor.value
    descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}   
```
- 此处的 target 变成了Button.prototype，即类的原型对象。这是因为 onClick 方法总是要依附其实例存在的，修饰 onClik 其实是修饰它的实例。但我们的装饰器函数执行的时候，Button 实例还并不存在。为了确保实例生成后可以顺利调用被装饰好的方法，装饰器只能去修饰 Button 类的原型对象。

3. 装饰器函数调用的时机
- 装饰器函数执行的时候，Button 实例还并不存在。这是因为实例是在我们的代码运行时动态生成的，而装饰器函数则是在编译阶段就执行了。所以说装饰器函数真正能触及到的，就只有类这个层面上的对象

#### 将“属性描述对象”交到你手里
- 在编写类装饰器时，我们一般获取一个target参数就足够了。但在编写方法装饰器时，我们往往需要至少三个参数：
```
function funcDecorator(target, name, descriptor) {
  let originalMethod = descriptor.value
  descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}
```
- 第一个参数的意义，前文已经解释过。第二个参 数name，是我们修饰的目标属性属性名，也没啥好讲的。关键就在这个 descriptor 身上，它也是我们使用频率最高的一个参数，它的真面目就是“属性描述对象”（attributes object）。这个名字大家可能不熟悉，但Object.defineProperty方法我想大家多少都用过，它的调用方式是这样的：
```
Object.defineProperty(obj, prop, descriptor)
```
- 此处的descriptor和装饰器函数里的 descriptor 是一个东西，它是 JavaScript 提供的一个内部数据结构、一个对象，专门用来描述对象的属性。它由各种各样的属性描述符组成，这些描述符又分为数据描述符和存取描述符：

- 数据描述符：
  - 包括 value（存放属性值，默认为默认为 undefined）
  - writable（表示属性值是否可改变，默认为true）
  - enumerable（表示属性是否可枚举，默认为 true）
  - configurable（属性是否可配置，默认为true）。
- 存取描述符：
  - 包括 get 方法（访问属性时调用的方法，默认为 undefined）
  - set（设置属性时调用的方法，默认为 undefined ）

- 很明显，拿到了 descriptor，就相当于拿到了目标方法的控制权。通过修改 descriptor，我们就可以对目标方法为所欲为的逻辑进行拓展了~

- 在上文的示例中，我们通过 descriptor 获取到了原函数的函数体（originalMethod），把原函数推迟到了新逻辑（console）的后面去执行。这种做法和我们上一节在ES5中实现装饰器模式时做的事情一模一样，所以说装饰器就是这么回事儿，换汤不换药~

#### React中的装饰器：HOC
- 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。

- HOC (Higher Order Component) 即高阶组件。它是装饰器模式在 React 中的实践，同时也是 React 应用中非常重要的一部分。通过编写高阶组件，我们可以充分复用现有逻辑，提高编码效率和代码的健壮性。

- 我们现在编写一个高阶组件，它的作用是把传入的组件丢进一个有红色边框的容器里（拓展其样式）。
```
import React, { Component } from 'react'

const BorderHoc = WrappedComponent => class extends Component {
  render() {
    return <div style={{ border: 'solid 1px red' }}>
      <WrappedComponent />
    </div>
  }
}
export default borderHoc
```
用它来装饰目标组件
```
import React, { Component } from 'react'
import BorderHoc from './BorderHoc'

// 用BorderHoc装饰目标组件
@BorderHoc 
class TargetComponent extends React.Component {
  render() {
    // 目标组件具体的业务逻辑
  }
}

// export出去的其实是一个被包裹后的组件
export default TargetComponent
```
- 可以看出，高阶组件从实现层面来看其实就是上文我们提到的类装饰器。在高阶组件的辅助下，我们不必因为一个小小的拓展而大费周折地编写新组件或者把一个新逻辑重写 N 多次，只需要轻轻 @ 一下装饰器即可。

#### 使用装饰器改写Redux connect
- Redux 是热门的状态管理工具。在 React 中，当我们想要引入 Redux 时，通常需要调用 connect 方法来把状态和组件绑在一起：
```
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import action from './action.js'

class App extends Component {
  render() {
    // App的业务逻辑
  }
}

function mapStateToProps(state) {
  // 假设App的状态对应状态树上的app节点
  return state.app
}

function mapDispatchToProps(dispatch) {
  // 这段看不懂也没关系，下面会有解释。重点理解connect的调用即可
  return bindActionCreators(action, dispatch)
}

// 把App组件与Redux绑在一起
export default connect(mapStateToProps, mapDispatchToProps)(App)
```
- 这里给没用过 redux 的同学解释一下 connect 的两个入参：mapStateToProps 是一个函数，它可以建立组件和状态之间的映射关系；mapDispatchToProps也是一个函数，它用于建立组件和store.dispatch的关系，使组件具备通过 dispatch 来派发状态的能力。

- 总而言之，我们调用 connect 可以返回一个具有装饰作用的函数，这个函数可以接收一 个React 组件作为参数，使这个目标组件和 Redux 结合、具备 Redux 提供的数据和能力。既然有装饰作用，既然是能力的拓展，那么就一定能用装饰器来改写：

把 connect 抽出来：
```
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import action from './action.js'

function mapStateToProps(state) {
  return state.app
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators(action, dispatch)
}

// 将connect调用后的结果作为一个装饰器导出
export default connect(mapStateToProps, mapDispatchToProps)
```
在组件文件里引入connect：
```
import React, { Component } from 'react'
import connect from './connect.js'   

@connect
export default class App extends Component {
  render() {
    // App的业务逻辑
  }
}
```
这样一来，我们的代码结构是不是清晰了很多
- 推荐一个非常赞的装饰模式库 —— core-decorators (opens new window)。core-decorators 帮我们实现好了一些使用频率较高的装饰器，比如@readonly(使目标属性只读)、@deprecate(在控制台输出警告，提示用户某个指定的方法已被废除)等

#### 结构型-适配器模式
#### 兼容接口
- 大家知道我们现在有一个非常好用异步方案叫fetch，它的写法比ajax优雅很多。因此在不考虑兼容性的情况下，我们更愿意使用fetch、而不是使用ajax来发起异步请求。李雷是拜fetch教的忠实信徒，为了能更好地使用fetch，他封装了一个基于fetch的http方法库：

```
export default class HttpUtils {
  // get方法
  static get(url) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url)
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }
  
  // post方法，data以object形式传入
  static post(url, data) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        // 将object类型的数据格式化为合法的body参数
        body: this.changeData(data)
      })
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }
  
  // body请求体的格式化方法
  static changeData(obj) {
    var prop,
      str = ''
    var i = 0
    for (prop in obj) {
      if (!prop) {
        return
      }
      if (i == 0) {
        str += prop + '=' + obj[prop]
      } else {
        str += '&' + prop + '=' + obj[prop]
      }
      i++
    }
    return str
  }
}
```
- 当我想使用 fetch 发起请求时，只需要这样轻松地调用，而不必再操心繁琐的数据配置和数据格式化：
```
// 定义目标url地址
const URL = "xxxxx"
// 定义post入参
const params = {
    ...
}

// 发起post请求
 const postResponse = await HttpUtils.post(URL,params) || {}
 
 // 发起get请求
 const getResponse = await HttpUtils.get(URL)
```
- 真是个好用的方法库！老板看了李雷的 HttpUtils 库，喜上眉梢——原来老板也是个拜 fetch 教。老板说李雷，咱们公司以后要做潮流公司了，写代码不再考虑兼容性，我希望你能把公司所有的业务的网络请求都迁移到你这个 HttpUtils 上来，这样以后你只用维护这一个库了，也方便。李雷一听，悲从中来——他是该公司的第 99 代员工，对远古时期的业务一无所知。而该公司第1代员工封装的网络请求库，是基于 XMLHttpRequest 的，差不多长这样：
```
function Ajax(type, url, data, success, failed){
    // 创建ajax对象
    var xhr = null;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    } else {
        xhr = new ActiveXObject('Microsoft.XMLHTTP')
    }
 
   ...(此处省略一系列的业务逻辑细节)
   
   var type = type.toUpperCase();
    
    // 识别请求类型
    if(type == 'GET'){
        if(data){
          xhr.open('GET', url + '?' + data, true); //如果有数据就拼接
        } 
        // 发送get请求
        xhr.send();
 
    } else if(type == 'POST'){
        xhr.open('POST', url, true);
        // 如果需要像 html 表单那样 POST 数据，使用 setRequestHeader() 来添加 http 头。
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        // 发送post请求
        xhr.send(data);
    }
 
    // 处理返回数据
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status == 200){
                success(xhr.responseText);
            } else {
                if(failed){
                    failed(xhr.status);
                }
            }
        }
    }
}
```
实现逻辑我们简单描述了一下，这个不是重点，重点是它是这样调用的：
```
// 发送get请求
Ajax('get', url地址, post入参, function(data){
    // 成功的回调逻辑
}, function(error){
    // 失败的回调逻辑
})
```
李雷佛了 —— 不仅接口名不同，入参方式也不一样，这手动改要改到何年何日呢？

- 还好李雷学过设计模式，他立刻联想到了专门为我们抹平差异的适配器模式。要把老代码迁移到新接口，不一定要挨个儿去修改每一次的接口调用——正如我们想用 iPhoneX + 旧耳机听歌，不必挨个儿去改造耳机一样，我们只需要在引入接口时进行一次适配，便可轻松地 cover 掉业务里可能会有的多次调用（具体的解析在注释里）：
```
// Ajax适配器函数，入参与旧接口保持一致
async function AjaxAdapter(type, url, data, success, failed) {
    const type = type.toUpperCase()
    let result
    try {
         // 实际的请求全部由新接口发起
         if(type === 'GET') {
            result = await HttpUtils.get(url) || {}
        } else if(type === 'POST') {
            result = await HttpUtils.post(url, data) || {}
        }
        // 假设请求成功对应的状态码是1
        result.statusCode === 1 && success ? success(result) : failed(result.statusCode)
    } catch(error) {
        // 捕捉网络错误
        if(failed){
            failed(error.statusCode);
        }
    }
}

// 用适配器适配旧的Ajax方法
async function Ajax(type, url, data, success, failed) {
    await AjaxAdapter(type, url, data, success, failed)
}
```
- 如此一来，我们只需要编写一个适配器函数AjaxAdapter，并用适配器去承接旧接口的参数，就可以实现新旧接口的无缝衔接了~

#### 生产实践：axios中的适配器
- 数月之后，李雷的老板发现了网络请求神库axios，于是团队的方案又整个迁移到了axios——对于心中有适配器的李雷来说，这现在已经根本不是个事儿。不过本小节我们要聊的可不再是“如何使现有接口兼容axios”了。此处引出axios，一是因为大家对它足够熟悉（不熟悉的同学，点这里 (opens new window)可以快速熟悉一下~），二是因为axios本身就用到了我们的适配器模式，它的兼容方案值得我们学习和借鉴。

- 在使用axios时，作为用户我们只需要掌握以下面三个最常用的接口为代表的一套api：
```
// Make a request for a user with a given ID
axios.get('/user?ID=12345')
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .then(function () {
    // always executed
  })   
     
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });   

axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
})
```
- 便可轻松地发起各种姿势的网络请求，而不用去关心底层的实现细节。
- 除了简明优雅的api之外，axios 强大的地方还在于，它不仅仅是一个局限于浏览器端的库。在Node环境下，我们尝试调用上面的 api，会发现它照样好使 —— axios 完美地抹平了两种环境下api的调用差异，靠的正是对适配器模式的灵活运用。

- 在 axios 的核心逻辑 (opens new window)中，我们可以注意到实际上派发请求的是 dispatchRequest 方法 (opens new window)。该方法内部其实主要做了两件事：
  - 数据转换，转换请求体/响应体，可以理解为数据层面的适配；
  - 调用适配器。

调用适配器的逻辑如下：
```
// 若用户未手动配置适配器，则使用默认的适配器
var adapter = config.adapter || defaults.adapter;
  
  // dispatchRequest方法的末尾调用的是适配器方法
  return adapter(config).then(function onAdapterResolution(response) {
    // 请求成功的回调
    throwIfCancellationRequested(config);

    // 转换响应体
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    // 请求失败的回调
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // 转换响应体
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
```
- 大家注意注释的第一行，“若用户未手动配置适配器，则使用默认的适配器”。手动配置适配器允许我们自定义处理请求，主要目的是为了使测试更轻松。

- 实际开发中，我们使用默认适配器的频率更高。默认适配器在axios/lib/default.js (opens new window)里是通过getDefaultAdapter方法来获取的：
```
function getDefaultAdapter() {
  var adapter;
  // 判断当前是否是node环境
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // 如果是node环境，调用node专属的http适配器
    adapter = require('./adapters/http');
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // 如果是浏览器环境，调用基于xhr的适配器
    adapter = require('./adapters/xhr');
  }
  return adapter;
}
```
我们再来看看 Node 的 http 适配器和 xhr 适配器大概长啥样：

- http 适配器：
```
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    // 具体逻辑
  }
}
```

- xhr 适配器：
```
module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    // 具体逻辑
  }
}
```
- 具体逻辑啥样，咱们目前先不关心，有兴趣的同学，可以狠狠地点这里 (opens new window)阅读源码。咱们现在就注意两个事儿：

- 两个适配器的入参都是 config；
- 两个适配器的出参都是一个 Promise。

- Tips：要是仔细读了源码，会发现两个适配器中的 Promise 的内部结构也是如出一辙。

- 这么一来，通过 axios 发起跨平台的网络请求，不仅调用的接口名是同一个，连入参、出参的格式都只需要掌握同一套。这导致它的学习成本非常低，开发者看了文档就能上手；同时因为足够简单，在使用的过程中也不容易出错，带来了极佳的用户体验，axios 也因此越来越流行。

- 这正是一个好的适配器的自我修养——把变化留给自己，把统一留给用户。在此处，所有关于 http 模块、关于 xhr 的实现细节，全部被 Adapter 封装进了自己复杂的底层逻辑里，暴露给用户的都是十分简单的统一的东西——统一的接口，统一的入参，统一的出参，统一的规则。用起来就是一个字 —— 爽！

#### 结构型-代理模式
- 代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。

- 代理模式非常好理解，因为你可能天天都在用，只是没有刻意挖掘过它背后的玄机——比如大家耳熟能详的科学上网，就是代理模式的典型案例。

#### ES6中的Proxy
- 在 ES6 中，提供了专门以代理角色出现的代理器 —— Proxy。它的基本用法如下：
```
const proxy = new Proxy(obj, handler)
```
- 第一个参数是我们的目标对象，也就是上文中的“未知妹子”。handler 也是一个对象，用来定义代理的行为，相当于上文中的“婚介所”。当我们通过 proxy 去访问目标对象的时候，handler会对我们的行为作一层拦截，我们的每次访问都需要经过 handler 这个第三方。

#### “婚介所”的实现
- 未知妹子的个人信息，刚问了下我们已经注册了 VIP 的同事哥，大致如下：
```
// 未知妹子
const girl = {
  // 姓名
  name: '小美',
  // 自我介绍
  aboutMe: '...'（大家自行脑补吧）
  // 年龄
  age: 24,
  // 职业
  career: 'teacher',
  // 假头像
  fakeAvatar: 'xxxx'(新垣结衣的图片地址）
  // 真实头像
  avatar: 'xxxx'(自己的照片地址),
  // 手机号
  phone: 123456,
}
```
- 婚介所收到了小美的信息，开始营业。大家想，这个姓名、自我介绍、假头像，这些信息大差不差，曝光一下没问题。但是人家妹子的年龄、职业、真实头像、手机号码，是不是属于非常私密的信息了？要想 get 这些信息，平台要考验一下你的诚意了 —— 首先，你是不是已经通过了实名审核？如果通过实名审核，那么你可以查看一些相对私密的信息（年龄、职业）。然后，你是不是 VIP ？只有 VIP 可以查看真实照片和联系方式。满足了这两个判定条件，你才可以顺利访问到别人的全部私人信息，不然，就劝退你提醒你去完成认证和VIP购买再来。
```
// 普通私密信息
const baseInfo = ['age', 'career']
// 最私密信息
const privateInfo = ['avatar', 'phone']

// 用户（同事A）对象实例
const user = {
  ...(一些必要的个人信息)
  isValidated: true,
  isVIP: false,
}

// 婚介所登场了
const lovers = new Proxy(girl, {
  get: function(girl, key) {
      if(baseInfo.indexOf(key)!==-1 && !user.isValidated) {
          alert('您还没有完成验证哦')
          return
      }
      
      //...(此处省略其它有的没的各种校验逻辑)
    
      // 此处我们认为只有验证过的用户才可以购买VIP
      if(user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
          alert('只有VIP才可以查看该信息哦')
          return
      }
  }
})
```
- 以上主要是 getter 层面的拦截。假设我们还允许会员间互送礼物，每个会员可以告知婚介所自己愿意接受的礼物的价格下限，我们还可以作 setter 层面的拦截。：
```
// 规定礼物的数据结构由type和value组成
const present = {
    type: '巧克力',
    value: 60,
}

// 为用户增开presents字段存储礼物
const girl = {
  // 姓名
  name: '小美',
  // 自我介绍
  aboutMe: '...'（大家自行脑补吧）
  // 年龄
  age: 24,
  // 职业
  career: 'teacher',
  // 假头像
  fakeAvatar: 'xxxx'(新垣结衣的图片地址）
  // 真实头像
  avatar: 'xxxx'(自己的照片地址),
  // 手机号
  phone: 123456,
  // 礼物数组
  presents: [],
  // 拒收50块以下的礼物
  bottomValue: 50,
  // 记录最近一次收到的礼物
  lastPresent: present,
}

// 婚介所推出了小礼物功能
const lovers = new Proxy(girl, {
  get: function(girl, key) {
    if(baseInfo.indexOf(key)!==-1 && !user.isValidated) {
        alert('您还没有完成验证哦')
        return
    }
    
    //...(此处省略其它有的没的各种校验逻辑)
  
    // 此处我们认为只有验证过的用户才可以购买VIP
    if(user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
        alert('只有VIP才可以查看该信息哦')
        return
    }
  }
  
  set: function(girl, key, val) {
    // 最近一次送来的礼物会尝试赋值给lastPresent字段
    if(key === 'lastPresent') {
      if(val.value < girl.bottomValue) {
          alert('sorry，您的礼物被拒收了')
          return
      }
    
      // 如果没有拒收，则赋值成功，同时并入presents数组
      girl[lastPresent] = val
      girl[presents] = [...presents, val]
    }
  }
 
})
```

#### 事件代理
- 事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：

- 事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件代理</title>
</head>
<body>
  <div id="father">
    <a href="#">链接1号</a>
    <a href="#">链接2号</a>
    <a href="#">链接3号</a>
    <a href="#">链接4号</a>
    <a href="#">链接5号</a>
    <a href="#">链接6号</a>
  </div>
</body>
</html>
```
- 我们现在的需求是，希望鼠标点击每个 a 标签，都可以弹出“我是xxx”这样的提示。比如点击第一个 a 标签，弹出“我是链接1号”这样的提示。这意味着我们至少要安装 6 个监听函数给 6 个不同的的元素(一般我们会用循环，代码如下所示），如果我们的 a 标签进一步增多，那么性能的开销会更大。
```
// 假如不用代理模式，我们将循环安装监听函数
const aNodes = document.getElementById('father').getElementsByTagName('a')
  
const aLength = aNodes.length

for(let i=0;i<aLength;i++) {
    aNodes[i].addEventListener('click', function(e) {
        e.preventDefault()
        alert(`我是${aNodes[i].innerText}`)                  
    })
}
```
- 考虑到事件本身具有“冒泡”的特性，当我们点击 a 元素时，点击事件会“冒泡”到父元素 div 上，从而被监听到。如此一来，点击事件的监听函数只需要在 div 元素上被绑定一次即可，而不需要在子元素上被绑定 N 次——这种做法就是事件代理，它可以很大程度上提高我们代码的性能。

事件代理的实现
- 用代理模式实现多个子元素的事件监听，代码会简单很多：
```
// 获取父元素
const father = document.getElementById('father')

// 给父元素安装一次监听函数
father.addEventListener('click', function(e) {
    // 识别是否是目标子元素
    if(e.target.tagName === 'A') {
        // 以下是监听函数的函数体
        e.preventDefault()
        alert(`我是${e.target.innerText}`)
    }
} )
```
- 在这种做法下，我们的点击操作并不会直接触及目标子元素，而是由父元素对事件进行处理和分发、间接地将其作用于子元素，因此这种操作从模式上划分属于代理模式。

#### 虚拟代理
- 简单地给大家描述一下懒加载是个什么东西：它是针对图片加载时机的优化：在一些图片量比较大的网站，比如电商网站首页，或者团购网站、小游戏首页等。如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象。

- 此时我们会采取“先占位、后加载”的方式来展示图片 —— 在元素露出之前，我们给它一个 div 作占位，当它滚动到可视区域内时，再即时地去加载真实的图片资源，这样做既减轻了性能压力、又保住了用户体验。

- 除了图片懒加载，还有一种操作叫图片预加载。预加载主要是为了避免网络不好、或者图片太大时，页面长时间给用户留白的尴尬。常见的操作是先让这个 img 标签展示一个占位图，然后创建一个 Image 实例，让这个 Image 实例的 src 指向真实的目标图片地址、观察该 Image 实例的加载情况 —— 当其对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将 DOM 上的 img 元素的 src 指向真实的目标图片地址。此时我们直接去取了目标图片的缓存，所以展示速度会非常快，从占位图到目标图片的时间差会非常小、小到用户注意不到，这样体验就会非常好了。

上面的思路，我们可以不假思索地实现如下
```
class PreLoadImage {
    // 占位图的url地址
    static LOADING_URL = 'xxxxxx'
    
    constructor(imgNode) {
        // 获取该实例对应的DOM节点
        this.imgNode = imgNode
    }
    
    // 该方法用于设置真实的图片地址
    setSrc(targetUrl) {
        // img节点初始化时展示的是一个占位图
        this.imgNode.src = PreLoadImage.LOADING_URL
        // 创建一个帮我们加载图片的Image实例
        const image = new Image()
        // 监听目标图片加载的情况，完成时再将DOM上的img节点的src属性设置为目标图片的url
        image.onload = () => {
            this.imgNode.src = targetUrl
        }
        // 设置src属性，Image实例开始加载图片
        image.src = srcUrl
    }
}
```
- 这个 PreLoadImage 乍一看没问题，但其实违反了我们设计原则中的单一职责原则。PreLoadImage 不仅要负责图片的加载，还要负责 DOM 层面的操作（img 节点的初始化和后续的改变）。这样一来，就出现了两个可能导致这个类发生变化的原因。

- 好的做法是将两个逻辑分离，让 PreLoadImage 专心去做 DOM 层面的事情（真实 DOM 节点的获取、img 节点的链接设置），再找一个对象来专门来帮我们搞加载——这两个对象之间缺个媒婆，这媒婆非代理器不可：
```
class PreLoadImage {
    constructor(imgNode) {
        // 获取真实的DOM节点
        this.imgNode = imgNode
    }
     
    // 操作img节点的src属性
    setSrc(imgUrl) {
        this.imgNode.src = imgUrl
    }
}

class ProxyImage {
    // 占位图的url地址
    static LOADING_URL = 'xxxxxx'

    constructor(targetImage) {
        // 目标Image，即PreLoadImage实例
        this.targetImage = targetImage
    }
    
    // 该方法主要操作虚拟Image，完成加载
    setSrc(targetUrl) {
       // 真实img节点初始化时展示的是一个占位图
        this.targetImage.setSrc(ProxyImage.LOADING_URL)
        // 创建一个帮我们加载图片的虚拟Image实例
        const virtualImage = new Image()
        // 监听目标图片加载的情况，完成时再将DOM上的真实img节点的src属性设置为目标图片的url
        virtualImage.onload = () => {
            this.targetImage.setSrc(targetUrl)
        }
        // 设置src属性，虚拟Image实例开始加载图片
        virtualImage.src = targetUrl
    }
}
```
- ProxyImage 帮我们调度了预加载相关的工作，我们可以通过 ProxyImage 这个代理，实现对真实 img 节点的间接访问，并得到我们想要的效果。

- 在这个实例中，virtualImage 这个对象是一个“幕后英雄”，它始终存在于 JavaScript 世界中、代替真实 DOM 发起了图片加载请求、完成了图片加载工作，却从未在渲染层面抛头露面。因此这种模式被称为“虚拟代理”模式。

#### 缓存代理
- 缓存代理比较好理解，它应用于一些计算量较大的场景里。在这种场景下，我们需要“用空间换时间”——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果。这种场景下，就需要一个代理来帮我们在进行计算的同时，进行计算结果的缓存了。

- 一个比较典型的例子，是对传入的参数进行求和：
```
// addAll方法会对你传入的所有参数做求和操作
const addAll = function() {
    console.log('进行了一次新计算')
    let result = 0
    const len = arguments.length
    for(let i = 0; i < len; i++) {
        result += arguments[i]
    }
    return result
}

// 为求和方法创建代理
const proxyAddAll = (function(){
    // 求和结果的缓存池
    const resultCache = {}
    return function() {
        // 将入参转化为一个唯一的入参字符串
        const args = Array.prototype.join.call(arguments, ',')
        
        // 检查本次入参是否有对应的计算结果
        if(args in resultCache) {
            // 如果有，则返回缓存池里现成的结果
            return resultCache[args]
        }
        return resultCache[args] = addAll(...arguments)
    }
})()
```
- 我们把这个方法丢进控制台，尝试同一套入参两次，结果喜人：

- 我们发现 proxyAddAll 针对重复的入参只会计算一次，这将大大节省计算过程中的时间开销。现在我们有 6 个入参，可能还看不出来，当我们针对大量入参、做反复计算时，缓存代理的优势将得到更充分的凸显。

#### 行为型-策略模式
- 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

例子
- 定义：根据不同参数可以命中不同的策略

优点：
- 能减少大量的if语句
- 复用性好
- 优化使用：
  - 封装代码，暴露方法
```
export default {
    xxx
}

import xxx from 'x.js'
```

```
const strategy = {
    'A': (salary) => {
        return salary * 2;
    },

    'B': (salary) => {
        return salary * 3;
    },

    'C': (salary) => {
        return salary * 4;
    }
}

const calculateBonus = (level, salary) => {
    return strategy[level](salary)
}

const A = calculateBonus('A', 10000);
console.log(A); // 20000

// 暴露方法
export default {
    calculateBonus
}
```

#### 先来看一个真实场景
- 有一天，产品经理韩梅梅找到李雷，给李雷提了这么个需求：

- 马上大促要来了，我们本次大促要做差异化询价。啥是差异化询价？就是说同一个商品，我通过在后台给它设置不同的价格类型，可以让它展示不同的价格。具体的逻辑如下：
  - 当价格类型为“预售价”时，满 100 - 20，不满 100 打 9 折
  - 当价格类型为“大促价”时，满 100 - 30，不满 100 打 8 折
  - 当价格类型为“返场价”时，满 200 - 50，不叠加
  - 当价格类型为“尝鲜价”时，直接打 5 折

- 李雷扫了一眼 prd，立刻来了主意。他首先将四种价格做了标签化：
```
预售价 - pre
大促价 - onSale
返场价 - back
尝鲜价 - fresh
```
- 接下来李雷仔细研读了 prd 的内容，作为资深 if-else 侠，他三下五除二就写出一套功能完备的代码：
```
// 询价方法，接受价格标签和原价为入参
function askPrice(tag, originPrice) {

  // 处理预热价
  if(tag === 'pre') {
    if(originPrice >= 100) {
      return originPrice - 20
    } 
    return originPrice * 0.9
  }
  
  // 处理大促价
  if(tag === 'onSale') {
    if(originPrice >= 100) {
      return originPrice - 30
    } 
    return originPrice * 0.8
  }
  
  // 处理返场价
  if(tag === 'back') {
    if(originPrice >= 200) {
      return originPrice - 50
    }
    return originPrice
  }
  
  // 处理尝鲜价
  if(tag === 'fresh') {
     return originPrice * 0.5
  }
}
```

#### if-else侠，人人喊打
- 随便跑一下，上述代码运行起来确实没啥毛病。但也只是“运行起来”没毛病而已。作为人人喊打的 if-else 侠，李雷必须为他的行为付出代价。我们一起来看看这么写代码会带来什么后果：

- 首先，它违背了“单一功能”原则。一个 function 里面，它竟然处理了四坨逻辑——这个函数的逻辑太胖了！这样会带来什么样的糟糕后果，笔者在前面的小节中已经 BB 过很多次了：比如说万一其中一行代码出了 Bug，那么整个询价逻辑都会崩坏；与此同时出了 Bug 你很难定位到底是哪个代码块坏了事；再比如说单个能力很难被抽离复用等等等等。相信跟着我一路学下来的各位，也已经在重重实战中对胖逻辑的恶劣影响有了切身的体会。总之，见到胖逻辑，我们的第一反应，就是一个字——拆！
- 不仅如此，它还违背了“开放封闭”原则。假如有一天韩梅梅再次找到李雷，要他加一个满 100 - 50 的“新人价”怎么办？他只能继续 if-else：
```
function askPrice(tag, originPrice) {

  // 处理预热价
  if(tag === 'pre') {
    if(originPrice >= 100) {
      return originPrice - 20
    } 
    return originPrice * 0.9
  }
  // 处理大促价
  if(tag === 'onSale') {
    if(originPrice >= 100) {
      return originPrice - 30
    } 
    return originPrice * 0.8
  }

  // 处理返场价
  if(tag === 'back') {
    if(originPrice >= 200) {
      return originPrice - 50
    }
    return originPrice
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
      return originPrice * 0.5
  }
  
  // 处理新人价
  if(tag === 'newUser') {
    if(originPrice >= 100) {
      return originPrice - 50
    }
    return originPrice
  }
}
```
- 没错，李雷灰溜溜地跑去改了 askPrice 函数！随后他恬不知耻地徐徐转头，对背后的测试同学说：哥，我改了询价函数，麻烦你帮我把整个询价逻辑回归一下。测试同学莞尔一笑， 心中早已有无数头羊驼在狂奔。他强忍着周末加班的悲痛，做完了这漫长而不必要的回归测试，随后默默点击了同事系统里的举报按钮对李雷说：哥，求你学学设计模式吧！！

#### 重构询价逻辑
- 现在我们基于我们已经学过的设计模式思想，一点一点改造掉这个臃肿的 askPrice。

1. 单一功能改造
- 首先，我们赶紧把四种询价逻辑提出来，让它们各自为政：
```
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

function askPrice(tag, originPrice) {
  // 处理预热价
  if(tag === 'pre') {
    return prePrice(originPrice)
  }
  // 处理大促价
  if(tag === 'onSale') {
    return onSalePrice(originPrice)
  }

  // 处理返场价
  if(tag === 'back') {
    return backPrice(originPrice)
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
     return freshPrice(originPrice)
  }
}
```
- OK，我们现在至少做到了一个函数只做一件事。现在每个函数都有了自己明确的、单一的分工：
```
prePrice - 处理预热价
onSalePrice - 处理大促价
backPrice - 处理返场价
freshPrice - 处理尝鲜价
askPrice - 分发询价逻辑
```
- 如此一来，我们在遇到 Bug 时，就可以做到“头痛医头，脚痛医脚”，而不必在庞大的逻辑海洋里费力去定位到底是哪块不对。

- 同时，如果我在另一个函数里也想使用某个询价能力，比如说我想询预热价，那我直接把 prePrice 这个函数拿去调用就是了，而不必在 askPrice 肥胖的身躯里苦苦寻觅、然后掏出这块逻辑、最后再复制粘贴到另一个函数去——更何况万一哪天 askPrice 里的预热价逻辑改了，你还得再复制粘贴一次，扎心啊老铁！

- 到这里，在单一功能原则的指引下，我们已经解决了一半的问题。

- 我们现在来捋一下，其实这个询价逻辑整体上来看只有两个关键动作：
```
询价逻辑的分发 ——> 询价逻辑的执行
```
- 在改造的第一步，我们已经把“询价逻辑的执行”给摘了出去，并且实现了不同询价逻辑之间的解耦。接下来，我们就要拿“分发”这个动作开刀。

2. 开放封闭改造
- 剩下一半的问题是啥呢？就是咱们上面说的那个新人价的问题——这会儿我要想给 askPrice 增加新人询价逻辑，我该咋整？我只能这么来：
```
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

// 处理新人价
function newUserPrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 50
  }
  return originPrice
}

function askPrice(tag, originPrice) {
  // 处理预热价
  if(tag === 'pre') {
    return prePrice(originPrice)
  }
  // 处理大促价
  if(tag === 'onSale') {
    return onSalePrice(originPrice)
  }

  // 处理返场价
  if(tag === 'back') {
    return backPrice(originPrice)
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
     return freshPrice(originPrice)
  }
  
  // 处理新人价
  if(tag === 'newUser') {
     return newUserPrice(originPrice)
  }
}
```
- 在外层，我们编写一个 newUser 函数用于处理新人价逻辑；在 askPrice 里面，我们新增了一个 if-else 判断。可以看出，这样其实还是在修改 askPrice 的函数体，没有实现“对扩展开放，对修改封闭”的效果。

- 那么我们应该怎么做？我们仔细想想，楼上用了这么多 if-else，我们的目的到底是什么？是不是就是为了把 询价标签-询价函数 这个映射关系给明确下来？那么在 JS 中，有没有什么既能够既帮我们明确映射关系，同时不破坏代码的灵活性的方法呢？答案就是对象映射！

咱们完全可以把询价算法全都收敛到一个对象里去嘛：
```
// 定义一个询价处理器对象
const priceProcessor = {
  pre(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 20;
    }
    return originPrice * 0.9;
  },
  onSale(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 30;
    }
    return originPrice * 0.8;
  },
  back(originPrice) {
    if (originPrice >= 200) {
      return originPrice - 50;
    }
    return originPrice;
  },
  fresh(originPrice) {
    return originPrice * 0.5;
  },
};
```
当我们想使用其中某个询价算法的时候：通过标签名去定位就好了：
```
// 询价函数
function askPrice(tag, originPrice) {
  return priceProcessor[tag](originPrice)
}
```
- 如此一来，askPrice 函数里的 if-else 大军彻底被咱们消灭了。这时候如果你需要一个新人价，只需要给 priceProcessor 新增一个映射关系：
```
priceProcessor.newUser = function (originPrice) {
  if (originPrice >= 100) {
    return originPrice - 50;
  }
  return originPrice;
}
```
- 这样一来，询价逻辑的分发也变成了一个清清爽爽的过程。当李雷以这种方式新增一个新人价的询价逻辑的时候，就可以底气十足地对测试同学说：老哥，我改了询价逻辑，但是改动范围仅仅涉及到新人价，是一个单纯的功能增加。所以你只测这个新功能点就 OK，老逻辑不用管！

- 从此，李雷就从人人喊打的 if-else 侠，摇身一变成为了测试之友、中国好开发。业务代码里的询价逻辑，也因为李雷坚守设计原则100年不动摇，而变得易读、易维护。

#### 总结
- 说起来你可能不相信，咱们上面的整个重构的过程，就是对策略模式的应用。

- 现在大家来品品策略模式的定义：
  - 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

- 回头看看，咱们忙活到现在，是不是就干了这事儿？

- 但你要直接读这句话，可能确实会懵圈——啥是算法？如何封装？可替换又是咋做到的？

- 如今你你已经自己动手实现了算法提取、算法封装、分发优化的整个一条龙的操作流，相信面对这条定义，你可以会心一笑——算法，就是我们这个场景中的询价逻辑，它也可以是你任何一个功能函数的逻辑；“封装”就是把某一功能点对应的逻辑给提出来；“可替换”建立在封装的基础上，只是说这个“替换”的判断过程，咱们不能直接怼 if-else，而要考虑更优的映射方案。

#### 行为型-状态模式
#### 一台咖啡机的诞生
- 作为一个具备强大抽象思维能力的程序员，李雷没有辜负自己这么多年来学过的现代前端框架。他敏锐地感知到，韩梅梅所说的这些不同的”选择“间的切换，本质就是状态的切换。在这个能做四种咖啡的咖啡机体内，蕴含着四种状态：
```
- 美式咖啡态（american)：只吐黑咖啡
- 普通拿铁态(latte)：黑咖啡加点奶
- 香草拿铁态（vanillaLatte）：黑咖啡加点奶再加香草糖浆
- 摩卡咖啡态(mocha)：黑咖啡加点奶再加点巧克力
```
- 嘿嘿，这么一梳理，李雷的思路一下子清晰了起来。作为死性不改的 if-else 侠，他再次三下五除二写出了一套功能完备的代码：
```
class CoffeeMaker {
  constructor() {
    /**
     *这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
    **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  // 关注咖啡机状态切换函数
  changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      console.log('我只吐黑咖啡');
    } else if(state === 'latte') {
      console.log(`给黑咖啡加点奶`);
    } else if(state === 'vanillaLatte') {
      console.log('黑咖啡加点奶再加香草糖浆');
    } else if(state === 'mocha') {
      console.log('黑咖啡加点奶再加点巧克力');
    }
  }
}
```
测试一下，完美无缺：
```
const mk = new CoffeeMaker();
mk.changeState('latte'); // 输出 '给黑咖啡加点奶'
```
- 鉴于 if-else 使不得，李雷赶紧翻出了他在策略模式中学到的“单一职责”和“开放封闭”原则，比猫画虎地改造起了自己的咖啡机：

#### 改造咖啡机的状态切换机制
1. 职责分离
- 首先，映入李雷眼帘最大的问题，就是咖啡制作过程不可复用：
```
changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      console.log('我只吐黑咖啡');
    } else if(state === 'latte') {
      console.log(`给黑咖啡加点奶`);
    } else if(state === 'vanillaLatte') {
      console.log('黑咖啡加点奶再加香草糖浆');
    } else if(state === 'mocha') {
      console.log('黑咖啡加点奶再加点巧克力');
    }
}
```
- 李雷发现，这个 changeState 函数，它好好管好自己的事（状态切换）不行吗？怎么连做咖啡的过程也写在这里面？这不合理。
```
class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      this.americanProcess();
    } else if(state === 'latte') {
      this.latteProcress();
    } else if(state === 'vanillaLatte') {
      this.vanillaLatteProcress();
    } else if(state === 'mocha') {
      this.mochaProcress();
    }
  }
  
  americanProcess() {
    console.log('我只吐黑咖啡');    
  }
  
  latteProcress() {
    this.americanProcess();
    console.log('加点奶');  
  }
  
  vanillaLatteProcress() {
    this.latteProcress();
    console.log('再加香草糖浆');
  }
  
  mochaProcress() {
    this.latteProcress();
    console.log('再加巧克力');
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```
输出结果符合预期：
```
我只吐黑咖啡
加点奶
```

#### 开放封闭
- 复用的问题解决了，if-else 却仍然活得好好的。

- 现在咱们假如要增加”气泡美式“这个咖啡品种，就不得不去修改 changeState 的函数逻辑，这违反了开放封闭的原则。

- 同时，一个函数里收敛这么多判断，也着实不够体面。咱们现在要像策略模式一样，想办法把咖啡机状态和咖啡制作工序之间的映射关系（也就是咱们上节谈到的分发过程）用一个更优雅地方式做掉。如果你策略模式掌握得足够好，你会第一时间反映出对象映射的方案：
```
const stateToProcessor = {
  american() {
    console.log('我只吐黑咖啡');    
  },
  latte() {
    this.american();
    console.log('加点奶');  
  },
  vanillaLatte() {
    this.latte();
    console.log('再加香草糖浆');
  },
  mocha() {
    this.latte();
    console.log('再加巧克力');
  }
}

class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  
  // 关注咖啡机状态切换函数
  changeState(state) {
    // 记录当前状态
    this.state = state;
    // 若状态不存在，则返回
    if(!stateToProcessor[state]) {
      return ;
    }
    stateToProcessor[state]();
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```
输出结果符合预期：
```
我只吐黑咖啡
加点奶
```
- 当我们这么做时，其实已经实现了一个 js 版本的状态模式。

- 但这里有一点大家需要引起注意：这种方法仅仅是看上去完美无缺，其中却暗含一个非常重要的隐患——stateToProcessor 里的工序函数，感知不到咖啡机的内部状况。

#### 进一步改造
- 按照我们这一通描述，当务之急是要把咖啡机和它的状态处理函数建立关联。

- 如果你读过一些早期的设计模式教学资料，有一种思路是将每一个状态所对应的的一些行为抽象成类，然后通过传递 this 的方式来关联状态和状态主体。

- 这种思路也可以，不过它一般还需要你实现抽象工厂，比较麻烦。实际业务中这种做法极为少见。我这里要给大家介绍的是一种更方便也更常用的解决方案——非常简单，把状态-行为映射对象作为主体类对应实例的一个属性添加进去就行了：
```
class CoffeeMaker {
  constructor() {
    /**
     *这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
    **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
    // 初始化牛奶的存储量
    this.leftMilk = '500ml';
  }
  stateToProcessor = {
    that: this,
    american() {
      // 尝试在行为函数里拿到咖啡机实例的信息并输出
      console.log('咖啡机现在的牛奶存储量是:', this.that.leftMilk)
      console.log('我只吐黑咖啡');
    },
    latte() {
      this.american()
      console.log('加点奶');
    },
    vanillaLatte() {
      this.latte();
      console.log('再加香草糖浆');
    },
    mocha() {
      this.latte();
      console.log('再加巧克力');
    }
  }

  // 关注咖啡机状态切换函数
  changeState(state) {
    this.state = state;
    if (!this.stateToProcessor[state]) {
      return;
    }
    this.stateToProcessor[state]();
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```
输出结果为：
```
咖啡机现在的牛奶存储量是: 500ml
我只吐黑咖啡
加点奶
```
- 如此一来，我们就可以在 stateToProcessor 轻松拿到咖啡机的实例对象，进而感知咖啡机这个主体了。

#### 状态模式复盘
- 和策略模式一样，咱们仍然是敲完代码之后，一起来复盘一下状态模式的定义：
  - 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

- 这个定义比较粗糙，可能你读完仍然 get 不到它想让你干啥。这时候，我们就应该把目光转移到它解决的问题上来：
  - 状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

- 仔细回忆一下我们这节做的事情，也确实就是这么回事儿。
  - 唯一的区别在于，定义里强调了”类“的概念。但我们的示例中，包括大家今后的实践中，一个对象的状态如果复杂到了你不得不给它的每 N 种状态划分为一类、一口气划分很多类这种程度，我更倾向于你去反思一个这个对象是不是做太多事情了。事实上，在大多数场景下，我们的行为划分，都是可以像本节一样，控制在”函数“这个粒度的。

#### 行为型-观察者模式
- 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns

- 观察者模式，是所有 JavaScript 设计模式中使用频率最高，面试频率也最高的设计模式，所以说它十分重要——如果我是面试官，考虑到面试时间有限、设计模式这块不能多问，我可能在考查你设计模式的时候只会问观察者模式这一个模式。该模式的权重极高

- 重点不一定是难点。观察者模式十分重要，但它并不抽象，理解难度不大。这种模式不仅在业务开发中遍地开花，在日常生活中也是非常常见的。为了帮助大家形成初步的理解，在进入代码世界之前，我们照例来看一段日常：

#### 生活中的观察者模式
- 周一刚上班，前端开发李雷就被产品经理韩梅梅拉进了一个钉钉群——“员工管理系统需求第99次变更群”。这个群里不仅有李雷，还有后端开发 A，测试同学 B。三位技术同学看到这简单直白的群名便立刻做好了接受变更的准备、打算撸起袖子开始干了。此时韩梅梅却说：“别急，这个需求有问题，我需要和业务方再确认一下，大家先各忙各的吧”。这种情况下三位技术同学不必立刻投入工作，但他们都已经做好了本周需要做一个新需求的准备，时刻等待着产品经理的号召。

- 一天过去了，两天过去了。周三下午，韩梅梅终于和业务方确认了所有的需求细节，于是在“员工管理系统需求第99次变更群”里大吼一声：“需求文档来了！”，随后甩出了"需求文档.zip"文件，同时@所有人。三位技术同学听到熟悉的“有人@我”提示音，立刻点开群进行群消息和群文件查收，随后根据群消息和群文件提供的需求信息，投入到了各自的开发里。上述这个过程，就是一个典型的观察者模式。

重点角色对号入座
- 观察者模式有一个“别名”，叫发布 - 订阅模式（之所以别名加了引号，是因为两者之间存在着细微的差异，下个小节里我们会讲到这点）。这个别名非常形象地诠释了观察者模式里两个核心的角色要素——“发布者”与“订阅者”。

- 在上述的过程中，需求文档（目标对象）的发布者只有一个——产品经理韩梅梅。而需求信息的接受者却有多个——前端、后端、测试同学，这些同学的共性就是他们需要根据需求信息开展自己后续的工作、因此都非常关心这个需求信息，于是不得不时刻关注着这个群的群消息提醒，他们是实打实的订阅者，即观察者对象。

- 现在我们再回过头来看一遍开头我们提到的略显抽象的定义：
  - 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

- 在我们上文这个钉钉群里，一个需求信息对象对应了多个观察者（技术同学），当需求信息对象的状态发生变化（从无到有）时，产品经理通知了群里的所有同学，以便这些同学接收信息进而开展工作：角色划分 --> 状态变化 --> 发布者通知到订阅者，这就是观察者模式的“套路”。

#### 在实践中理解定义
- 结合我们上面的分析，现在大家知道，在观察者模式里，至少应该有两个关键角色是一定要出现的——发布者和订阅者。用面向对象的方式表达的话，那就是要有两个类。

- 首先我们来看这个代表发布者的类，我们给它起名叫Publisher。这个类应该具备哪些“基本技能”呢？大家回忆一下上文中的韩梅梅，韩梅梅的基本操作是什么？首先是拉群（增加订阅者），然后是@所有人（通知订阅者），这俩是最明显的了。此外作为群主&产品经理，韩梅梅还具有踢走项目组成员（移除订阅者）的能力。OK，产品经理发布者类的三个基本能力齐了，下面我们开始写代码：
```
// 定义发布者类
class Publisher {
  constructor() {
    this.observers = []
    console.log('Publisher created')
  }
  // 增加订阅者
  add(observer) {
    console.log('Publisher.add invoked')
    this.observers.push(observer)
  }
  // 移除订阅者
  remove(observer) {
    console.log('Publisher.remove invoked')
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1)
      }
    })
  }
  // 通知所有订阅者
  notify() {
    console.log('Publisher.notify invoked')
    this.observers.forEach((observer) => {
      observer.update(this)
    })
  }
}
```
- ok，搞定了发布者，我们一起来想想订阅者能干啥——其实订阅者的能力非常简单，作为被动的一方，它的行为只有两个——被通知、去执行（本质上是接受发布者的调用，这步我们在Publisher中已经做掉了）。既然我们在Publisher中做的是方法调用，那么我们在订阅者类里要做的就是方法的定义：
```
// 定义订阅者类
class Observer {
    constructor() {
        console.log('Observer created')
    }
    update() {
        console.log('Observer.update invoked')
    }
}
```
- 以上，我们就完成了最基本的发布者和订阅者类的设计和编写。在实际的业务开发中，我们所有的定制化的发布者/订阅者逻辑都可以基于这两个基本类来改写。比如我们可以通过拓展发布者类，来使所有的订阅者来监听某个特定状态的变化。

- 仍然以开篇的例子为例，我们让开发者们来监听需求文档（prd）的变化：
```
// 定义一个具体的需求文档（prd）发布类
class PrdPublisher extends Publisher {
    constructor() {
        super()
        // 初始化需求文档
        this.prdState = null
        // 韩梅梅还没有拉群，开发群目前为空
        this.observers = []
        console.log('PrdPublisher created')
    }
    
    // 该方法用于获取当前的prdState
    getState() {
        console.log('PrdPublisher.getState invoked')
        return this.prdState
    }
    
    // 该方法用于改变prdState的值
    setState(state) {
        console.log('PrdPublisher.setState invoked')
        // prd的值发生改变
        this.prdState = state
        // 需求文档变更，立刻通知所有开发者
        this.notify()
    }
}
```
- 作为订阅方，开发者的任务也变得具体起来：接收需求文档、并开始干活：
```
class DeveloperObserver extends Observer {
    constructor() {
        super()
        // 需求文档一开始还不存在，prd初始为空对象
        this.prdState = {}
        console.log('DeveloperObserver created')
    }
    
    // 重写一个具体的update方法
    update(publisher) {
        console.log('DeveloperObserver.update invoked')
        // 更新需求文档
        this.prdState = publisher.getState()
        // 调用工作函数
        this.work()
    }
    
    // work方法，一个专门搬砖的方法
    work() {
        // 获取需求文档
        const prd = this.prdState
        // 开始基于需求文档提供的信息搬砖。。。
        ...
        console.log('996 begins...')
    }
}
```
- 下面，我们可以 new 一个 PrdPublisher 对象（产品经理），她可以通过调用 setState 方法来更新需求文档。需求文档每次更新，都会紧接着调用 notify 方法来通知所有开发者：

- 目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

OK，下面我们来看看韩梅梅和她的小伙伴们是如何搞事情的吧：
```
// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver()
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver()
// 创建订阅者：测试同学小B
const B = new DeveloperObserver()
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher()
// 需求文档出现了
const prd = {
    // 具体的需求内容
    ...
}
// 韩梅梅开始拉群
hanMeiMei.add(liLei)
hanMeiMei.add(A)
hanMeiMei.add(B)
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd)
```
- 以上，就是观察者模式在代码世界里的完整实现流程了。

- 相信走到这一步，大家对观察者模式的核心思想、基本实现模式都有了不错的掌握。下面我们趁热打铁，一起来看看如何凭借观察者模式，在面试中表演真正的技术~

#### Vue数据双向绑定（响应式系统）的实现原理
1. 解析
- Vue 框架是热门的渐进式 JavaScript框架。在 Vue 中，当我们修改状态时，视图会随之更新，这就是Vue的数据双向绑定（又称响应式原理）。数据双向绑定是Vue 最独特的特性之一。如果读者没有接触过 Vue，强烈建议阅读Vue官方对响应式原理的介绍 (opens new window)。此处我们用官方的一张流程图来简要地说明一下Vue响应式系统的整个流程：

- 在 Vue 中，每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。这道面试题考察了受试者对Vue底层原理的理解、对观察者模式的实现能力以及一系列重要的JS知识点，具有较强的综合性和代表性。

- 值得注意的是，在面试过程中，面试官多数情况下不会要求大家写出完整的响应式原理实现代码，而是要求你“说说自己的理解”。在本节，我们不会带大家一行一行写代码（具体深入Vue框架的相关知识，建议大家阅读Vue源码 (opens new window)及这本专门写Vue的小册 (opens new window)。），而是针对Vue响应式系统中与观察者模式紧密关联的这部分知识作讲解，帮助大家捋清楚整套流程里的来龙去脉、加深对观察者模式的理解。

在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：
- observer（监听器）：注意，此 observer 非彼 observer。在我们上面的解析中，observer 作为设计模式中的一个角色，代表“订阅者”。但在Vue数据双向绑定的角色结构里，所谓的 observer 不仅是一个数据监听器，它还需要对监听到的数据进行转发——也就是说它同时还是一个发布者。
- watcher（订阅者）：observer 把数据转发给了真正的订阅者——watcher对象。watcher 接收到新的数据后，会去更新视图。
- compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~

- OK，实现方案搞清楚了，下面我们给整个流程中涉及到发布-订阅这一模式的代码来个特写：

2. 核心代码
实现observer
- 首先我们需要实现一个方法，这个方法会对需要监听的数据对象进行遍历、给它的属性加上定制的 getter 和 setter 函数。这样但凡这个对象的某个属性发生了改变，就会触发 setter 函数，进而通知到订阅者。这个 setter 函数，就是我们的监听器：
```
// observe方法遍历并包装对象属性
function observe(target) {
    // 若target是一个对象，则遍历它
    if(target && typeof target === 'object') {
        Object.keys(target).forEach((key)=> {
            // defineReactive方法会给目标属性装上“监听器”
            defineReactive(target, key, target[key])
        })
    }
}

// 定义defineReactive方法
function defineReactive(target, key, val) {
    // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历
    observe(val)
    // 为当前属性安装监听器
    Object.defineProperty(target, key, {
         // 可枚举
        enumerable: true,
        // 不可配置
        configurable: false, 
        get: function () {
            return val;
        },
        // 监听器函数
        set: function (value) {
            console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)
            val = value
        }
    });
}
```
下面实现订阅者 Dep：
```
// 定义订阅者类Dep
class Dep {
    constructor() {
        // 初始化订阅队列
        this.subs = []
    }
    
    // 增加订阅者
    addSub(sub) {
        this.subs.push(sub)
    }
    
    // 通知订阅者（是不是所有的代码都似曾相识？）
    notify() {
        this.subs.forEach((sub)=>{
            sub.update()
        })
    }
}
```
- 现在我们可以改写 defineReactive 中的 setter 方法，在监听器里去通知订阅者了：
```
function defineReactive(target, key, val) {
    const dep = new Dep()
    // 监听当前属性
    observe(val)
    Object.defineProperty(target, key, {
        set: (value) => {
            // 通知所有订阅者
            dep.notify()
        }
    })
}
```

#### 实现一个Event Bus/Event Emitter
- Event Bus（Vue、Flutter 等前端框架中有出镜）和 Event Emitter（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——全局事件总线。

- 全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式。它在我们日常的业务开发中应用非常广。

- 如果只能选一道题，那这道题一定是 Event Bus/Event Emitter 的代码实现——我都说这么清楚了，这个知识点到底要不要掌握、需要掌握到什么程度，就看各位自己的了。

在Vue中使用Event Bus来实现组件间的通讯
- Event Bus/Event Emitter 作为全局事件总线，它起到的是一个沟通桥梁的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。

- 在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 Vuex 之外，我们还可以通过 Event Bus 来实现我们的需求。

创建一个 Event Bus（本质上也是 Vue 实例）并导出：
```
const EventBus = new Vue()
export default EventBus
```
在主文件里引入EventBus，并挂载到全局：
```
import bus from 'EventBus的文件路径'
Vue.prototype.bus = bus
```
订阅事件：
```
// 这里func指someEvent这个事件的监听函数
this.bus.$on('someEvent', func)
```
发布（触发）事件：
```
// 这里params指someEvent这个事件被触发时回调函数接收的入参
this.bus.$emit('someEvent', params)
```
- 大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上面的PrdPublisher和DeveloperObserver），全程只有bus这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！

下面，我们就一起来实现一个Event Bus（注意看注释里的解析）：
```
class EventEmitter {
  constructor() {
    // handlers是一个map，用于存储事件与回调之间的对应关系
    this.handlers = {}
  }

  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数
  on(eventName, cb) {
    // 先检查一下目标事件名有没有对应的监听函数队列
    if (!this.handlers[eventName]) {
      // 如果没有，那么首先初始化一个监听函数队列
      this.handlers[eventName] = []
    }

    // 把回调函数推入目标事件的监听函数队列里去
    this.handlers[eventName].push(cb)
  }

  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数
  emit(eventName, ...args) {
    // 检查目标事件是否有监听函数队列
    if (this.handlers[eventName]) {
      // 如果有，则逐个调用队列里的回调函数
      this.handlers[eventName].forEach((callback) => {
        callback(...args)
      })
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, cb) {
    const callbacks = this.handlers[eventName]
    const index = callbacks.indexOf(cb)
    if (index !== -1) {
      callbacks.splice(index, 1)
    }
  }

  // 为事件注册单次监听器
  once(eventName, cb) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const wrapper = (...args) => {
      cb.apply(...args)
      this.off(eventName, wrapper)
    }
    this.on(eventName, wrapper)
  }
}
```
- 在日常的开发中，大家用到EventBus/EventEmitter往往提供比这五个方法多的多的多的方法。但在面试过程中，如果大家能够完整地实现出这五个方法，已经非常可以说明问题了，因此楼上这个EventBus希望大家可以熟练掌握。学有余力的同学，推荐阅读FaceBook推出的通用EventEmiiter库的源码 (opens new window)，相信你会有更多收获。

#### 观察者模式与发布-订阅模式的区别是什么
在- 面试过程中，一些对细节比较在意的面试官可能会追问观察者模式与发布-订阅模式的区别。这个问题可能会引发一些同学的不适，因为在大量参考资料以及已出版的纸质书籍中，都会告诉大家“发布-订阅模式和观察者模式是同一个东西的两个名字”。本书在前文的叙述中，也没有突出强调两者的区别。其实这两个模式，要较起真来，确实不能给它们划严格的等号。

- 为什么大家都喜欢给它们强行划等号呢？这是因为就算划了等号，也不影响我们正常使用，毕竟两者在核心思想、运作机制上没有本质的差别。但考虑到这个问题确实可以成为面试题的一个方向，此处我们还是单独拿出来讲一下。

- 回到我们上文的例子里。韩梅梅把所有的开发者拉了一个群，直接把需求文档丢给每一位群成员，这种发布者直接触及到订阅者的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。

- 相信大家也已经看出来了，观察者模式和发布-订阅模式之间的区别，在于是否存在第三方、发布者能否直接感知订阅者。

- 在我们见过的这些例子里，韩梅梅拉钉钉群的操作，就是典型的观察者模式；而通过EventBus去实现事件监听/发布，则属于发布-订阅模式。

- 既生瑜，何生亮？既然有了观察者模式，为什么还需要发布-订阅模式呢？
- 大家思考一下：为什么要有观察者模式？观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，并没有完全地解决耦合问题——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。

- 而发布-订阅模式，则是快刀斩乱麻了——发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。发布-订阅模式下，实现了完全地解耦。

- 但这并不意味着，发布-订阅模式就比观察者模式“高级”。在实际开发中，我们的模块解耦诉求并非总是需要它们完全解耦。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用发布-订阅模式。

#### 行为型-迭代器模式
- 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》

- 迭代器模式是设计模式中少有的目的性极强的模式。所谓“目的性极强”就是说它不操心别的，它就解决这一个问题——遍历。

#### “公元前”的迭代器模式
- 遍历作为一种合理、高频的使用需求，几乎没有语言会要求它的开发者手动去实现。在JS中，本身也内置了一个比较简陋的数组迭代器的实现—— Array.prototype.forEach

通过调用forEach方法，我们可以轻松地遍历一个数组：
```
const arr = [1, 2, 3]
arr.forEach((item, index)=>{
    console.log(`索引为${index}的元素是${item}`)
})
```
但forEach方法并不是万能的，比如下面这种场景：
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件代理</title>
</head>
<body>
    <a href="#">链接1号</a>
    <a href="#">链接2号</a>
    <a href="#">链接3号</a>
    <a href="#">链接4号</a>
    <a href="#">链接5号</a>
    <a href="#">链接6号</a>
</body>
</html>
我想拿到所有的a标签，我可以这样做：

const aNodes = document.getElementsByTagName('a')
console.log('aNodes are', aNodes)
```
我想取其中一个a标签，可以这样做：
```
const aNode = aNodes[i]
```
- 在这个操作的映衬下，aNodes看上去多么像一个数组啊！但当你尝试用数组的原型方法去遍历它时：
```
aNodes.forEach((aNode, index){
    console.log(aNode, index)
})
```
你发现报错了：

- 原来这个aNodes是个假数组！准确地说，它是一个类数组对象，并没有为你实现好用的forEach方法。也就是说，要想实现类数组的遍历，你得另请高明。

- 现在问题就出现了：普通数组是不是集合？是！aNodes是不是集合？是！同样是集合，同样有遍历需求，我们却要针对不同的数据结构执行不同的遍历手段，好累！再回头看看迭代器的定义是什么——遍历集合的同时，我们不需要关心集合的内部结构。而forEach只能做到允许我们不关心数组这一种集合的内部结构，看来想要一套统一的遍历方案，我们非得请出一个更强的通用迭代器不可了。

- 这个小节的标题定语里有三个字“公元前”，这个“公元前”怎么定义呢？其实它说的就是ES标准内置迭代器之前的那些日子——差不多四五年之前，彼时还没有这么多轮子，jQuery风头正盛。当时面试可不问什么Vue原理、React原理、Webpack这些，当时问的最多的是你读过jQuery源码吗？答读过，好，那咱们就有的聊了。答没有？fine，看来你只是个调包侠，回见吧——因为前端的技术点在那时还很有限，所以可考察的东西也就这么点，读jQuery源码的程序员和不读jQuery源码的程序员在面试官眼里有着质的区别。但这也从一个侧面反映出来，jQuery这个库其实是非常优秀的，至少jQuery里有太多优秀的设计模式可以拿来考考你。就包括咱们当年想用一个真·迭代器又不想自己搞的时候，也是请jQuery实现的迭代器来帮忙：

首先我们要在页面里引入jQuery：
```
  <script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js" type="text/javascript"></script>
```
借助jQuery的each方法，我们可以用同一套遍历规则遍历不同的集合对象：
```
const arr = [1, 2, 3]
const aNodes = document.getElementsByTagName('a')

$.each(arr, function (index, item) {
    console.log(`数组的第${index}个元素是${item}`)
})

$.each(aNodes, function (index, aNode) {
    console.log(`DOM类数组的第${index}个元素是${aNode.innerText}`)
})
```
输出结果完全没问题：

- 当然啦，遍历jQuery自己的集合对象也不在话下：
```
const jQNodes = $('a')
$.each(jQNodes, function (index, aNode) {
   console.log(`jQuery集合的第${index}个元素是${aNode.innerText}`)
})
```
输出结果仍然没问题：

- 可以看出，jQuery的迭代器为我们统一了不同类型集合的遍历方式，使我们在访问集合内每一个成员时不用去关心集合本身的内部结构以及集合与集合间的差异，这就是迭代器存在的价值~

#### ES6对迭代器的实现
- 在“公元前”，JS原生的集合类型数据结构，只有Array（数组）和Object（对象）；而ES6中，又新增了Map和Set。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以ES6在推出新数据结构的同时也推出了一套统一的接口机制——迭代器（Iterator）。

- ES6约定，任何数据结构只要具备Symbol.iterator属性（这个属性就是Iterator的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被for...of...循环和迭代器的next方法遍历。 事实上，for...of...的背后正是对next方法的反复调用。

- 在ES6中，针对Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象这些原生的数据结构都可以通过for...of...进行遍历。原理都是一样的，此处我们拿最简单的数组进行举例，当我们用for...of...遍历数组时：
```
const arr = [1, 2, 3]
const len = arr.length
for(item of arr) {
   console.log(`当前元素是${item}`)
}
```
- 之所以能够按顺序一次一次地拿到数组里的每一个成员，是因为我们借助数组的Symbol.iterator生成了它对应的迭代器对象，通过反复调用迭代器对象的next方法访问了数组成员，像这样：
```
const arr = [1, 2, 3]
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 对迭代器对象执行next，就能逐个访问集合的成员
iterator.next()
iterator.next()
iterator.next()
```
丢进控制台，我们可以看到next每次会按顺序帮我们访问一个集合成员：

- 而for...of...做的事情，基本等价于下面这通操作：
```
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 初始化一个迭代结果
let now = { done: false }

// 循环往外迭代成员
while(!now.done) {
    now = iterator.next()
    if(!now.done) {
        console.log(`现在遍历到了${now.value}`)
    }
}
```
- 可以看出，for...of...其实就是iterator循环调用换了种写法。在ES6中我们之所以能够开心地用for...of...遍历各种各种的集合，全靠迭代器模式在背后给力。

#### 实现一个迭代器生成函数
- ok，看过了迭代器从古至今的操作，我们一起来实现一个自定义的迭代器。

- 楼上我们说迭代器对象全凭迭代器生成函数帮我们生成。在ES6中，实现一个迭代器生成函数并不是什么难事儿，因为ES6早帮我们考虑好了全套的解决方案，内置了贴心的生成器（Generator）供我们使用：
```
// 编写一个迭代器生成函数
function *iteratorGenerator() {
    yield '1号选手'
    yield '2号选手'
    yield '3号选手'
}

const iterator = iteratorGenerator()

iterator.next()
iterator.next()
iterator.next()
```
丢进控制台，不负众望：

- 写一个生成器函数并没有什么难度，但在面试的过程中，面试官往往对生成器这种语法糖背后的实现逻辑更感兴趣。下面我们要做的，不仅仅是写一个迭代器对象，而是用ES5去写一个能够生成迭代器对象的迭代器生成函数（解析在注释里）：
```
// 定义生成器函数，入参是任意集合
function iteratorGenerator(list) {
    // idx记录当前访问的索引
    var idx = 0
    // len记录传入集合的长度
    var len = list.length
    return {
        // 自定义next方法
        next: function() {
            // 如果索引还没有超出集合长度，done为false
            var done = idx >= len
            // 如果done为false，则可以继续取值
            var value = !done ? list[idx++] : undefined
            
            // 将当前值与遍历是否完毕（done）返回
            return {
                done: done,
                value: value
            }
        }
    }
}

var iterator = iteratorGenerator(['1号选手', '2号选手', '3号选手'])
iterator.next()
iterator.next()
iterator.next()
```
- 此处为了记录每次遍历的位置，我们实现了一个闭包，借助自由变量来做我们的迭代过程中的“游标”。

运行一下我们自定义的迭代器，结果符合预期：
- 迭代器模式比较特别，它非常重要，重要到语言和框架都争着抢着帮我们实现。但也正因为如此，大家业务开发中需要手动写迭代器的场景几乎没有，所以很少有同学会去刻意留意迭代器模式、思考它背后的实现机制。通过阅读本节，希望大家可以领略迭代器模式的妙处（为什么会有，为什么要用）和迭代器模式的实现思路（方便面试）。

#### 中介者模式
定义：对象与对象之间借助第三方中介者通信
```
class Player {
    constructor(name) {
        this.name = name;

        this.playerMiddle = new PlayerMiddle();
        this.playerMiddle.add(name);
    }

    win() {
        this.playerMiddle.win(this.name);
    }

    lose() {
        this.playerMiddle.lose(this.name);
    }
}

// 中介者
class PlayerMiddle {
    constructor() {
        this.players = [];
        this.winArr = [];
        this.loseArr = [];
    }

    add(name) {
        this.players.push(name)
    }

    win(name) {
        this.winArr.push(name)
        if (this.winArr.length + this.loseArr.length === this.players.length) {
            this.show()
        }
    }

    lose(name) {
        this.loseArr.push(name)
        if (this.winArr.length + this.loseArr.length === this.players.length) {
            this.show()
        }
    }

    show() {
        for (let winner of this.winArr) {
            console.log(winner + '挑战成功;')
        }

        for (let loser of this.loseArr) {
            console.log(loser + '挑战失败;')
        }
    }
}

const a = new Player('A 选手')
const b = new Player('B 选手')
const c = new Player('C 选手')

a.win()
b.win()
c.lose()
```

#### 享元模式
- 定义：一种优化程序性能的模式, 本质为减少对象创建的个数。

以下情况可以使用享元模式
- 有大量相似的对象，占用了大量内存
- 对象中大部分状态可以抽离为外部状态
```
// 题目：某商家有 50 种男款内衣和 50 种款女款内衣, 要展示它们！

class Model {
    constructor(gender) {
        this.gender = gender
        // this.underwear = ''
    }
    
    /* 方法一 */
    // takePhoto() {
    //     console.log(`${this.gender}穿着${this.underwear}`)
    // }
    
   /* 方法二 */
    takePhoto(i) {
        console.log(`${this.gender}穿着${i}款衣服`)
    }


}

const maleModel = new Model('male')
const femaleModel = new Model('female')

for (let i = 1; i < 51; i++) {
    // maleModel.underwear = `第${i}款衣服`
    // maleModel.takePhoto()

    maleModel.takePhoto(i)
}

for (let i = 1; i < 51; i++) {
    // femaleModel.underwear = `第${i}款衣服`
    // femaleModel.takePhoto()

    maleModel.takePhoto(i)
}
```


### 框架通识
#### MVVM
MVVM 由以下三个内容组成
- View：界面
- Model：数据模型
- ViewModel：作为桥梁负责沟通 View 和 Model

- 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。

MVVM
- 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View复用这个 ViewModel。

- 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

脏数据检测
- 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。

- 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。

数据劫持
- Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。
```
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```
- 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅
```
<div>
    {{name}}
</div>
```
- 在解析如上模板代码时，遇到 {name} 就会给属性 name 添加发布订阅。
```
// 通过 Dep 解耦
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    // sub 是 Watcher 实例
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null

function update(value) {
  document.querySelector('div').innerText = value
}

class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
```
接下来,对 defineReactive 函数进行改造
```
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      // 执行 watcher 的 update 方法
      dp.notify()
    }
  })
}
```
- 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加

Proxy 与 Object.defineProperty 对比
- Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。

- 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化
- 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack的办法，并且也是有缺陷的。
```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下几个函数
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
methodsToPatch.forEach(function (method) {
  // 获得原生函数
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    // 调用原生函数
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // 触发更新
    ob.dep.notify()
    return result
  })
})
```
- 反观 Proxy就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty
```
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

#### 路由原理
- 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式
  - hash 模式
  - history 模式

- www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。

- History模式是 HTML5 新推出的功能，比之 Hash URL 更加美观

#### （虚拟DOM）Virtual Dom
为什么需要 Virtual Dom
- 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多
```
// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这里替换上面的 li
[1, 2, 5, 4]
```
- 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。

如果以上操作对应到 DOM 中，那么就是以下代码
```
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
```
- 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。

- 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM
- 以下是一个 JS 对象模拟 DOM 对象的简单实现
```
export default class Element {
  /**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */
  constructor(tag, props, children, key) {
    this.tag = tag
    this.props = props
    if (Array.isArray(children)) {
      this.children = children
    } else if (isString(children)) {
      this.key = children
      this.children = null
    }
    if (key) this.key = key
  }
  // 渲染
  render() {
    let root = this._createElement(
      this.tag,
      this.props,
      this.children,
      this.key
    )
    document.body.appendChild(root)
    return root
  }
  create() {
    return this._createElement(this.tag, this.props, this.children, this.key)
  }
  // 创建节点
  _createElement(tag, props, child, key) {
    // 通过 tag 创建节点
    let el = document.createElement(tag)
    // 设置节点属性
    for (const key in props) {
      if (props.hasOwnProperty(key)) {
        const value = props[key]
        el.setAttribute(key, value)
      }
    }
    if (key) {
      el.setAttribute('key', key)
    }
    // 递归添加子节点
    if (child) {
      child.forEach(element => {
        let child
        if (element instanceof Element) {
          child = this._createElement(
            element.tag,
            element.props,
            element.children,
            element.key
          )
        } else {
          child = document.createTextNode(element)
        }
        el.appendChild(child)
      })
    }
    return el
  }
}
```
Virtual Dom 算法简述
- 既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。
- DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React团队优化了算法，实现了 O(n) 的复杂度来对比差异。
- 实现O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素

所以判断差异的算法就分为了两步
- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

Virtual Dom 算法实现
树的递归
- 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况
- 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了
- 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树
- 没有新的节点，那么什么都不用做
```
import { StateEnums, isString, move } from './util'
import Element from './element'

export default function diff(oldDomTree, newDomTree) {
  // 用于记录差异
  let pathchs = {}
  // 一开始的索引为 0
  dfs(oldDomTree, newDomTree, 0, pathchs)
  return pathchs
}

function dfs(oldNode, newNode, index, patches) {
  // 用于保存子树的更改
  let curPatches = []
  // 需要判断三种情况
  // 1.没有新的节点，那么什么都不用做
  // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
  // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  if (!newNode) {
  } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) {
    // 判断属性是否变更
    let props = diffProps(oldNode.props, newNode.props)
    if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props })
    // 遍历子树
    diffChildren(oldNode.children, newNode.children, index, patches)
  } else {
    // 节点不同，需要替换
    curPatches.push({ type: StateEnums.Replace, node: newNode })
  }

  if (curPatches.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(curPatches)
    } else {
      patches[index] = curPatches
    }
  }
}
```
判断属性的更改
- 判断属性的更改也分三个步骤

- 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
- 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
- 在第二步中同时查看是否有属性不存在与旧的属性列列表中
```
function diffProps(oldProps, newProps) {
  // 判断 Props 分以下三步骤
  // 先遍历 oldProps 查看是否存在删除的属性
  // 然后遍历 newProps 查看是否有属性值被修改
  // 最后查看是否有属性新增
  let change = []
  for (const key in oldProps) {
    if (oldProps.hasOwnProperty(key) && !newProps[key]) {
      change.push({
        prop: key
      })
    }
  }
  for (const key in newProps) {
    if (newProps.hasOwnProperty(key)) {
      const prop = newProps[key]
      if (oldProps[key] && oldProps[key] !== newProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      } else if (!oldProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      }
    }
  }
  return change
}
```
判断列表差异算法实现
- 这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步

- 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
- 遍历新的节点列表，判断是否有新的节点
- 在第二步中同时判断节点是否有移动
PS：该算法只对有 key 的节点做处理
```
function listDiff(oldList, newList, index, patches) {
  // 为了遍历方便，先取出两个 list 的所有 keys
  let oldKeys = getKeys(oldList)
  let newKeys = getKeys(newList)
  let changes = []

  // 用于保存变更后的节点数据
  // 使用该数组保存有以下好处
  // 1.可以正确获得被删除节点索引
  // 2.交换节点位置只需要操作一遍 DOM
  // 3.用于 `diffChildren` 函数中的判断，只需要遍历
  // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要
  // 再去判断一遍
  let list = []
  oldList &&
    oldList.forEach(item => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找新的 children 中是否含有当前节点
      // 没有的话需要删除
      let index = newKeys.indexOf(key)
      if (index === -1) {
        list.push(null)
      } else list.push(key)
    })
  // 遍历变更后的数组
  let length = list.length
  // 因为删除数组元素是会更改索引的
  // 所有从后往前删可以保证索引不变
  for (let i = length - 1; i >= 0; i--) {
    // 判断当前元素是否为空，为空表示需要删除
    if (!list[i]) {
      list.splice(i, 1)
      changes.push({
        type: StateEnums.Remove,
        index: i
      })
    }
  }
  // 遍历新的 list，判断是否有节点新增或移动
  // 同时也对 `list` 做节点新增和移动节点的操作
  newList &&
    newList.forEach((item, i) => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找旧的 children 中是否含有当前节点
      let index = list.indexOf(key)
      // 没找到代表新节点，需要插入
      if (index === -1 || key == null) {
        changes.push({
          type: StateEnums.Insert,
          node: item,
          index: i
        })
        list.splice(i, 0, key)
      } else {
        // 找到了，需要判断是否需要移动
        if (index !== i) {
          changes.push({
            type: StateEnums.Move,
            from: index,
            to: i
          })
          move(list, index, i)
        }
      }
    })
  return { changes, list }
}

function getKeys(list) {
  let keys = []
  let text
  list &&
    list.forEach(item => {
      let key
      if (isString(item)) {
        key = [item]
      } else if (item instanceof Element) {
        key = item.key
      }
      keys.push(key)
    })
  return keys
}
```
遍历子元素打标识
- 对于这个函数来说，主要功能就两个

- 判断两个列表差异
  - 给节点打上标记
  - 总体来说，该函数实现的功能很简单
```
function diffChildren(oldChild, newChild, index, patches) {
  let { changes, list } = listDiff(oldChild, newChild, index, patches)
  if (changes.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(changes)
    } else {
      patches[index] = changes
    }
  }
  // 记录上一个遍历过的节点
  let last = null
  oldChild &&
    oldChild.forEach((item, i) => {
      let child = item && item.children
      if (child) {
        index =
          last && last.children ? index + last.children.length + 1 : index + 1
        let keyIndex = list.indexOf(item.key)
        let node = newChild[keyIndex]
        // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
        if (node) {
          dfs(item, node, index, patches)
        }
      } else index += 1
      last = item
    })
}
```
渲染差异
- 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤

这个函数主要两个功能
- 深度遍历树，将需要做变更操作的取出来
- 局部更新 DOM
```
let index = 0
export default function patch(node, patchs) {
  let changes = patchs[index]
  let childNodes = node && node.childNodes
  // 这里的深度遍历和 diff 中是一样的
  if (!childNodes) index += 1
  if (changes && changes.length && patchs[index]) {
    changeDom(node, changes)
  }
  let last = null
  if (childNodes && childNodes.length) {
    childNodes.forEach((item, i) => {
      index =
        last && last.children ? index + last.children.length + 1 : index + 1
      patch(item, patchs)
      last = item
    })
  }
}

function changeDom(node, changes, noChild) {
  changes &&
    changes.forEach(change => {
      let { type } = change
      switch (type) {
        case StateEnums.ChangeProps:
          let { props } = change
          props.forEach(item => {
            if (item.value) {
              node.setAttribute(item.prop, item.value)
            } else {
              node.removeAttribute(item.prop)
            }
          })
          break
        case StateEnums.Remove:
          node.childNodes[change.index].remove()
          break
        case StateEnums.Insert:
          let dom
          if (isString(change.node)) {
            dom = document.createTextNode(change.node)
          } else if (change.node instanceof Element) {
            dom = change.node.create()
          }
          node.insertBefore(dom, node.childNodes[change.index])
          break
        case StateEnums.Replace:
          node.parentNode.replaceChild(change.node.create(), node)
          break
        case StateEnums.Move:
          let fromNode = node.childNodes[change.from]
          let toNode = node.childNodes[change.to]
          let cloneFromNode = fromNode.cloneNode(true)
          let cloenToNode = toNode.cloneNode(true)
          node.replaceChild(cloneFromNode, toNode)
          node.replaceChild(cloenToNode, fromNode)
          break
        default:
          break
      }
    })
}
```
Virtual Dom 算法的实现也就是以下三步
- 通过 JS 来模拟创建 DOM 对象
- 判断两个对象的差异
- 渲染差异
```
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])

let test1 = new Element('div', { class: 'my-div' }, [test4])

let test2 = new Element('div', { id: '11' }, [test5, test4])

let root = test1.render()

let pathchs = diff(test1, test2)
console.log(pathchs)

setTimeout(() => {
  console.log('开始更新')
  patch(root, pathchs)
  console.log('结束更新')
}, 1000)
```

#### Diff算法
#### React-Diff
- React的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。

1. 实现原理
来看这样一个例子。
- nextList为新的列表，prevList为旧列表。这个例子我们一眼能看出来，新列表是不需要进行移动的。下面我用react的递增思想，解释一下为什么新列表中的节点不需要移动。

- 我们首先遍历nextList，并且找到每一个节点，在prevList中的位置。
```
function foo(prevList, nextList) {
    for (let i = 0; i < nextList.length; i++) {
        let nextItem = nextList[i];
        for (let j = 0; j < prevList.length; j++) {
            let prevItem = prevList[j]
            if (nextItem === prevItem) {

            }
        }
    }
}
```
- 找到位置以后，与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个lastIndex来记录上一个节点的位置。
```
function foo(prevList, nextList) {
    let lastIndex = 0
    for (let i = 0; i < nextList.length; i++) {
        let nextItem = nextList[i];
        for (let j = 0; j < prevList.length; j++) {
            let prevItem = prevList[j]
            if (nextItem === prevItem) {
                if (j < lastIndex) {
                    // 需要移动节点
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```
- 在上面的例子中，nextList每个节点在prevList的位置为0 1 2 3。每一项都要比前一项要大，所以不需要移动，这就是react的diff算法的原理。

2. 找到需要移动的节点
- 在上一小节中，我们是通过对比值是否相等，查找的对应位置。但是在vdom中，每一个节点都是一个vNode，我们应该如何进行判断呢？

- 答案就是key，我们通过对每个节点的key进行赋值，并且让处于同一children数组下的vnode的key都不相同，以此来确定每个节点的唯一性，并进行新旧列表的对比。
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i];
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 需要移动节点
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```

3. 移动节点
- 首先我们先明确一点，移动节点所指的节点是DOM节点。vnode.el指向该节点对应的真实DOM节点。patch方法会将更新过后的DOM节点，赋值给新的vnode的el属性。

- 为了画图方便，我们用key的值来表示vnode节点。为了行文方便，我们把key值为a的vnode简写为vnode-a，vnode-a对应的真实DOM节点为DOM-A

- 我们来将上图的例子代入reactDiff中执行。我们遍历新列表，并查找vnode在旧列表中的位置。当遍历到vnode-d时，之前遍历在旧列表的位置为0 < 2 < 3，说明A C D这三个节点都是不需要移动的。此时lastIndex = 3, 并进入下一次循环，发现vnode-b在旧列表的index为1，1 < 3，说明DOM-B要移动。

- 通过观察我们能发现，只需要把DOM-B移动到DOM-D之后就可以了。也就是找到需要移动的VNode，我们称该VNode为α，将α对应的真实的DOM节点移动到，α在新列表中的前一个VNode对应的真实DOM的后面。

- 在上述的例子中，就是将vnode-b对应的真实DOM节点DOM-B, 移动到vnode-b在新列表中的前一个VNode——vnode-d对应的真实DOM节点DOM-D的后面
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i];
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```
- 为什么是这样移动的呢？首先我们列表是从头到尾遍历的。这就意味着对于当前VNode节点来说，该节点之前的所有节点都是排好序的，如果该节点需要移动，那么只需要将DOM节点移动到前一个vnode节点之后就可以，因为在新列表中vnode的顺序就是这样的。

4. 添加节点
- 上一小节我们只讲了如何移动节点，但是忽略了另外一种情况，就是在新列表中有全新的VNode节点，在旧列表中找不到。遇到这种情况，我们需要根据新的VNode节点生成DOM节点，并插入DOM树中。

- 至此，我们面临两个问题：1.如何发现全新的节点、2. 生成的DOM节点插入到哪里

- 我们先来解决第一个问题，找节点还是比较简单的，我们定义一个find变量值为false。如果在旧列表找到了key 相同的vnode，就将find的值改为true。当遍历结束后判断find值，如果为false，说明当前节点为新节点
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
        }
    }
}
```
- 找到新节点后，下一步就是插入到哪里了，这里的逻辑其实是和移动节点的逻辑是一样的。我们观察上图可以发现，新的vnode-c是紧跟在vnode-b后面的，并且vnode-b的DOM节点——DOM-B是已经排好序的，所以我们只需要将vnode-c生成的DOM节点插入到DOM-B之后就可以了。

- 但是这里有一种特殊情况需要注意，就是新的节点位于新列表的第一个，这时候我们需要找到旧列表第一个节点，将新节点插入到原来第一个节点之前就可以了。
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
            let refNode = i <= 0
                            ? prevChildren[0].el
                            : nextChildren[i - 1].el.nextSibling
            mount(nextChild, parent, refNode);
        }
    }
}
```

5. 移除节点
- 有增就有减，当旧的节点不在新列表中时，我们就将其对应的DOM节点移除。
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
            let refNode = i <= 0
                            ? prevChildren[0].el
                            : nextChildren[i - 1].el.nextSibling
            mount(nextChild, parent, refNode);
        }
    }
    for (let i = 0; i < prevChildren.length; i++) {
        let prevChild = prevChildren[i],
            key = prevChild.key,
            has = nextChildren.find(item => item.key === key);
        if (!has) parent.removeChild(prevChild.el)
    }
}
```
6. 优化与不足
以上就是React的diff算法的思路。
- 目前的reactDiff的时间复杂度为O(m*n)，我们可以用空间换时间，把key与index的关系维护成一个Map，从而将时间复杂度降低为O(n)，具体的代码可以查看此项目 (opens new window)。

我们接下来看这样一个例子
- 根据reactDiff的思路，我们需要先将DOM-A移动到DOM-C之后，然后再将DOM-B移动到DOM-A之后，完成Diff。但是我们通过观察可以发现，只要将DOM-C移动到DOM-A之前就可以完成Diff。

- 这里是有可优化的空间的，接下来我们介绍vue2.x中的diff算法——双端比较，该算法解决了上述的问题

#### Vue2.X Diff——双端比较
- 所谓双端比较就是新列表和旧列表两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。

1. 实现原理
- 我们先用四个指针指向两个列表的头尾
```
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[nextStartIndex],
    newEndNode = nextChildren[nextEndIndex];
}
```
我们根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比
- 使用旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比
- 使用旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比
- 使用旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比
- 使用旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比

- 使用以上四步进行对比，去寻找key相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图

对比顺序代码结构如下:
```
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];
  
  if (oldStartNode.key === newStartNode.key) {

  } else if (oldEndNode.key === newEndNode.key) {

  } else if (oldStartNode.key === newEndNode.key) {

  } else if (oldEndNode.key === newStartNode.key) {

  }
}
```
- 当对比时找到了可复用的节点，我们还是先patch给元素打补丁，然后将指针进行前/后移一位指针。根据对比节点的不同，我们移动的指针和方向也不同，具体规则如下：

- 当旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的头指针oldStartIndex与新列表的头指针newStartIndex同时向后移动一位。
- 当旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的尾指针oldEndIndex与新列表的尾指针newEndIndex同时向前移动一位。
- 当旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的头指针oldStartIndex向后移动一位；新列表的尾指针newEndIndex向前移动一位。
- 当旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的尾指针oldEndIndex向前移动一位；新列表的头指针newStartIndex向后移动一位。

```
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1,
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];

  if (oldStartNode.key === newStartNode.key) {
    patch(oldvStartNode, newStartNode, parent)

    oldStartIndex++
    newStartIndex++
    oldStartNode = prevChildren[oldStartIndex]
    newStartNode = nextChildren[newStartIndex]
  } else if (oldEndNode.key === newEndNode.key) {
    patch(oldEndNode, newEndNode, parent)

    oldEndIndex--
    newEndIndex--
    oldEndNode = prevChildren[oldEndIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldStartNode.key === newEndNode.key) {
    patch(oldStartNode, newEndNode, parent)

    oldStartIndex++
    newEndIndex--
    oldStartNode = prevChildren[oldStartIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldEndNode.key === newStartNode.key) {
    patch(oldEndNode, newStartNode, parent)

    oldEndIndex--
    nextStartIndex++
    oldEndNode = prevChildren[oldEndIndex]
    newStartNode = nextChildren[newStartIndex]
  }
}
```
- 在小节的开头，提到了要让指针向内靠拢，所以我们需要循环。循环停止的条件是当其中一个列表的节点全部遍历完成，代码如下
```
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1,
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldEndIndex--
      newndIndex--
      oldEndNode = prevChildren[oldEndIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldvStartNode, newEndNode, parent)

      oldStartIndex++
      newEndIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)

      oldEndIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldEndIndex]
      newStartNode = nextChildren[newStartIndex]
    }
  }
}
```
至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：
- 什么情况下DOM节点需要移动
- DOM节点如何移动

我们来解决第一个问题：什么情况下需要移动，我们还是以上图为例。
- 当我们在第一个循环时，在第四步发现旧列表的尾节点oldEndNode与新列表的头节点newStartNode的key相同，是可复用的DOM节点。通过观察我们可以发现，原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可。
```
function vue2Diff(prevChildren, nextChildren, parent) {
 // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
       // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      // ...
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      // 移动到旧列表头节点之前
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      
      oldEndIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldEndIndex]
      newStartNode = nextChildren[newStartIndex]
    }
  }
}
```
- 然后我们进入第二次循环，我们在第二步发现，旧列表的尾节点oldEndNode和新列表的尾节点newEndNode为复用节点。原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动，所以我们什么都不需要做。

- 同理，如果是旧列表的头节点oldStartNode和新列表的头节点newStartNode为复用节点，我们也什么都不需要做。

- 进入第三次循环，我们在第三部发现，旧列表的头节点oldStartNode和新列表的尾节点newEndNode为复用节点。到这一步聪明如你肯定就一眼可以看出来了，我们只要将DOM-A移动到DOM-B后面就可以了。

- 依照惯例我们还是解释一下，原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
      // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)

      oldStartIndex++
      newEndIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldEndNode.key === newStartNode.key) {
     //...
    }
  }
}
```
- OK，进入最后一个循环。在第一步旧列表头节点oldStartNode与新列表头节点newStartNode位置相同，所以啥也不用做。然后结束循环，这就是Vue2 双端比较的原理。

2. 非理想情况
- 上一小节，我们讲了双端比较的原理，但是有一种特殊情况，当四次对比都没找到复用节点时，我们只能拿新列表的第一个节点去旧列表中找与其key相同的节点。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
    }
  }
}
```
- 找节点的时候其实会有两种情况：一种在旧列表中找到了，另一种情况是没找到。我们先以上图为例，说一下找到的情况。

- 当我们在旧列表中找到对应的VNode，我们只需要将找到的节点的DOM元素，移动到开头就可以了。这里的逻辑其实和第四步的逻辑是一样的，只不过第四步是移动的尾节点，这里是移动找到的节点。DOM移动后，由我们将旧列表中的节点改为undefined，这是至关重要的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针newStartIndex向后移一位。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```
- 如果在旧列表中没有找到复用节点呢？很简单，直接创建一个新的节点放到最前面就可以了，然后后移头指针newStartIndex。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      } else {
      	mount(newStartNode, parent, oldStartNode.el)
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```
最后当旧列表遍历到undefind时就跳过当前节点。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode === undefind) {
    	oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefind) {
    	oldEndNode = prevChildren[--oldEndIndex]
    } else if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
    // ...
    }
  }
}
```

3. 添加节点
我们先来看一个例子
- 这个例子非常简单，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束，如下
- 此时oldEndIndex以及小于了oldStartIndex，但是新列表中还有剩余的节点，我们只需要将剩余的节点依次插入到oldStartNode的DOM之前就可以了。为什么是插入oldStartNode之前呢？原因是剩余的节点在新列表的位置是位于oldStartNode之前的，如果剩余节点是在oldStartNode之后，oldStartNode就会先行对比，这个需要思考一下，其实还是与第四步的思路一样。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  }
}
```

4. 移除节点
- 与上一小节的情况相反，当新列表的newEndIndex小于newStartIndex时，我们将旧列表剩余的节点删除即可。这里我们需要注意，旧列表的undefind。在第二小节中我们提到过，当头尾节点都不相同时，我们会去旧列表中找新列表的第一个节点，移动完DOM节点后，将旧列表的那个节点改为undefind。所以我们在最后的删除时，需要注意这些undefind，遇到的话跳过当前循环即可。
```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  } else if (newEndIndex < newStartIndex) {
    for (let i = oldStartIndex; i <= oldEndIndex; i++) {
      if (prevChildren[i]) {
        partent.removeChild(prevChildren[i].el)
      }
    }
  }
}
```

5. 小结
至此双端比较全部完成，以下是全部代码。
```
function vue2diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    newStartIndex = 0,
    oldStartIndex = prevChildren.length - 1,
    newStartIndex = nextChildren.length - 1,
    oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldStartIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newStartIndex];
  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {
    if (oldStartNode === undefined) {
      oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefined) {
      oldEndNode = prevChildren[--oldStartIndex]
    } else if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldStartIndex--
      newStartIndex--
      oldEndNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)
      oldStartIndex++
      newStartIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      oldStartIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else {
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));
      if (oldIndex === -1) {
        mount(newStartNode, parent, oldStartNode.el)
      } else {
        let prevNode = prevChildren[oldIndex]
        patch(prevNode, newStartNode, parent)
        parent.insertBefore(prevNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartIndex++
      newStartNode = nextChildren[newStartIndex]
    }
  }
  if (newStartIndex > newStartIndex) {
    while (oldStartIndex <= oldStartIndex) {
      if (!prevChildren[oldStartIndex]) {
        oldStartIndex++
        continue
      }
      parent.removeChild(prevChildren[oldStartIndex++].el)
    }
  } else if (oldStartIndex > oldStartIndex) {
    while (newStartIndex <= newStartIndex) {
      mount(nextChildren[newStartIndex++], parent, oldStartNode.el)
    }
  }
}
```

#### Vue3 Diff——最长递增子序列
- vue3的diff借鉴于inferno (opens new window)，该算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列，此思想与React的diff类似又不尽相同。下面我们来一一介绍。

1. 前置与后置的预处理
我们看这两段文字
```
Hello World
Hey World
```
- 其实就简单的看一眼我们就能发现，这两段文字是有一部分是相同的，这些文字是不需要修改也不需要移动的，真正需要进行修改中间的几个字母，所以diff就变成以下部分
```
text1: 'llo'
text2: 'y'
```
- 接下来换成vnode，我们以下图为例。

- 图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁patch就可以了。我们把该逻辑写成代码。
```
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    j++
    prevNode = prevChildren[j]
    nextNode = nextChildren[j]
  }
  
  prevNode = prevChildren[prevEnd]
  nextNode = prevChildren[nextEnd]
  
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    prevEnd--
    nextEnd--
    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]
  }
}
```
- 这时候，我们就需要考虑边界情况了，这里有两种情况。一种是j > prevEnd；另一种是j > nextEnd。

 我们以这张图为例，此时j > prevEnd且j <= nextEnd，我们只需要把新列表中j到nextEnd之间剩下的节点插入进去就可以了。相反， 如果j > nextEnd时，我们把旧列表中j到prevEnd之间的节点删除就可以了。
```
function vue3Diff(prevChildren, nextChildren, parent) {
  // ...
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```
- 我们再继续思考，在我们while循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用label语法，当我们触发边界情况时，退出全部的循环，直接进入判断。代码如下：
```
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  // label语法
  outer: {
    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      j++
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[j]
      nextNode = nextChildren[j]
    }

    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]

    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      prevEnd--
      nextEnd--
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[prevEnd]
      nextNode = prevChildren[nextEnd]
    }
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```

2. 判断是否需要移动
- 其实几个算法看下来，套路已经很明显了，就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。这个算法也不例外，我们接下来看一下它是如何做的。

- 当前/后置的预处理结束后，我们进入真正的diff环节。首先，我们先根据新列表剩余的节点数量，创建一个source数组，并将数组填满-1。

我们先写这块逻辑。
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1);  // 创建数组，填满-1
     
  }
}
```
- 那么这个source数组，是要做什么的呢？他就是来做新旧节点的对应关系的，我们将新节点在旧列表的位置存储在该数组中，我们在根据source计算出它的最长递增子序列用于移动DOM节点。为此，我们先建立一个对象存储当前新列表中的节点与index的关系，再去旧列表中去找位置。

- 在找节点时要注意，如果旧节点在新列表中没有的话，直接删除就好。除此之外，我们还需要一个数量表示记录我们已经patch过的节点，如果数量已经与新列表剩余的节点数量一样，那么剩下的旧节点我们就直接删除了就可以了
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0;                            // 已更新过的节点的数量
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
    }
  }
}
```
- 找到位置后，我们观察这个重新赋值后的source，我们可以看出，如果是全新的节点的话，其在source数组中对应的值就是初始的-1，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。

- 其次，我们要判断是否需要移动。那么如何判断移动呢？很简单，和React一样我们用递增法，如果我们找到的index是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0,
      move = false,                           // 是否移动
      lastIndex = 0;                          // 记录上一次的位置
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
      
      // 递增方法，判断是否需要移动
      if (nextIndex < lastIndex) {
      	move = false
      } else {
      	lastIndex = nextIndex
      }
    }
    
    if (move) {
    
    // 需要移动
    } else {
	
    //不需要移动
    }
  }
}
```

3. DOM如何移动
- 判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行DOM移动，我们首先要做的就是找到source的最长递增子序列。
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
  // 需要移动
  } else {

  //不需要移动
  }
}
```
- 什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。
  - 例如给定数值序列为：[ 0, 8, 4, 12 ]。
  - 那么它的最长递增子序列就是：[0, 8, 12]。
  - 当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的。

- 上面的代码中，我们调用lis 函数求出数组source的最长递增子序列为[ 0, 1 ]。我们知道 source 数组的值为 [2, 3, 1, -1]，很显然最长递增子序列应该是[ 2, 3 ]，但为什么计算出的结果是[ 0, 1 ]呢？其实[ 0, 1 ]代表的是最长递增子序列中的各个元素在source数组中的位置索引，如下图所示：

- 我们根据source，对新列表进行重新编号，并找出了最长递增子序列。

- 我们从后向前进行遍历source每一项。此时会出现三种情况：

- 当前的值为-1，这说明该节点是全新的节点，又由于我们是从后向前遍历，我们直接创建好DOM节点插入到队尾就可以了。
- 当前的索引为最长递增子序列中的值，也就是i === seq[j]，这说说明该节点不需要移动
- 当前的索引不是最长递增子序列中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
   // 需要移动
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
 
  } else {
  //不需要移动
  
  }
}
```
- 说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：
```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
  } else {
    //不需要移动
    for (let i = nextLeft - 1； i >= 0; i--) {
      let cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
       let pos = nextStart + i, // 对应新列表的index
          nextNode = nextChildren[pos],	// 找到vnode
          nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
          refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
      	mount(nextNode, parent, refNode)
      }
    }
  }
}
```
至此vue3.0的diff完成。

4. 最长递增子序列
我们以该数组为例
```
[10,9,2,5,3,8,7,13]
```
- 我们可以使用动态规划的思想考虑这个问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。

- 我们先假设只有一个值的数组[13]，那么该数组的最长递增子序列就是[13]自己本身，其长度为1。那么我们认为每一项的递增序列的长度值均为1

- 那么我们这次给数组增加一个值[7, 13], 由于7 < 13，所以该数组的最长递增子序列是[7, 13]，那么该长度为2。那么我们是否可以认为，当[7]小于[13]时，以[7]为头的递增序列的长度是，[7]的长度和[13]的长度的和，即1 + 1 = 2。

- ok，我们基于这种思想来给计算一下该数组。我们先将每个值的初始赋值为1

- 首先 7 < 13 那么7对应的长度就是13的长度再加1，1 + 1 = 2

- 继续，我们对比8。我们首先和7比，发现不满足递增，但是没关系我们还可以继续和13比，8 < 13满足递增，那么8的长度也是13的长度在加一，长度为2

- 我们再对比3，我们先让其与8进行对比，3 < 8，那么3的长度是8的长度加一，此时3的长度为3。但是还没结束，我们还需要让3与7对比。同样3 < 7，此时我们需要在计算出一个长度是7的长度加一同样是3，我们对比两个长度，如果原本的长度没有本次计算出的长度值大的话，我们进行替换，反之则我们保留原本的值。由于3 === 3，我们选择不替换。最后，我们让3与13进行对比，同样的3 < 13，此时计算出的长度为2，比原本的长度3要小，我们选择保留原本的值。

- 之后的计算依次类推，最后的结果是这样的

- 我们从中取最大的值4，该值代表的最长递增子序列的个数。代码如下：
```
function lis(arr) {
  let len = arr.length,
    dp = new Array(len).fill(1); // 用于保存长度
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i]
    for(let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 如果是递增 取更大的长度值
      if (cur < next) dp[i] = Math.max(dp[j]+1, dp[i])
    }
  }
  return Math.max(...dp)
}
```
- 至此为止，我们讲完了基础的最长递增子序列。然而在vue3.0中，我们需要的是最长递增子序列在原本数组中的索引。所以我们还需要在创建一个数组用于保存每个值的最长子序列所对应在数组中的index。具体代码如下：
```
function lis(arr) {
  let len = arr.length,
    res = [],
    dp = new Array(len).fill(1);
  // 存默认index
  for (let i = 0; i < len; i++) {
    res.push([i])
  }
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i],
      nextIndex = undefined;
    // 如果为-1 直接跳过，因为-1代表的是新节点，不需要进行排序
    if (cur === -1) continue
    for (let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 满足递增条件
      if (cur < next) {
        let max = dp[j] + 1
        // 当前长度是否比原本的长度要大
        if (max > dp[i]) {
          dp[i] = max
          nextIndex = j
        }
      }
    }
    // 记录满足条件的值，对应在数组中的index
    if (nextIndex !== undefined) res[i].push(...res[nextIndex])
  }
  let index = dp.reduce((prev, cur, i, arr) => cur > arr[prev] ? i : prev, dp.length - 1)
  // 返回最长的递增子序列的index
  return result[index]
}
```


### React

  #### React生命周期
react旧版生命周期包含三个过程：
- 1、挂载过程
constructor()
componentWillMount()
componentDidMount()

- 2、更新过程
componentWillReceiveProps(nextProps)
shouldComponentUpdate(nextProps,nextState)
componentWillUpdate (nextProps,nextState)
render()
componentDidUpdate(prevProps,prevState)

- 3、卸载过程
componentWillUnmount()

其具体作用分别为：
- 1、constructor()
完成了React数据的初始化。

- 2、componentWillMount()
组件已经完成初始化数据，但是还未渲染DOM时执行的逻辑，主要用于服务端渲染。

- 3、componentDidMount()
组件第一次渲染完成时执行的逻辑，此时DOM节点已经生成了。

- 4、componentWillReceiveProps(nextProps)
接收父组件新的props时，重新渲染组件执行的逻辑。

- 5、shouldComponentUpdate(nextProps, nextState)
在setState以后，state发生变化，组件会进入重新渲染的流程时执行的逻辑。在这个生命周期中return false可以阻止组件的更新，主要用于性能优化。

- 6、componentWillUpdate(nextProps, nextState)
shouldComponentUpdate返回true以后，组件进入重新渲染的流程时执行的逻辑。

- 7、render()
页面渲染执行的逻辑，render函数把jsx编译为函数并生成虚拟dom，然后通过其diff算法比较更新前后的新旧DOM树，并渲染更改后的节点。

- 8、componentDidUpdate(prevProps, prevState)
重新渲染后执行的逻辑。

- 9、componentWillUnmount()
组件的卸载前执行的逻辑，比如进行“清除组件中所有的setTimeout、setInterval等计时器”或“移除所有组件中的监听器removeEventListener”等操作。

react新版生命周期：
```
react16.4后使用了新的生命周期，使用getDerivedStateFromProps
代替了旧的componentWillReceiveProps及componentWillMount。
使用getSnapshotBeforeUpdate代替了旧的componentWillUpdate。
```

使用getDerivedStateFromProps(nextProps, prevState)的原因：
```
旧的React中componentWillReceiveProps方法是用来判断前后两个 props 
是否相同，如果不同，则将新的 props 更新到相应的 state 上去。
在这个过程中我们实际上是可以访问到当前props的，这样我们可能会对
this.props做一些奇奇怪怪的操作，很可能会破坏 state 数据的
单一数据源，导致组件状态变得不可预测。

而在 getDerivedStateFromProps 中禁止了组件去访问 this.props，
强制让开发者去比较 nextProps 与 prevState 中的值，以确保当
开发者用到 getDerivedStateFromProps 这个生命周期函数时，
就是在根据当前的 props 来更新组件的 state，而不是去访问
this.props并做其他一些让组件自身状态变得更加不可预测的事情。
```

使用getSnapshotBeforeUpdate(prevProps, prevState)的原因：
```
在 React 开启异步渲染模式后，在执行函数时读到的 DOM 元素状态
并不总是渲染时相同，这就导致在 componentDidUpdate 中使用 
componentWillUpdate 中读取到的 DOM 元素状态是不安全的，
因为这时的值很有可能已经失效了。

而getSnapshotBeforeUpdate 会在最终的 render 之前被调用，
也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素
状态是可以保证与componentDidUpdate 中一致的。
```

  #### 组件之间通信
- 父子组件通信
- 自定义事件
- redux和context

context如何运用
- 父组件向其下所有子孙组件传递信息
- 如一些简单的信息：主题、语言
- 复杂的公共信息用redux

  #### 组件的渲染顺序
假如有A,B,C,D组件，层级结构为：
```
   顶层       A
   子组件     B
   子组件   C   D
```

我们知道组件的生命周期为：
挂载阶段：
- constructor()
- componentWillMount()
- render()
- componentDidMount()

更新阶段为：
- componentWillReceiveProps()
- shouldComponentUpdate()
- componentWillUpdate()
- render()
- componentDidUpdate

那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？
```
以render()函数为分界线。从顶层组件开始，一直往下，
直至最底层子组件。然后再往上
```

组件update阶段同理
前面是react16以前的组建渲染方式。这就存在一个问题
```
如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行
```

Fiber架构就是为了解决这个问题
```
fiber架构 组建的渲染顺序

加入fiber的react将组件更新分为两个时期
```

这两个时期以render为分界
- render前的生命周期为phase1,
- render后的生命周期为phase2
```
phase1的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，
去确定是否有其他更重要的任务。此过程，React在 workingProgressTree 
（并不是真实的virtualDomTree）上复用 current 上的 Fiber 数据结构
来一步地（通过requestIdleCallback）来构建新的 tree，
标记处需要更新的节点，放入队列中

phase2的生命周期是不可被打断的，React 将其所有的变更一次性
更新到DOM上
```

这里最重要的是phase1这是时期所做的事。
因此我们需要具体了解phase1的机制
- 如果不被打断，那么phase1执行完会直接进入render函数，构建真实的virtualDomTree
- 如果组件再phase1过程中被打断，即当前组件只渲染到一半（也许是在willMount,也许是willUpdate~反正是在render之前的生命周期），那么react会怎么干呢？ react会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，react通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）

所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来
```
这样的话，就和react16版本之前有很大区别了，因为可能会被执行多次，
那么我们最好就得保证phase1的生命周期每一次执行的结果都是一样的，
否则就会有问题，因此，最好都是纯函数
```
- 如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决
- 所以，facebook在react16增加fiber结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿

  #### React组件和渲染更新过程
渲染和更新过程
- jsx如何渲染为页面
- setState之后如何更新页面
- 面试考察全流程

JSX本质和vdom
- JSX即createElement函数
- 执行生成vnode
- patch(elem,vnode)和patch(vnode,newNode)

组件渲染过程
- props state
- render()生成vnode
- patch(elem, vnode)

组件更新过程
- setState-->dirtyComponents(可能有子组件)
- render生成newVnode
- patch(vnode, newVnode)

  #### React都做过哪些优化
- React渲染页面的两个阶段
  - 调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。
  - 渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上

- React 15 架构
  - React15架构可以分为两层
    - Reconciler（协调器）—— 负责找出变化的组件；
    - Renderer（渲染器）—— 负责将变化的组件渲染到页面上；

```
  在React15及以前，Reconciler采用递归的方式创建虚拟DOM，
递归过程是不能中断的。如果组件树的层级很深，递归会占用线程
很多时间，递归更新时间超过了16ms，用户交互就会卡顿。

  为了解决这个问题，React16将递归的无法中断的更新重构为异步的
可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。
于是，全新的Fiber架构应运而生。
```

- React 16 架构
  - 为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。
  - 从v15到v16，React团队花了两年时间将源码架构中的Stack Reconciler重构为Fiber Reconciler
  - React16架构可以分为三层：
    - Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler；
    - Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构；
    - Renderer（渲染器）—— 负责将变化的组件渲染到页面上。

- React 17 优化
  - 使用Lane来管理任务的优先级。Lane用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。
  - Concurrent Mode的目的是实现一套可中断/恢复的更新机制。其由两部分组成：
    - 一套协程架构：Fiber Reconciler
    - 基于协程架构的启发式更新算法：控制协程架构工作方式的算法

  #### React有哪些优化性能的手段
类组件中的优化手段
- 使用纯组件 PureComponent 作为基类。
- 使用 React.memo 高阶函数包装组件。
- 使用 shouldComponentUpdate 生命周期函数来自定义渲染逻辑。

方法组件中的优化手段
- 使用 useMemo。
- 使用 useCallBack。

其他方式
- 在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
- 必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
- 使用 Suspense 和 lazy 进行懒加载，例如：
```
import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    var ComponentToLazyLoad = null;

    if (this.props.name == "Mayank") {
      ComponentToLazyLoad = lazy(() => import("./mayankComponent"));
    } else if (this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() => import("./anshulComponent"));
    }

    return (
      <div>
        <h1>This is the Base User: {this.state.name}</h1>
        <Suspense fallback={<div>Loading...</div>}>
          <ComponentToLazyLoad />
        </Suspense>
      </div>
    )
  }
}
```

  #### diff算法是怎么运作
```
每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，
react会先比较该节点类型，假如节点类型不一样，那么react会直接
删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，
那么会比较prop是否有更新，假如有prop不一样，那么react会判定
该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，
一层一层往下，直到没有子节点
```

- 把树形结构按照层级分解，只比较同级元素。
- 给列表结构的每个单元添加唯一的key属性，方便比较。
- React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）
- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty的 component重新绘制.
- 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能

优化
```
为了降低算法复杂度，React的diff会预设三个限制：
```
- 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。
- 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
- 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：

Diff的思路
该如何设计算法呢？如果让我设计一个Diff算法，我首先想到的方案是：
```
判断当前节点的更新属于哪种情况
如果是新增，执行新增逻辑
如果是删除，执行删除逻辑
如果是更新，执行更新逻辑
```
- 按这个方案，其实有个隐含的前提——不同操作的优先级是相同的
- 但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。

基于以上原因，Diff算法的整体逻辑会经历两轮遍历：
- 第一轮遍历：处理更新的节点。
- 第二轮遍历：处理剩下的不属于更新的节点。


diff算法的作用
```
计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，
而非重新渲染整个页面。
```

传统diff算法
```
通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3) ，n是树
的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。
即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。
```

React的diff算法
```
什么是调和？
将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。

什么是React diff算法？
diff算法是调和的具体实现。
```

diff策略
```
React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度
```

策略一（tree diff）：
- Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。

策略二（component diff）：
- 拥有相同类的两个组件 生成相似的树形结构，
- 拥有不同类的两个组件 生成不同的树形结构。

策略三（element diff）：
对于同一层级的一组子节点，通过唯一id区分。
tree diff
- React通过updateDepth对Virtual DOM树进行层级控制。
- 对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。
- 只需遍历一次，就能完成整棵DOM树的比较。

那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？
```
答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，
只有创建节点和删除节点的操作。

以A为根节点的整棵树会被重新创建，而不是移动，因此官方建议
不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，
而不是真正地移除、添加DOM节点
```

component diff
```
React对不同的组件间的比较，有三种策略
```

- 同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。
- 同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 shouldComponentUpdate() 来判断是否需要 判断计算。
- 不同类型的组件，将一个（将被改变的）组件判断为dirty component（脏组件），从而替换 整个组件的所有节点。

```
注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。
```

element diff
```
当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。
```
- 插入：组件 C 不在集合（A,B）中，需要插入
- 删除：
  - 组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。
  - 组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。
- 移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即可。

总结
- tree diff：只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动
```
react 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下
的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，
不会用于进一步的比较。

这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

这就意味着，如果 dom 节点发生了跨层级移动，react 会删除旧的节点，
生成新的节点，而不会复用。
```

- component diff：如果不是同一类型的组件，会删除旧的组件，创建新的组件

- element diff：对于同一层级的一组子节点，需要通过唯一 id 进行来区分
```
  如果没有 id 来进行区分，一旦有插入动作，
会导致插入位置之后的列表全部重新渲染

  这也是为什么渲染列表时为什么要使用唯一的 key。
```

diff的不足与待优化的地方
```
尽量减少类似将最后一个节点移动到列表首部的操作，
当节点数量过大或更新操作过于频繁时，会影响React的渲染性能
```

  #### React router
react-router如何配置懒加载
```
import { BrowserRouter as Router, Route, Switch } from ' react- router-dom' ;
import React, { Suspense, lazy } from 'react' ;
const Home = lazy(() => import(' ./ routes/Home'));
const About = lazy(() => import('./ routes/About'));
constApp=()=>(
<Router>
<Suspense fallback= {<div>Loading... </div>}>
<Switch>
<Route exact path="/" component= {Home}/>
Route path=" / about" component= {About}/>
</ Switch>
</ Suspense>
</Route r>
);
```




- [jQuery](#jQuery)
  - [](#)  2 jQuery 的实现原理
  - [](#)  12 针对 jQuery 的优化方法
  - [](#)  17 jQuery对象的特点
  - [](#)  1 你觉得jQuery或zepto源码有哪些写的好的地方
  - [](#)  11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的
  - [](#)  5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝
  - [](#)  6 jQuery 的队列是如何实现的
  - [](#)  10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来
  - [](#)  9 jQuery 通过哪个方法和 Sizzle 选择器结合的
  - [](#)  3 jQuery.fn 的 init 方法返回的 this 指的是什么对象
  - [](#)  4 jQuery.extend 与 jQuery.fn.extend 的区别
  - [](#)  7 jQuery 中的 bind(), live(), delegate(), on()的区别
  - [](#)  8 是否知道自定义事件
  - [](#)  14 jQuery UI 如何自定义组件
  - [](#)  15 jQuery 与 jQuery UI、jQuery Mobile 区别
  - [](#)  13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢
  - [](#)  16 jQuery 和 Zepto 的区别？ 各自的使用场景



#### 针对jQuery的优化方法

```
缓存频繁操作DOM对象
尽量使用id选择器代替class选择器
总是从#id选择器来继承
尽量使用链式操作
使用时间委托 on绑定事件
采用jQuery的内部函数data()来存储数据
使用最新版本的 jQuery
```



- [微信小程序](#微信小程序)
  - [](#)  5 微信小程序与vue区别
  - [](#)  1 微信小程序有几个文件
  - [](#)  2 微信小程序怎样跟事件传值
  - [](#)  3 小程序的 wxss 和 css 有哪些不一样的地方？
  - [](#)  4 小程序关联微信公众号如何确定用户的唯一性



### webpack相关

#### webpack原理简述
#### 核心概念
- JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。

- Entry: 入口文件，Webpack会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

#### 工作流程(加载-编译-输出)
- 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象；
- 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译；
- 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步；
- 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改;
- 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程；

#### 模块包装
```
(function(modules) {
	// 模拟 require 函数，从内存中加载模块；
	function __webpack_require__(moduleId) {
		// 缓存模块
		if (installedModules[moduleId]) {
			return installedModules[moduleId].exports;
		}
		
		var module = installedModules[moduleId] = {
			i: moduleId,
			l: false,
			exports: {}
		};
		
		// 执行代码；
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		
		// Flag: 标记是否加载完成；
		module.l = true;
		
		return module.exports;
	}
	
	// ...
	
	// 开始执行加载入口文件；
	return __webpack_require__(__webpack_require__.s = "./src/index.js");
 })({
 	"./src/index.js": function (module, __webpack_exports__, __webpack_require__) {
		// 使用 eval 执行编译后的代码；
		// 继续递归引用模块内部依赖；
		// 实际情况并不是使用模板字符串，这里是为了代码的可读性；
		eval(`
			__webpack_require__.r(__webpack_exports__);
			//
			var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("test", ./src/test.js");
		`);
	},
	"./src/test.js": function (module, __webpack_exports__, __webpack_require__) {
		// ...
	},
 })
```
总结:
- 模块机制: webpack自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- 文件编译: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

#### webpack的打包原理
- 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- 确定入口：根据配置中的 entry 找出所有的入口文件
- 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

#### 总结
- 初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。
- 开始编译：从上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。
- 确定入口：根scope据配置中的 entry 找出所有的入口文件。
- 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。
- 完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

#### webpack热更新原理
- 当修改了一个或多个文件；
- 文件系统接收更改并通知 webpack；
- webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；
- HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp
- HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新

#### webpack Loader
- 由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 不同格式文件转换器。其实 Loader 做的事，也并不难理解: 对 Webpack 传入的字符串进行按需修改。例如一个最简单的 Loader:
```
// html-loader/index.js
module.exports = function(htmlSource) {
	// 返回处理后的代码字符串
	// 删除 html 文件中的所有注释
	return htmlSource.replace(/<!--[\w\W]*?-->/g, '')
}
```
- 当然，实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 Babel-loader 会执行以下步骤:

- babylon 将 ES6/ES7 代码解析成 AST
- babel-traverse 对 AST 进行遍历转译，得到新的 AST
- 新 AST 通过 babel-generator 转换成 ES5

Loader 特性:
- 链式传递，按照配置时相反的顺序链式执行；
- 基于 Node 环境，拥有 较高权限，比如文件的增删查改；
- 可同步也可异步；

常用 Loader:
- file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；
- url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；
- babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；
- ts-loader: 加载 ts / tsx 文件，编译 TypeScript；
- style-loader: 将 css 代码以<style>标签的形式插入到 html 中；
- css-loader: 分析@import和url()，引用 css 文件与对应的资源；
- postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；
- less-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；

编写原则:
- 单一原则: 每个 Loader 只做一件事；
- 链式调用: Webpack 会按顺序链式调用每个 Loader；
- 统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

#### webpack Plugin
- 插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。

一个最简单的 plugin 是这样的:
```
class Plugin{
  	// 注册插件时，会调用 apply 方法
  	// apply 方法接收 compiler 对象
  	// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作
  	apply(compiler){
  		// compilation 是监听每次编译循环
  		// 每次文件变化，都会生成新的 compilation 对象并触发该事件
    	compiler.plugin('compilation',function(compilation) {})
  	}
}
```

注册插件:
```
// webpack.config.js
module.export = {
	plugins:[
		new Plugin(options),
	]
}
```

事件流机制:
```
Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 
与 Plugin 的一道道处理，最后输出结果。
```
- 通过链式调用，按顺序串起一个个 Loader；
- 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中；
```
Webpack 事件流编程范式的核心是基础类 Tapable，
是一种观察者模式的实现事件的订阅与广播：
```

```
const { SyncHook } = require("tapable")

const hook = new SyncHook(['arg'])

// 订阅
hook.tap('event', (arg) => {
	// 'event-hook'
	console.log(arg)
})

// 广播
hook.call('event-hook')
```

```Webpack 中两个最重要的类 Compiler 与 Compilation 
便是继承于 Tapable，也拥有这样的事件流机制。
```
- Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递；

- Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子；

- 区别:
  - Compiler 全局唯一，且从启动生存到结束；
  - Compilation对应每次编译，每轮编译循环均会重新创建；

- 常用 Plugin:
  - UglifyJsPlugin: 压缩、混淆代码；
  - CommonsChunkPlugin: 代码分割；
  - ProvidePlugin: 自动加载模块；
  - html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；
  - extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；
  - optimize-css-assets-webpack-plugin: CSS 代码去重；
  - webpack-bundle-analyzer: 代码分析；
  - compression-webpack-plugin: 使用 gzip 压缩 js 和 css；
  - happypack: 使用多进程，加速代码构建；
  - EnvironmentPlugin: 定义环境变量；
- 调用插件 apply 函数传入 compiler 对象
- 通过 compiler 对象监听事件

loader和plugin有什么区别？
- webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。

- loader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。
- plugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。

webpack中都有哪些插件，这些插件有什么作用？
- html-webpack-plugin 自动创建一个HTML文件，并把打包好的JS插入到HTML文件中
- clean-webpack-plugin 在每一次打包之前，删除整个输出文件夹下所有的内容
- mini-css-extrcat-plugin 抽离CSS代码，放到一个单独的文件中
- optimize-css-assets-plugin 压缩css

实现一个编译结束退出命令的插件
```
apply (compiler) {
  const afterEmit = (compilation, cb) => {
    cb()
    setTimeout(function () {
      process.exit(0)
    }, 1000)
  }

  compiler.plugin('after-emit', afterEmit)
}
}

module.exports = BuildEndPlugin
```

```
<script>
export default {
  mounted () {
    var isGithub = location.href.indexOf('FE-Interview-Questions')!==-1
    var sId = isGithub ? '59154049' : '66575297'
    var script = document.createElement("script");
    script.type = "text/javascript"
    script.charset="UTF-8"
    script.src = `http://tajs.qq.com/stats?sId=${sId}`
    document.body.appendChild(script);
  }
}
</script>
```

#### webpack编译优化
代码优化:
- 无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；

- 例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如:
```
var fn = function() {
	return 1;
	// 下面代码便属于 不可能执行的代码；
	// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；
	var a = 1;
	return a;
}
```
- 摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 "摇" 我们打包后的 js 代码，将没有使用到的无用代码 "摇" 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。

- 原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。
- 问题: 具有 副作用 的函数无法被 tree-shaking
  - 在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；
  - 尽量写纯函数，减少函数的副作用；
  - 可使用 webpack-deep-scope-plugin，可以进行作用域分析，减少此类情况的发生，但仍需要注意；
- code-spliting: 代码分割技术，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；
- Webpack 中使用 SplitChunksPlugin 进行拆分；
- 按 页面 拆分: 不同页面打包成不同的文件；
- 按 功能 拆分:
  - 将类似于播放器，计算库等大模块进行拆分后再懒加载引入；
  - 提取复用的业务代码，减少冗余代码；
- 按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；
- scope hoisting: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；

编译性能优化:
- 升级至 最新 版本的 webpack，能有效提升编译性能；
- 使用 dev-server / 模块热替换 (HMR) 提升开发体验；
  - 监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；
- 缩小编译范围
  - modules: 指定模块路径，减少递归搜索；
  - mainFields: 指定入口文件描述字段，减少搜索；
  - noParse: 避免对非模块化文件的加载；
  - includes/exclude: 指定搜索范围/排除不必要的搜索范围；
  - alias: 缓存目录，避免重复寻址；
- babel-loader
  - 忽略node_moudles，避免编译第三方库中已经被编译过的代码
  - 使用cacheDirectory，可以缓存编译结果，避免多次重复编译
- 多进程并发
  - webpack-parallel-uglify-plugin: 可多进程并发压缩 js 文件，提高压缩速度；
  - HappyPack: 多进程并发文件的 Loader 解析；
- 第三方库模块缓存:
  - DLLPlugin 和 DLLReferencePlugin 可以提前进行打包并缓存，避免每次都重新编译；
- 使用分析
  - Webpack Analyse / webpack-bundle-analyzer 对打包后的文件进行分析，寻找可优化的地方
  - 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方
- source-map:
  - 开发: cheap-module-eval-source-map
  - 生产: hidden-source-map；

#### 优化webpack打包速度
- 减少文件搜索范围
  - 比如通过别名
  - loader 的 test，include & exclude
- - Webpack4 默认压缩并行
- Happypack 并发调用
- babel 也可以缓存编译

#### webpack import()原理
#### 动态导入原理
用于动态加载的import()方法
- 这个功能可以实现按需加载我们的代码，并且使用了promise式的回调，获取加载的包
- 在代码中所有被import()的模块，都将打成一个单独的包，放在chunk存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载
```
// 这里是一个简单的demo。
// 可以看到，import()的语法十分简单。该函数只接受一个参数，就是引用包的地址
import('lodash').then(_ => {
  // Do something with lodash (a.k.a '_')...
 })
```

#### webpack中如何实现动态导入
- 使用import(/** webpackChunkName: "lodash" **/ 'lodash').then(_ => {})，同时可以在webpack.config.js中配置一下output的chunkFilename为[name].bunld.js将要导入的模块单独抽离到一个bundle中，以此实现代码分离。
- 使用async，由于import()返回的是一个promise, 因此我们可以使用async函数来简化它，不过需要babel这样的预处理器及处理转换async的插件。const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');

#### webpack有哪几种文件指纹
- hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值。(粒度整个项目)
- chunkhash是根据不同的入口进行依赖文件解析，构建对应的chunk(模块)，生成对应的hash值。只有被修改的chunk(模块)在重新构建之后才会生成新的hash值，不会影响其它的chunk。(粒度entry的每个入口文件)
- contenthash是跟每个生成的文件有关，每个文件都有一个唯一的hash值。当要构建的文件内容发生改变时，就会生成新的hash值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

#### webpack如果使用了hash命名，那是每次都会重写生成hash吗
有三种情况：
- 如果是hash的话，是和整个项目有关的，有一处文件发生更改则所有文件的hash值都会发生改变且它们共用一个hash值；
- 如果是chunkhash的话，只和entry的每个入口文件有关，也就是同一个chunk下的文件有所改动该chunk下的文件的hash值就会发生改变
- 如果是contenthash的话，和每个生成的文件有关，只有当要构建的文件内容发生改变时才会给该文件生成新的hash值，并不会影响其它文件。

#### webpack中如何处理图片的
在webpack中有两种处理图片的loader：
- file-loader：解决CSS等中引入图片的路径问题；(解决通过url,import/require()等引入图片的问题)
- url-loader：当图片小于设置的limit参数值时，url-loader将图片进行base64编码(当项目中有很多图片，通过url-loader进行base64编码后会减少http请求数量，提高性能)，大于limit参数值，则使用file-loader拷贝图片并输出到编译目录中；

#### webpack常用插件总结
1. 功能类
1.1 html-webpack-plugin
```
自动生成html，基本用法：
```
```
new HtmlWebpackPlugin({
  filename: 'index.html', // 生成文件名
  template: path.join(process.cwd(), './index.html') // 模班文件
})
```

1.2 copy-webpack-plugin
```
拷贝资源插件
```
```
new CopyWebpackPlugin([
  {
    from: path.join(process.cwd(), './vendor/'),
    to: path.join(process.cwd(), './dist/'),
    ignore: ['*.json']
  }
])
```

1.3 webpack-manifest-plugin && assets-webpack-plugin
```
俩个插件效果一致，都是生成编译结果的资源单，
只是资源单的数据结构不一致而已
```
webpack-manifest-plugin 基本用法
```
module.exports = {
  plugins: [
    new ManifestPlugin()
  ]
}
```
assets-webpack-plugin 基本用法
```
module.exports = {
  plugins: [
    new AssetsPlugin()
  ]
}
```
1.4 clean-webpack-plugin
```
在编译之前清理指定目录指定内容
```
```
// 清理目录
const pathsToClean = [
  'dist',
  'build'
]
 
// 清理参数
const cleanOptions = {
  exclude:  ['shared.js'], // 跳过文件
}
module.exports = {
  // ...
  plugins: [
    new CleanWebpackPlugin(pathsToClean, cleanOptions)
  ]
}
```
1.5 compression-webpack-plugin
```
提供带 Content-Encoding 编码的压缩版的资源
```
```
module.exports = {
  plugins: [
    new CompressionPlugin()
  ]
}
```
1.6 progress-bar-webpack-plugin
```
编译进度条插件
```
```
module.exports = {
  //...
  plugins: [
    new ProgressBarPlugin()
  ]
}
```
2. 代码相关类
2.1 webpack.ProvidePlugin
```
自动加载模块，如 $ 出现，就会自动加载模块；
$ 默认为'jquery'的exports
```
```
new webpack.ProvidePlugin({
  $: 'jquery',
})
```
2.2 webpack.DefinePlugin
```
定义全局常量
```
```
new webpack.DefinePlugin({
  'process.env': {
    NODE_ENV: JSON.stringify(process.env.NODE_ENV)
  }
})
```
2.3 mini-css-extract-plugin && extract-text-webpack-plugin
```
提取css样式，对比
```
- mini-css-extract-plugin 为webpack4及以上提供的plugin，支持css chunk
- extract-text-webpack-plugin 只能在webpack3 及一下的版本使用，不支持css chunk

基本用法 extract-text-webpack-plugin
```
const ExtractTextPlugin = require("extract-text-webpack-plugin");
 
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",
          use: "css-loader"
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin("styles.css"),
  ]
}
```
基本用法 mini-css-extract-plugin
```
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
    module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '/'  // chunk publicPath
            }
          },
          "css-loader"
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].css", // 主文件名
      chunkFilename: "[id].css"  // chunk文件名
    })
  ]
}
```

3. 编译结果优化类
3.1 wbepack.IgnorePlugin
```
忽略regExp匹配的模块
```
```
new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
```
3.2 uglifyjs-webpack-plugin
```
代码丑化，用于js压缩
```
```
module.exports = {
  //...
  optimization: {
    minimizer: [new UglifyJsPlugin({
      cache: true,   // 开启缓存
      parallel: true, // 开启多线程编译
      sourceMap: true,  // 是否sourceMap
      uglifyOptions: {  // 丑化参数
        comments: false,
        warnings: false,
        compress: {
          unused: true,
          dead_code: true,
          collapse_vars: true,
          reduce_vars: true
        },
        output: {
          comments: false
        }
      }
    }]
  }
};
```
3.3 optimize-css-assets-webpack-plugin
```
css压缩，主要使用 cssnano 压缩器 https://github.com/cssnano/cssnano
```
```
module.exports = {
  //...
  optimization: {
    minimizer: [new OptimizeCssAssetsPlugin({
      cssProcessor: require('cssnano'),   // css 压缩优化器
      cssProcessorOptions: { discardComments: { removeAll: true } } // 去除所有注释
    })]
  }
};
```
3.4 webpack-md5-hash
```
使你的chunk根据内容生成md5，用这个md5取代 webpack chunkhash。
```
```
var WebpackMd5Hash = require('webpack-md5-hash');
 
module.exports = {
  // ...
  output: {
    //...
    chunkFilename: "[chunkhash].[id].chunk.js"
  },
  plugins: [
    new WebpackMd5Hash()
  ]
};
```
3.5 SplitChunksPlugin
- CommonChunkPlugin 的后世，用于chunk切割。
- webpack 把 chunk 分为两种类型，一种是初始加载initial chunk，另外一种是异步加载 async chunk，如果不配置SplitChunksPlugin，webpack会在production的模式下自动开启，默认情况下，webpack会将 node_modules 下的所有模块定义为异步加载模块，并分析你的 entry、动态加载（import()、require.ensure）模块，找出这些模块之间共用的node_modules下的模块，并将这些模块提取到单独的chunk中，在需要的时候异步加载到页面当中，其中默认配置如下
```
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async', // 异步加载chunk
      minSize: 30000,
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '~', // 文件名中chunk分隔符
      name: true,
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,  // 
          priority: -10
        },
        default: {
          minChunks: 2,  // 最小的共享chunk数
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```
4. 编译优化类
4.1 DllPlugin && DllReferencePlugin && autodll-webpack-plugin
- dllPlugin将模块预先编译，DllReferencePlugin 将预先编译好的模块关联到当前编译中，当 webpack 解析到这些模块时，会直接使用预先编译好的模块。
- autodll-webpack-plugin 相当于 dllPlugin 和 DllReferencePlugin 的简化版，其实本质也是使用 dllPlugin && DllReferencePlugin，它会在第一次编译的时候将配置好的需要预先编译的模块编译在缓存中，第二次编译的时候，解析到这些模块就直接使用缓存，而不是去编译这些模块

dllPlugin 基本用法：
```
const output = {
  filename: '[name].js',
  library: '[name]_library',
  path: './vendor/'
}

module.exports = {
  entry: {
    vendor: ['react', 'react-dom']  // 我们需要事先编译的模块，用entry表示
  },
  output: output,
  plugins: [
    new webpack.DllPlugin({  // 使用dllPlugin
      path: path.join(output.path, `${output.filename}.json`),
      name: output.library // 全局变量名， 也就是 window 下 的 [output.library]
    })
  ]
}
```
DllReferencePlugin 基本用法：
```
const manifest = path.resolve(process.cwd(), 'vendor', 'vendor.js.json')

module.exports = {
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: require(manifest), // 引进dllPlugin编译的json文件
      name: 'vendor_library' // 全局变量名，与dllPlugin声明的一致
    }
  ]
}
```
autodll-webpack-plugin 基本用法：
```
module.exports = {
  plugins: [
    new AutoDllPlugin({
      inject: true, // 与 html-webpack-plugin 结合使用，注入html中
      filename: '[name].js',
      entry: {
        vendor: [
          'react',
          'react-dom'
        ]
      }
    })
  ]
}
```
4.2 happypack && thread-loader
```
多线程编译，加快编译速度，thread-loader不可以和 
mini-css-extract-plugin 结合使用
```
happypack 基本用法
```
const HappyPack = require('happypack');
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });
const happyLoaderId = 'happypack-for-react-babel-loader';

module.exports = {
  module: {
    rules: [{
      test: /\.jsx?$/,
      loader: 'happypack/loader',
      query: {
        id: happyLoaderId
      },
      include: [path.resolve(process.cwd(), 'src')]
    }]
  },
  plugins: [new HappyPack({
    id: happyLoaderId,
    threadPool: happyThreadPool,
    loaders: ['babel-loader']
  })]
}
```
thread-loader 基本用法
```
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve("src"),
        use: [
          "thread-loader",
          // your expensive loader (e.g babel-loader)
          "babel-loader"
        ]
      }
    ]
  }
}
```
4.3 hard-source-webpack-plugin && cache-loader
```
使用模块编译缓存，加快编译速度
```
hard-source-webpack-plugin 基本用法
```
module.exports = {
  plugins: [
    new HardSourceWebpackPlugin()
  ]
}
```
cache-loader 基本用法
```
module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          'cache-loader',
          ...loaders
        ],
        include: path.resolve('src')
      }
    ]
  }
}
```
5. 编译分析类
5.1 webpack-bundle-analyzer
```
编译模块分析插件
```
```
new BundleAnalyzerPlugin({
  analyzerMode: 'server',
  analyzerHost: '127.0.0.1',
  analyzerPort: 8889,
  reportFilename: 'report.html',
  defaultSizes: 'parsed',
  generateStatsFile: false,
  statsFilename: 'stats.json',
  statsOptions: null,
  logLevel: 'info'
}),
```
5.2 stats-webpack-plugin && PrefetchPlugin
- stats-webpack-plugin 将构建的统计信息写入文件，该文件可在 http://webpack.github.io/analyse中上传进行编译分析，并根据分析结果，可使用 PrefetchPlugin 对部分模块进行预解析编译

stats-webpack-plugin 基本用法：
```
module.exports = {
  plugins: [
    new StatsPlugin('stats.json', {
      chunkModules: true,
      exclude: [/node_modules[\\\/]react/]
    })
  ]
};
```
PrefetchPlugin 基本用法：
```
module.exports = {
  plugins: [
    new webpack.PrefetchPlugin('/web/', 'app/modules/HeaderNav.jsx'),
    new webpack.PrefetchPlugin('/web/', 'app/pages/FrontPage.jsx')
];
}
```
5.3 speed-measure-webpack-plugin
统计编译过程中，各loader和plugin使用的时间
```
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
 
const smp = new SpeedMeasurePlugin();
 
const webpackConfig = {
  plugins: [
    new MyPlugin(),
    new MyOtherPlugin()
  ]
}
module.exports = smp.wrap(webpackConfig);
```

#### 抽象语法树AST
- 抽象语法树（Abstract Syntax Tree），是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查、代码风格检查、代码格式化、代码高亮、代码错误提示、代码自动补全等等的基础
```
// 转换前
function square(n) {
  return n * n
}

// 转换后
const element = {
  type: "FunctionDeclaration",
  start: 0,
  end: 35,
  id: Identifier,
  expression: false,
  generator: false,
  params: [1, element],
  body: BlockStatement
}
```

#### 使用babel-loader会有哪些问题？可以怎样优化
- 会使得编译很慢。解决办法是可以在webpack的babel-loader配置中使用exclude这个可选项来去除一些不需要编译的文件夹(例如node_modules和bower_components)，另一种可以设置cacheDirectory选项为true, 开启缓存, 转译的结果将会缓存到文件系统中, 这样使babel-loader至少提速两倍(代码量越多效果应该越明显)。
- babel-loader使得打包文件体积过大。Babel 对一些公共方法使用了非常小的辅助代码, 比如 _extend.默认情况下会被添加到每一个需要它的文件中, 所以会导致打包文件体积过大.解决办法: 引入babel runtime作为一个单独的模块, 来避免重复。也就是可以使用@babel/plugin-transform-runtime和babel-runtime。

#### Babel原理
- babel 的编译过程分为三个阶段：parsing、transforming、generating，以 ES6 编译为 ES5 作为例子：

- ES6 代码输入；
- babylon 进行解析得到 AST；
- plugin 用 babel-traverse 对 AST树进行遍历编译，得到新的 AST树；
- 用 babel-generator 通过 AST树生成 ES5 代码。
Babel原理及其使用(opens new window)

#### Babel是如何编译Class的
就拿下面的类来说：
```
class Person {
  constructor ({ name }) {
    this.name = name
    this.getSex = function () {
      return 'boy'
    }
  }
  getName () {
    return this.name
  }
  static getLook () {
    return 'sunshine'
  }
}
```
- 当我们在使用babel的这些plugin或者使用preset的时候，有一个配置属性loose它默认是为false，在这样的条件下：

Class编译后：
- 总体来说Class会被封装成一个IIFE立即执行函数
- 立即执行函数返回的是一个与类同名的构造函数
- 实例属性和方法定义在构造函数内(如name和getSex())
- 类内部声明的属性方法(getName)和静态属性方法(getLook)是会被Object.defineProperty所处理，将其可枚举属性设置为false

编译后的代码：
```
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Person = /*#__PURE__*/ (function () {
  function Person(_ref) {
    var name = _ref.name;

    _classCallCheck(this, Person);

    this.name = name;

    this.getSex = function () {
      return "boy";
    };
  }

  _createClass(
    Person,
    [
      {
        key: "getName",
        value: function getName() {
          return this.name;
        },
      },
    ],
    [
      {
        key: "getLook",
        value: function getLook() {
          return "sunshine";
        },
      },
    ]
  );

  return Person;
})();
```
- 为什么Babel对于类的处理会使用Object.defineProperty这种形式呢？它和直接使用原型链有什么不同吗？

- 通过原型链声明的属性和方法是可枚举的，也就是可以被for...of...搜寻到
- 而类内部声明的方法是不可枚举的

- 所以，babel为了符合ES6真正的语义，编译类时采取了Object.defineProperty来定义原型方法。

- 但是可以通过设置babel的loose模式(宽松模式)为true，它会不严格遵循ES6的语义，而采取更符合我们平常编写代码时的习惯去编译代码，在.babelrc中可以如下设置：
```
{
  "presets": [["env", { "loose": true }]]
}
```
- 比如上述的Person类的属性方法将会编译成直接在原型链上声明方法：
```
"use strict";

var Person = /*#__PURE__*/function () {
  function Person(_ref) {
    var name = _ref.name;
    this.name = name;

    this.getSex = function () {
      return 'boy';
    };
  }

  var _proto = Person.prototype;

  _proto.getName = function getName() {
    return this.name;
  };

  Person.getLook = function getLook() {
    return 'sunshine';
  };

  return Person;
}();
```

总结
- 当使用Babel编译时默认的loose为false，即非宽松模式
- 无论哪种模式，转换后的定义在类内部的属性方法是被定义在构造函数的原型对象上的；静态属性被定义到构造函数上
- 只不过非宽松模式时，这些属性方法会被_createClass函数处理，函数内通过Object.defineProperty()设置属性的可枚举值enumerable为false
- 由于在_createClass函数内使用了Object，所以非宽松模式下是会产生副作用的，而宽松模式下不会。
- webpack中的UglifyJS依旧还是会将宽松模式认为是有副作用的，而rollup有程序流程分析的功能，可以更好的判断代码是否真正产生副作用，所以它会认为宽松模式没有副作用。
- (副作用大致理解为：一个函数会、或者可能会对函数外部变量产生影响的行为。)

#### babel-polyfill是什么
- ployfill是补丁
- babel-polyfill现在已经被弃用

- babel 7.4之后弃用babel-polyfill
- 直接推荐使用core-js和regenerator

babel-polyfill按需引入
- 文件较大
- 只用一部分功能，无需全部引入
- 配置按需引入
 
babel-polyfill的问题
- 会污染全局环境
- 如果做一个独立的web系统，无碍
- 如果做一个第三个的lib，会有问题
 
#### Tree Shaking原理是什么
对tree-shaking的了解
作用：
- 它表示在打包的时候会去除一些无用的代码

原理：
- ES6的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码

特点：
- 在生产模式下它是默认开启的，但是由于经过babel编译全部模块被封装成IIFE，它存在副作用无法被tree-shaking掉
- 可以在package.json中配置sideEffects来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是false则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用
- rollup和webpack中对tree-shaking的层度不同，例如对babel转译后的class，如果babel的转译是宽松模式下的话(也就是loose为true)，webpack依旧会认为它有副作用不会tree-shaking掉，而rollup会。这是因为rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。

原理
- ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
- 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

```
依赖于import/export
```
通过导入所有的包后再进行条件获取。如下：
```
import foo from "foo";
import bar from "bar";

if(condition) {
    // foo.xxxx
} else {
    // bar.xxx
}
```
- ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码

- CommonJS的动态特性模块意味着tree shaking不适用。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：
```
// 不可行，ES6 的import是完全静态的
if(condition) {
    myDynamicModule = require("foo");
} else {
    myDynamicModule = require("bar");
}
```

#### Vite了解吗
- 是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包

Vite 特点
- 快速的冷启动
- 按需编译
- 即时热模块更新

生产环境需要打包吗
- 可以不打包，需要启动server，需要浏览器支持
















### Node
- 当面试官问你node的时候，更多引导面试官用node做前端工程化，去引导到webpack、npm、打包工具上面去说说自己的想法，不要引导到自己会后端，后台不是会一点node语法就能写的

#### package.json版本号规则
major.minor.patch
- 主版本号.次版本号.修补版本号
- patch：修复bug，兼容老版本
- minor：新增功能，兼容老版本
- major：新的架构调整，不兼容老版本

~和^的区别
- ~会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0
- ^会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0

#### npm模块安装机制
- 发出 npm install 命令 1 查询 node_modules 目录之中是否已经存在指定模块
- 若存在，不再重新安装
- 若不存在
- npm 向 registry 查询模块压缩包的网址
- 下载压缩包，存放在根目录下的.npm 目录里
- 解压压缩包到当前项目的 node_modules 目录

#### 模块化的差异AMD CMD COMMONJS ESMODULE
- AMD是依赖前置，define写法
- CMD 语法require
- AMD和CMD是动态引入，运行时才知道的
- ESMODULE是静态引入，好处方便wepback打包依赖图谱分析
- CommonJs 是单个值导出，ES6 Module 可以导出多个
- CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
- CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined

#### Node的Event Loop:6个阶段
- timer 阶段: 执行到期的setTimeout / setInterval队列回调
- I/O 阶段: 执行上轮循环残流的callback
- idle, prepare
- poll: 等待回调
  - 执行回调
  - 执行定时器
    - 如有到期的setTimeout / setInterval， 则返回 timer 阶段
    - 如有setImmediate，则前往 check 阶段
- check
  - 执行setImmediate
- close callbacks

#### Koa相关
koa洋葱模型怎么实现的
- app.use() 把中间件函数存储在middleware数组中，最终会调用koa-compose导出的函数compose返回一个promise，中间函数的第一个参数ctx是包含响应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个promise

如果中间件中的next()方法报错了怎么办
- 中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit('error', err, this)（因为koa继承自events模块，所以有'emit'和on等方法），可以使用app.on('error', (err) => {})，或者app.onerror = (err) => {}进行捕获。

co的原理是怎样的
- co的原理是通过不断调用generator函数的next方法来达到自动执行generator函数的，类似async、await函数自动执行

#### Express、koa实现原理以及对比
- 底层建立在node.js内置的http模块上。http模块生成服务器的原始代码如下
```
var http = require("http");

var app = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.end("Hello world!");
});

app.listen(3000, "localhost");
```
- Express框架的核心是对http模块的再包装
- Express框架等于在http模块之上，加了一个中间层
- 它最大的特点就是，一个中间件处理完，再传递给下一个中间件
- 比如自带 Router、路由规则等
- callback太多

koa2特点
- 洋葱模型
- 没有自带路由，由koa-router管理
- 没有callback








### 小程序
#### 登录
unionid和openid
- 了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识：

- OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。
- UnionId 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通了。

关键Api
- wx.login 官方提供的登录能力
- wx.checkSession校验用户当前的session_key是否有效
- wx.authorize 提前向用户发起授权请求
- wx.getUserInfo 获取用户基本信息

登录流程设计
- 利用现有登录体系
  - 直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可

- 利用OpenId 创建用户体系
  - OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下

- 小程序客户端通过 wx.login 获取 code
- 传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态
- 小程序客户端缓存 （通过storage）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可

利用 Unionid 创建用户体系
- 如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式

- 如果户关注了某个相同主体公众号，或曾经在某个相同主体App、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid
- 结合 wx.getUserInfo 和 <button open-type="getUserInfo"><button/> 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践
  - 调用 wx.login 获取 code，然后从微信后端换取到 session_key，用于解密 getUserInfo返回的敏感数据
  - 使用 wx.getSetting 获取用户的授权情况
    - 如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息；
    - 用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息
  - 获取到用户数据后可以进行展示或者发送给自己的后端。

注意事项
- 需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况
```
wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid
```
- 因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间
- 值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如platform，channel，deviceParam等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。
- openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业

#### 图片导出
- 这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。

基本原理
- 借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （api基本和h5保持一致，但有轻微差异，使用时注意即可
- 借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum （需要授权）保存图片到本地

如何优雅实现
- 绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。
- 结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。
```
class CanvasKit {
   constructor() {
   }
   drawImg(option = {}) {
     ...
     return this
   }
   drawRect(option = {}) {
     return this
   }
   drawText(option = {}) {
     ...
     return this
   }
   static exportImg(option = {}) {
     ...
   }
 }

 let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2)
 drawer.exportImg()
```

注意事项
- 小程序中无法绘制网络图片到canvas上，需要通过downLoadFile 先下载图片到本地临时文件才可以绘制
- 通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（32可见字符）限制，可以借助服务端生成 短链接 的方式来解决

#### 数据统计
- 数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点

设计一个埋点sdk
- 小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对Page进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下
```
// 代码仅供理解思路
 page = function(params) {
   let keys = params.keys()
   keys.forEach(v => {
       if (v === 'onLoad') {
         params[v] = function(options) {
           stat()   //曝光埋点代码
           params[v].call(this, options)
         }
       }
       else if (v.includes('click')) {
         params[v] = funciton(event) {
           let data = event.dataset.config
           stat(data)  // 点击埋点
           param[v].call(this)
         }
       }
   })
 }
```
- 这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。

分析接口
- 对于特殊的一些业务，我们可以采取 接口埋点，什么叫接口埋点呢？很多情况下，我们有的api并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。

微信自定义数据分析
- 微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助小程序数据助手这款小程序可以很方便的查看

#### 工程化
工程化做什么
- 目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：

- 不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率
- 不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）
- 不支持ES7等后续的js特性，好用的async await等特性都无法使用
- 不支持引入外部字体文件，只支持base64
- 没有 eslint 等代码检查工具

方案选型
- 对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp非常的适合处理，并且相对于webpack配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp

具体开发思路
- 通过 gulp 的 task 实现：

- 实时编译 less 文件至相应目录
- 引入支持async，await的运行时文件
- 编译字体文件为base64 并生成相应css文件，方便使用
- 依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录
- 检查代码规范

#### 小程序架构
- 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用。

它们在两个线程里运行。
- 视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理

- 视图层使用 WebView 渲染，iOS中使用自带 WKWebView，在 Android 使用腾讯的 x5内核（基于 Blink）运行。
- 逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android中使用腾讯的 x5 内核（基于 Blink）运行。
- 开发工具使用 nw.js 同时提供了视图层和逻辑层的运行环境。

#### WXML&&WXSS
WXML
- 支持数据绑定
- 支持逻辑算术、运算
- 支持模板、引用
- 支持添加事件（bindtap）
- Wxml编译器：Wcc 把 Wxml文件 转为 JS
- 执行方式：Wcc index.wxml
- 使用 Virtual DOM，进行局部更新

WXSS
- wxss编译器：wcsc 把wxss文件转化为 js
- 执行方式： wcsc index.wxss

尺寸单位 rpx
- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。公式：
```
const dsWidth = 750

export const screenHeightOfRpx = function () {
  return 750 / env.screenWidth * env.screenHeight
}

export const rpxToPx = function (rpx) {
  return env.screenWidth / 750 * rpx
}

export const pxToRpx = function (px) {
  return 750 / env.screenWidth * px
}
```

样式导入
- 使用 @import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束

内联样式
- 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度

全局样式与局部样式
- 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器

#### 小程序的问题
- 小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生）
- 服务端接口返回的头无法执行，比如：Set-Cookie。
- 依赖浏览器环境的 JS库不能使用。
- 不能使用 npm，但是可以自搭构建工具或者使用 mpvue。（未来官方有计划支持）
- 不能使用 ES7，可以自己用babel+webpack自搭或者使用 mpvue。
- 不支持使用自己的字体（未来官方计划支持）。
- 可以用 base64 的方式来使用 iconfont。
- 小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。
- 获取二维码/小程序接口的限制
- 程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId，formId 只有7天有效期。（现在的做法是在每个页面都放入form并且隐藏以此获取更多的 formId。后端使用原则为：优先使用有效期最短的）
- 小程序大小限制 2M，分包总计不超过 8M
- 转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）
- 拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制：
  - 50个移动应用
  - 10个网站
  - 50个同主体公众号
  - 5个不同主体公众号
  - 50个同主体小程序
  - 5个不同主体小程序
- 公众号关联小程序
  - 所有公众号都可以关联小程序。
  - 一个公众号可关联10个同主体的小程序，3个不同主体的小程序。
  - 一个小程序可关联500个公众号。
  - 公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。
- 一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转
- 品牌搜索不支持金融、医疗
- 小程序授权需要用户主动点击
- 小程序不提供测试 access_token
- 安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败
- 开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了wx.checkSession，并且在session_key有效期内，授权获取用户信息也会得到新的session_key

#### 授权获取用户信息流程
- session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长
- 在调用 wx.login 时会直接更新 session_key，导致旧 session_key 失效
- 小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序

面试题：先授权获取用户信息再 login 会发生什么？
- 用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key，这时后端服务从开放平台获取到新 session_key，但是无法对老 session_key 加密过的数据解密，用户信息获取失败
- 在用户信息授权之前先调用 wx.checkSession 呢？wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key，从而再一次导致用户信息解密失败

#### 性能优化
- 我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用

加载优化
- 代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小

优化方式
- 代码压缩。
- 及时清理无用代码和资源文件。
- 减少代码包中的图片等资源文件的大小和数量。
- 分包加载。

首屏加载的体验优化建议
- 提前请求: 异步数据请求不需要等待页面渲染完成。
- 利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。
- 避免白屏：先展示页面骨架页和基础内容。
- 及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应

使用分包加载优化
- 在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本，而分包则是根据开发者的配置进行划分
- 在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。

优点：
- 对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务
- 对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能

限制
- 整个小程序所有分包大小不超过 8M
- 单个分包/主包大小不能超过 2M
- 原生分包加载的配置 假设支持分包的小程序目录结构如下
```
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```
开发者通过在 app.json subPackages 字段声明项目分包结构
```
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subPackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```
分包原则
- 声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中
- app（主包）也可以有自己的 pages（即最外层的 pages 字段
- subPackage 的根目录不能是另外一个 subPackage 内的子目录
- 首页的 TAB页面必须在 app（主包）内

引用原则
- ``packageA无法require packageB JS 文件，但可以require app、自己package内的JS` 文件
- ``packageA无法import packageB的template，但可以require app、自己package内的template`
- ``packageA 无法使用packageB的资源，但可以使用app、自己package` 内的资源

```
官方即将推出 分包预加载
```
独立分包

渲染性能优化
- 每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。
- setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。
- setData 是小程序开发使用最频繁，也是最容易引发性能问题的

避免不当使用 setData
- 使用 data 在方法间共享数据，可能增加 setData传输的数据量。。data 应仅包括与页面渲染相关的数据。
- 使用 setData 传输大量数据，通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。仅传输页面中发生变化的数据，使用 setData 的特殊 key实现局部更新。
- 短时间内频繁调用 setData，操作卡顿，交互延迟，阻塞通信，页面渲染延迟。避免不必要的 setData，对连续的setData调用进行合并。
- 在后台页面进行 setData，抢占前台页面的渲染资源。页面切入后台后的 setData 调用，延迟到页面重新展示时执行。

避免不当使用onPageScroll
- 只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。
- 避免在 onPageScroll 中执行复杂逻辑
- 避免在 onPageScroll 中频繁调用 setData
- 避免滑动时频繁查询节点信息（SelectQuery）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（inersectionObserver）替代

使用自定义组件
- 在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响

#### wepy vs mpvue
数据流管理
- 相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 Web 开发中，随着 Flux、Redux、Vuex 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用

- WePY 默认支持 Redux，在脚手架生成项目的时候可以内置
- Mpvue 作为 Vue 的移植版本，当然支持 Vuex，同样在脚手架生成项目的时候可以内置

组件化
- WePY 类似 Vue实现了单文件组件，最大的差别是文件后缀 .wpy，只是写法上会有差异
```
export default class Index extends wepy.page {}
```
- Mpvue 作为 Vue 的移植版本，支持单文件组件，template、script 和 style 都在一个 .vue 文件中，和 vue 的写法类似，所以对 Vue 开发熟悉的同学会比较适应

工程化
- 所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具

- wepy 内置了构建，通过 wepy init 命令初始化项目，大致流程如下：
  - wepy-cli 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 3 步，反之继续进行。
  - 会从远程仓库下载模版，并保存到本地。
  - 询问开发者 Project name 等问题，依据开发者的回答，创建项目
- mpvue 沿用了 vue 中推崇的 webpack作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如
  - 不再需要 html-webpack-plugin
  - 基于 webpack-dev-middleware 修改成 webpack-dev-middleware-hard-disk
  - 最大的变化是基于 webpack-loader 修改成 mpvue-loader
  - 但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀

#### mpvue
mpvue
- Vue.js 小程序版, fork 自 vuejs/vue@2.4.1，保留了 vue runtime 能力，添加了小程序平台的支持。 mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验

框架原理
两个大方向：
- 通过mpvue提供 mp 的 runtime 适配小程序
- 通过mpvue-loader产出微信小程序所需要的文件结构和模块内容

七个具体问题：
- 要了解 mpvue 原理必然要了解 Vue 原理，这是大前提
现在假设您对 Vue 原理有个大概的了解
- 由于 Vue 使用了 Virtual DOM，所以 Virtual DOM可以在任何支持 JavaScript 语言的平台上操作，譬如说目前 Vue 支持浏览器平台或 weex，也可以是 mp(小程序)。那么最后 Virtual DOM 如何映射到真实的 DOM节点上呢？vue为平台做了一层适配层，浏览器平台见 runtime/node-ops.js、weex平台见runtime/node-ops.js，小程序见runtime/node-ops.js。不同平台之间通过适配层对外提供相同的接口，Virtual DOM进行操作Real DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变
- 所以思路肯定是往增加一个 mp 平台的 runtime方向走。但问题是小程序不能操作 DOM，所以 mp 下的node-ops.js里面的实现都是直接 return obj
- 新 Virtual DOM 和旧 Virtual DOM 之间需要做一个 patch，找出 diff。patch完了之后的 diff 怎么更新视图，也就是如何给这些 DOM 加入 attr、class、style等 DOM 属性呢？ Vue中有 nextTick 的概念用以更新视图，mpvue这块对于小程序的 setData 应该怎么处理呢？
- 另外个问题在于小程序的 Virtual DOM 怎么生成？也就是怎么将 template编译成render function。这当中还涉及到运行时-编译器-vs-只包含运行时，显然如果要提高性能、减少包大小、输出 wxml、mpvue 也要提供预编译的能力。因为要预输出 wxml 且没法动态改变 DOM，所以动态组件，自定义 render，和<script type="text/x-template">字符串模版等都不支持

另外还有一些其他问题，最后总结一下
- 1.如何预编译生成render function
- 2.如何预编译生成 wxml，wxss，wxs
- 3.如何 patch 出 diff
- 4.如何更新视图
- 5.如何建立小程序事件代理机制，在事件代理函数中触发与之对应的vue组件事件响应
- 6.如何建立vue实例与小程序 Page实例关联
- 7.如何建立小程序和vue生命周期映射关系，能在小程序生命周期中触发vue生命周期
```
platform/mp的目录结构
```
```
.
├── compiler //解决问题1，mpvue-template-compiler源码部分
├── runtime //解决问题3 4 5 6 7
├── util //工具方法
├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。
├── entry-runtime.js //对外提供Vue对象，当然是mpvue
└── join-code-in-build.js //编译出SDK时的修复
```
mpvue-loader
- mpvue-loader 是 vue-loader 的一个扩展延伸版，类似于超集的关系，除了vue-loader 本身所具备的能力之外，它还会利用mpvue-template-compiler生成render function

entry
- 它会从 webpack 的配置中的 entry 开始，分析依赖模块，并分别打包。在entry 中 app 属性及其内容会被打包为微信小程序所需要的 app.js／app.json／app.wxss，其余的会生成对应的
- 页面page.js/page.json/page.wxml/page.wxss，如示例的 entry 将会生成如下这些文件，文件内容下文慢慢讲来：
```
// webpack.config.js
{
    // ...
    entry: {
        app: resolve('./src/main.js'),               // app 字段被识别为 app 类型
        index: resolve('./src/pages/index/main.js'),   // 其余字段被识别为 page 类型
        'news/home': resolve('./src/pages/news/home/index.js')
    }
}

// 产出文件的结构
.
├── app.js
├── app.json
├──· app.wxss
├── components
│   ├── card$74bfae61.wxml
│   ├── index$023eef02.wxml
│   └── news$0699930b.wxml
├── news
│   ├── home.js
│   ├── home.wxml
│   └── home.wxss
├── pages
│   └── index
│       ├── index.js
│       ├── index.wxml
│       └── index.wxss
└── static
    ├── css
    │   ├── app.wxss
    │   ├── index.wxss
    │   └── news
    │       └── home.wxss
    └── js
        ├── app.js
        ├── index.js
        ├── manifest.js
        ├── news
        │   └── home.js
        └── vendor.js
```
- wxml 每一个 .vue 的组件都会被生成为一个 wxml 规范的 template，然后通过 wxml 规范的 import 语法来达到一个复用，同时组件如果涉及到 props的 data 数据，我们也会做相应的处理，举个实际的例子：
```
<template>
    <div class="my-component" @click="test">
        <h1>{{msg}}</h1>
        <other-component :msg="msg"></other-component>
    </div>
</template>
<script>
import otherComponent from './otherComponent.vue'

export default {
  components: { otherComponent },
  data () {
    return { msg: 'Hello Vue.js!' }
  },
  methods: {
    test() {}
  }
}
</script>
```
这样一个 Vue的组件的模版部分会生成相应的 wxml
```
<import src="components/other-component$hash.wxml" />
<template name="component$hash">
    <view class="my-component" bindtap="handleProxy">
        <view class="_h1">{{msg}}</view>
        <template is="other-component$hash" wx:if="{{ $c[0] }}" data="{{ ...$c[0] }}"></template>
    </view>
</template>
```
- 可能已经注意到了 other-component(:msg="msg") 被转化成了 。mpvue 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 setData 到 appData,$c是 $children 的缩写。至于那个 0 则是我们的 compiler处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下
```
// 这儿数据结构是一个数组，index 是动态的
{
  $child: {
    '0'{
      // ... root data
      $child: {
        '0': {
          // ... data
          msg: 'Hello Vue.js!',
          $child: {
            // ...data
          }
        }
      }
    }
  }
}
```
wxss
- 这个部分的处理同 web 的处理差异不大，唯一不同在于通过配置生成 .css 为 .wxss ，其中的对于 css的若干处理，在 postcss-mpvue-wxss 和 px2rpx-loader 这两部分的文档中又详细的介绍

- 推荐和小程序一样，将 app.json／page.json 放到页面入口处，使用 copy-webpack-plugin copy 到对应的生成位置。

- 这部分内容来源于 app 和page 的entry 文件，通常习惯是 main.js，你需要在你的入口文件中 export default { config: {} }，这才能被我们的 loader 识别为这是一个配置，需要写成 json 文件
```
import Vue from 'vue';
import App from './app';

const vueApp = new Vue(App);
vueApp.$mount();

// 这个是我们约定的额外的配置
export default {
    // 这个字段下的数据会被填充到 app.json ／ page.json
    config: {
        pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack
        window: {
            backgroundTextStyle: 'light',
            navigationBarBackgroundColor: '##455A73',
            navigationBarTitleText: '美团汽车票',
            navigationBarTextStyle: '##fff'
        }
    }
};
```



- [Bootstrap](#Bootstrap)
  - [](#)  1 什么是Bootstrap？以及为什么要使用Bootstrap？
  - [](#)  2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？
  - [](#)  3 什么是Bootstrap网格系统
  - [](#)  4 Bootstrap 网格系统（Grid System）的工作原理
  - [](#)  5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么
  - [](#)  6 Bootstrap 网格系统列与列之间的间隙宽度是多少
  - [](#)  7 如果需要在一个标题的旁边创建副标题，可以怎样操作
  - [](#)  8 用Bootstrap，如何设置文字的对齐方式？
  - [](#)  9 Bootstrap如何设置响应式表格？
  - [](#)  10 使用Bootstrap创建垂直表单的基本步骤？
  - [](#)  11 使用Bootstrap创建水平表单的基本步骤？
  - [](#)  12 使用Bootstrap如何创建表单控件的帮助文本？
  - [](#)  13 使用Bootstrap激活或禁用按钮要如何操作？
  - [](#)  14 Bootstrap有哪些关于的class？
  - [](#)  15 Bootstrap中有关元素浮动及清除浮动的class？
  - [](#)  16 除了屏幕阅读器外，其他设备上隐藏元素的class？
  - [](#)  17 Bootstrap如何制作下拉菜单？
  - [](#)  18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？
  - [](#)  19 Bootstrap如何设置按钮的下拉菜单？
  - [](#)  20 Bootstrap中的输入框组如何制作？
  - [](#)  21 Bootstrap中的导航都有哪些？
  - [](#)  22 Bootstrap中设置分页的class？
  - [](#)  23 Bootstrap中显示标签的class？
  - [](#)  24 Bootstrap中如何制作徽章？
  - [](#)  25 Bootstrap中超大屏幕的作用是什么？














### GIT
#### git与svn的区别在哪里
   ```
   git 和 svn 最大的区别在于 git 是分布式的，而 svn 是
   集中式的。因此我们不能再离线的情况下使用 svn。如果服务器
   出现问题，我们就没有办法使用 svn 来提交我们的代码。

   svn 中的分支是整个版本库的复制的一份完整目录，而 git 的
   分支是指针指向某次提交，因此 git 的分支创建更加开销更小
   并且分支上的变化不会影响到其他人。svn 的分支变化会
   影响到所有的人。

   svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。
   ```

#### 经常使用的git命令
   ```
   git init                     // 新建 git 代码库
   git add                      // 添加指定文件到暂存区
   git rm                       // 删除工作区文件，并且将这次删除放入暂存区
   git commit -m [message]      // 提交暂存区到仓库区
   git branch                   // 列出所有分支
   git checkout -b [branch]     // 新建一个分支，并切换到该分支
   git status                   // 显示有变更的文件
   ```

#### git pull和git fetch的区别
   ```
   git fetch 只是将远程仓库的变化下载下来，
   并没有和本地分支合并。

   git pull 会将远程仓库的变化下载下来，并和当前分支合并。
   ```

#### git rebase和git merge的区别
   ```
   git merge 和 git rebase 都是用于分支合并，
   关键在 commit 记录的处理上不同。

   git merge 会新建一个新的 commit 对象，然后两个分支
   以前的 commit 记录都指向这个新 commit 记录。
   这种方法会保留之前每个分支的 commit 历史。

   git rebase 会先找到两个分支的第一个共同的 commit 
   祖先记录，然后将提取当前分支这之后的所有 commit 记录，
   然后将这个 commit 记录添加到目标分支的最新提交后面。
   经过这个合并后，两个分支合并后的 commit 记录
   就变为了线性的记录了。
   ```

   
   
   
   
   
   
   
   
   
   
   
   
   
 
