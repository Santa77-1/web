## 框架 面试知识点总结
整理了 VUE、React、jQuery、Node、webpack、Bootstrap、Git工具 面试的部分知识点

### 目录
- [为什么用前端框架](#为什么用前端框架)

- [VUE](#VUE)
  - [vue的生命周期函数](#vue的生命周期函数)
  - [简述每个周期具体适合哪些场景](#简述每个周期具体适合哪些场景)
  - [vue组件间传递参数、传值通信](#vue组件间传递参数传值通信)
  - [Vue中父子组件生命周期执行顺序](#vue中父子组件生命周期执行顺序)
  - [vue双向数据绑定原理](#vue双向数据绑定原理)
  - [v-model双向绑定原理](#v-model双向绑定原理)
  - [v-model中的实现原理及如何自定义v-model](#v-model中的实现原理及如何自定义v-model)
  - [Vue是如何实现双向绑定的](#Vue是如何实现双向绑定的)
  - [vuex](#vuex)
  - [MVVM](#MVVM)
  - [MVVM和MVC的区别](#mvvm和mvc的区别)
  - [vue的优点](#vue的优点)
  - [Vue.js特点](#Vuejs特点)
  - [开发中常用的指令有哪些](#开发中常用的指令有哪些)
  - [vue的响应式原理](#vue的响应式原理)
  - [发布订阅模式和观察者模式](#发布订阅模式和观察者模式)
  - [Object.defineProperty介绍](#objectdefineproperty介绍)
  - [Vue的响应式原理中Object.defineProperty有什么缺陷](#Vue的响应式原理中ObjectdefineProperty有什么缺陷)
  - [使用Object.defineProperty()来进行数据劫持有什么缺点](#使用objectdefineproperty来进行数据劫持有什么缺点)
  - [v-if和v-show的区别](#v-if和v-show的区别)
  - [vue中created和mounted区别](#vue中created和mounted区别)
  - [vue中data和computed区别](#vue中data和computed区别)
  - [vue中watch和computed区别](#vue中watch和computed区别)
  - [vue中methods,watch和computer区别](#vue中methodswatch和computer区别)
  - [为什么vue组件中的data必须是函数](#为什么vue组件中的data必须是函数)
  - [vue的activated和deactivated钩子函数](#vue的activated和deactivated钩子函数)
  - [nextTick用法](#nexttick用法)
  - [vue中key属性的作用](#vue中key属性的作用)
  - [Vue中key属性用index为什么不行](#vue中key属性用index为什么不行)
  - [路由原理](#路由原理)
  - [Vue的路由模式](#vue的路由模式)
  - [Vue的路由实现：hash模式和history模式](#Vue的路由实现hash模式和history模式)
  - [Vue中hash模式和history模式的区别](#Vue中hash模式和history模式的区别)
  - [了解history有哪些方法吗？说下它们的区别](#了解history有哪些方法吗说下它们的区别)
  - [vue路由的钩子函数](#vue路由的钩子函数)
  - [路由之间跳转](#路由之间跳转)
  - [vue路由传参数](#vue路由传参数)
  - [vue中$router和$route的区别](#vue中router和route的区别)
  - [vue3带来的新特性/亮点](#vue3带来的新特性亮点)
  - [VDOM：三个part](#VDOM三个part)
  - [虚拟DOM(Virtual Dom)](#虚拟DOMVirtual-Dom)
  - [为什么使用虚拟DOM(Virtual DOM)](#为什么使用虚拟DOMVirtual-DOM)
  - [Compositon api](#Compositon-api)
  - [Vue diff算法详解](#vue-diff算法详解)
  - [移动端适配的方法](#移动端适配的方法)
  - [rem原理](#rem-原理)
  - [rem和em的区别](#rem和em的区别)
  - [移动端300ms延迟的原因以及解决方案](#移动端300ms延迟的原因以及解决方案)
  - [vue和react技术选型](#vue和react技术选型)
  - [Vue和React数据驱动的区别](#vue和react数据驱动的区别)
  - [如何让CSS只在当前组件中起作用](#如何让CSS只在当前组件中起作用)
  - [<keep-alive></keep-alive>的作用是什么](#keep-alivekeep-alive的作用是什么)
  - [指令v-el的作用是什么](#指令v-el的作用是什么)
  - [在Vue中使用插件的步骤](#在Vue中使用插件的步骤)
  - [请列举出3个Vue中常用的生命周期钩子函数](#请列举出3个Vue中常用的生命周期钩子函数)
  - [vue-cli工程技术集合介绍](#vue-cli工程技术集合介绍)
  - [实现Vue SSR](#实现Vue-SSR)
  - [Vue组件data为什么必须是函数](#Vue组件data为什么必须是函数)
  - [Vue computed实现](#Vue-computed实现)
  - [Vue complier实现](#Vue-complier实现)
  - [怎么快速定位哪个组件出现性能问题](#怎么快速定位哪个组件出现性能问题)
  - [Proxy相比于defineProperty的优势](#Proxy相比于defineProperty的优势)
  - [vue-router有哪几种导航守卫](#vue-router有哪几种导航守卫)
  - [Vue与Angular以及React的区别](#Vue与Angular以及React的区别)
  - [scoped样式穿透](#scoped样式穿透)
  - [ref的作用](#ref的作用)
  - [vue-router守卫](#vue-router守卫)
  - [vue修饰符](#vue修饰符)
  - [vue项目中的性能优化](#vue项目中的性能优化)
  - [Vue性能优化](#Vue性能优化)
  - [vue.extend和vue.component](#vueextend和vuecomponent)
  - [Vue的SPA如何优化加载速度](#Vue的SPA如何优化加载速度)
  - [移动端如何设计一个比较友好的Header组件](#移动端如何设计一个比较友好的Header组件)
  - [你是如何理解Vue的响应式系统的](#你是如何理解Vue的响应式系统的)
  - [既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异](#既然Vue通过数据劫持可以精准探测数据变化为什么还需要虚拟DOM进行diff检测差异)
  - [Vue为什么没有类似于React中shouldComponentUpdate的生命周期](#Vue为什么没有类似于React中shouldComponentUpdate的生命周期)
  - [说一下vue2.x中如何监测数组变化](#说一下vue2x中如何监测数组变化)
  - [vue中是如何检测数组变化的呢](#vue中是如何检测数组变化的呢)
  - [你的接口请求一般放在哪个生命周期中](#你的接口请求一般放在哪个生命周期中)
  - [Vue事件绑定原理说一下](#Vue事件绑定原理说一下)
  - [Vue模版编译原理知道吗，能简单说一下吗](#Vue模版编译原理知道吗能简单说一下吗)
  - [Vue2.x和Vue3.x渲染器的diff算法分别说一下](#Vue2x和Vue3x渲染器的diff算法分别说一下)
  - [再说一下虚拟Dom以及key属性的作用](#再说一下虚拟Dom以及key属性的作用)
  - [请说出vue.cli项目中src目录每个文件夹和文件的用法](#请说出vuecli项目中src目录每个文件夹和文件的用法)
  - [delete和Vue.delete删除数组的区别](#delete和Vuedelete删除数组的区别)
  - [v-on可以监听多个方法吗](#v-on可以监听多个方法吗)
  - [vue如何兼容ie的问题](#vue如何兼容ie的问题)
  - [Vue改变数组触发视图更新](#Vue改变数组触发视图更新)
  - [DOM渲染在哪个周期中就已经完成](#DOM渲染在哪个周期中就已经完成)
  - [动态绑定class](#动态绑定class)
  - [Vue3.0是如何变得更快的](#Vue30是如何变得更快的)
  - [说说你对proxy的理解](#说说你对proxy的理解)
  - [Composition API](#Composition-API)
  - [为什么Vue采用异步渲染呢](#为什么Vue采用异步渲染呢)
  - [Vuex工作原理](#Vuex工作原理)
  - [如何从真实DOM到虚拟DOM](#如何从真实DOM到虚拟DOM)
  - [为什么要使用异步组件](#为什么要使用异步组件)
  - [action与mutation的区别](#action与mutation的区别)
  - [插槽与作用域插槽的区别](#插槽与作用域插槽的区别)
  - [vue中相同逻辑如何抽离](#vue中相同逻辑如何抽离)
  - [谈谈对keep-alive的了解](#谈谈对keep-alive的了解)
  - [Vue3.0相对于Vue2.x有哪些不同](#Vue30相对于Vue2x有哪些不同)
  - [如何监听pushState和replaceState的变化呢](#如何监听pushState和replaceState的变化呢)
  - [Vue组件内的导航守卫有哪几个](#Vue组件内的导航守卫有哪几个)
  - [beforeRouteEnter和另外两个有什么不同吗](#beforeRouteEnter和另外两个有什么不同吗)
  - [完整的导航解析流程](#完整的导航解析流程)
  - [你是怎么看Vue和React的](#你是怎么看Vue和React的)



- [React](#React)
  - [React生命周期](#React生命周期)
  - [组件之间通信](#组件之间通信)
  - [组件的渲染顺序](#组件的渲染顺序)
  - [React组件和渲染更新过程](#React组件和渲染更新过程)
  - [React都做过哪些优化](#React都做过哪些优化)
  - [React有哪些优化性能的手段](#React有哪些优化性能的手段)
  - [diff算法是怎么运作](#diff算法是怎么运作)
  - [React router](#React router)
  - [](#)  18 redux 中间件
  - [](#)  14 Redux实现原理解析
  - [](#)  17 聊聊 Redux 和 Vuex 的设计思想
  - [](#)  19 redux数据管理
  - [](#)  3. React Fiber是什么
  - [](#)  2 React Fiber架构
  - [](#)  5 React Fiber架构总结
  - [](#)  7 React事务机制
  - [](#)  2. 浏览器一帧都会干些什么以及requestIdleCallback的启示
  - [](#)  3 createElement过程
  - [](#)  5 setState
  - [](#)  6 setState原理分析
  - [](#)  4 调和阶段 setState内部干了什么
  - [](#)  22 如何避免ajax数据请求重新获取
  - [](#)  12 为什么 React 元素有一个 $$typeof 属性
  - [](#)  10 合成事件原理
  - [](#)  16 react hooks，它带来了那些便利
  - [](#)  15 connect组件原理分析
  - [](#)  11 JSX语法糖本质
  - [](#)  20 受控组件和非受控组件
  - [](#)  21 SSR原理



- [jQuery](#jQuery)
  - [针对jQuery的优化方法](#针对jQuery的优化方法)
  - [](#)  2 jQuery 的实现原理
  - [](#)  12 针对 jQuery 的优化方法
  - [](#)  17 jQuery对象的特点
  - [](#)  1 你觉得jQuery或zepto源码有哪些写的好的地方
  - [](#)  11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的
  - [](#)  5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝
  - [](#)  6 jQuery 的队列是如何实现的
  - [](#)  10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来
  - [](#)  9 jQuery 通过哪个方法和 Sizzle 选择器结合的
  - [](#)  3 jQuery.fn 的 init 方法返回的 this 指的是什么对象
  - [](#)  4 jQuery.extend 与 jQuery.fn.extend 的区别
  - [](#)  7 jQuery 中的 bind(), live(), delegate(), on()的区别
  - [](#)  8 是否知道自定义事件
  - [](#)  14 jQuery UI 如何自定义组件
  - [](#)  15 jQuery 与 jQuery UI、jQuery Mobile 区别
  - [](#)  13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢
  - [](#)  16 jQuery 和 Zepto 的区别？ 各自的使用场景


- [webpack相关](#webpack相关)
  - [webpack原理简述](#webpack原理简述)
    - [核心概念](#核心概念)
    - [工作流程(加载-编译-输出)](#工作流程加载-编译-输出)
    - [模块包装](#模块包装)
    - [webpack的打包原理](#webpack的打包原理)
    - [总结](#总结)
  - [webpack热更新原理](#webpack热更新原理)
  - [webpack Loader](#webpack-Loader)
  - [webpack Plugin](#webpack-Plugin)
  - [webpack编译优化](#webpack编译优化)
    - [优化webpack打包速度](#优化webpack打包速度)
  - [webpack import()原理](#webpack-import原理)
    - [动态导入原理](#动态导入原理)
    - [webpack中如何实现动态导入](#webpack中如何实现动态导入)
  - [webpack有哪几种文件指纹](#webpack有哪几种文件指纹)
    - [webpack如果使用了hash命名，那是每次都会重写生成hash吗](#webpack如果使用了hash命名那是每次都会重写生成hash吗)
    - [webpack中如何处理图片的](#webpack中如何处理图片的)
  - [webpack常用插件总结](#webpack常用插件总结)
  - [抽象语法树AST](#抽象语法树AST)
  - [使用babel-loader会有哪些问题？可以怎样优化](#使用babelloader会有哪些问题可以怎样优化)
  - [Babel原理](#Babel原理)
  - [Babel是如何编译Class的](#Babel是如何编译Class的)
  - [babel-polyfill是什么](#babel-polyfill是什么)
  - [Tree Shaking原理是什么](#Tree-Shaking原理是什么)
  - [Vite了解吗](#Vite了解吗)
  - [](#)  1 打包体积 优化思路
  - [](#)  2 打包效率
  - [](#)  3 Loader
  - [](#)  4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化


- [Node](#Node)
  - [package.json版本号规则](#packagejson版本号规则)
  - [npm模块安装机制](#npm模块安装机制)
  - [模块化的差异AMD CMD COMMONJS ESMODULE](#模块化的差异AMD-CMD-COMMONJS-ESMODULE)
  - [Node的Event Loop:6个阶段](#Node的Event-Loop6个阶段)
  - [Koa相关](#Koa相关)
  - [Express、koa实现原理以及对比](#Expresskoa实现原理以及对比)


- [微信小程序](#小程序)
  - [登录](#登录)
  - [图片导出](#图片导出)
  - [数据统计](#数据统计)
  - [工程化](#工程化)
  - [小程序架构](小程序架构)
  - [WXML&&WXSS](#WXMLWXSS)
  - [小程序的问题](#小程序的问题)
  - [授权获取用户信息流程](#授权获取用户信息流程)
  - [性能优化](#性能优化)
  - [wepy vs mpvue](#wepy-vs-mpvue)
  - [mpvue](#mpvue)
  - [](#)  5 微信小程序与vue区别
  - [](#)  1 微信小程序有几个文件
  - [](#)  2 微信小程序怎样跟事件传值
  - [](#)  3 小程序的 wxss 和 css 有哪些不一样的地方？
  - [](#)  4 小程序关联微信公众号如何确定用户的唯一性



- [Bootstrap](#Bootstrap)
  - [](#)  1 什么是Bootstrap？以及为什么要使用Bootstrap？
  - [](#)  2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？
  - [](#)  3 什么是Bootstrap网格系统
  - [](#)  4 Bootstrap 网格系统（Grid System）的工作原理
  - [](#)  5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么
  - [](#)  6 Bootstrap 网格系统列与列之间的间隙宽度是多少
  - [](#)  7 如果需要在一个标题的旁边创建副标题，可以怎样操作
  - [](#)  8 用Bootstrap，如何设置文字的对齐方式？
  - [](#)  9 Bootstrap如何设置响应式表格？
  - [](#)  10 使用Bootstrap创建垂直表单的基本步骤？
  - [](#)  11 使用Bootstrap创建水平表单的基本步骤？
  - [](#)  12 使用Bootstrap如何创建表单控件的帮助文本？
  - [](#)  13 使用Bootstrap激活或禁用按钮要如何操作？
  - [](#)  14 Bootstrap有哪些关于的class？
  - [](#)  15 Bootstrap中有关元素浮动及清除浮动的class？
  - [](#)  16 除了屏幕阅读器外，其他设备上隐藏元素的class？
  - [](#)  17 Bootstrap如何制作下拉菜单？
  - [](#)  18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？
  - [](#)  19 Bootstrap如何设置按钮的下拉菜单？
  - [](#)  20 Bootstrap中的输入框组如何制作？
  - [](#)  21 Bootstrap中的导航都有哪些？
  - [](#)  22 Bootstrap中设置分页的class？
  - [](#)  23 Bootstrap中显示标签的class？
  - [](#)  24 Bootstrap中如何制作徽章？
  - [](#)  25 Bootstrap中超大屏幕的作用是什么？


- [GIT](#git)
  - [git与svn的区别在哪里](#git与svn的区别在哪里)
  - [经常使用的git命令](#经常使用的git命令)
  - [git pull和git fetch的区别](#git-pull和git-fetch的区别)
  - [git rebase和git merge的区别](#git-rebase和git-merge的区别)







### 为什么用前端框架
- 1.前端框架是为了解决什么问题?
  - 前端要做的工作无非就是根据用户的操作将相应的数据展示到视图中。
  - 为保证状态与UI同步，前端工作人员除了将精力放在业务逻辑上，还需要将大量的精力放在操作DOM上。
  - 频繁的操作DOM，这样的结果导致了代码臃肿，不易维护，容易出错，且浏览器渲染开销大。
  - 为了解决UI与状态同步的问题，出现了前端框架。
  - 前端框架帮助我们减少DOM的操作，同时提高了渲染页面的性能。

- 2.DOM的操作昂贵在什么地方?
  - 访问dom的费用高，比较耗时。而且读取dom集合的length比数组消耗大很多。
  - 修改dom引起重排跟重绘，会伴随着重新渲染的巨大代价。

- 3.渲染引擎的工作流程
  - 解析HTML构建dom树=>构建渲染树=>渲染树布局=>绘制渲染树

- 4.什么是重绘和重排？
  - 重排：如果页面元素位置发生变化，就要从布局阶段重新开始渲染，也就是页面重排。页面重排一定会进行后续重绘。
  - 重绘：如果页面元素只是显示样式改变而布局不变，那么页面内容将会从绘制阶段开始。

- 5.什么情况下触发重排？
  - 修改dom元素的几何属性，dom树结构发生变化，改变浏览器大小等会触发重排的操作。


### VUE

  #### vue的生命周期函数
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

生命周期是什么
```
Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、
编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，
我们称这是Vue的生命周期
```

各个生命周期的作用
- 生命周期	描述
- beforeCreate	组件实例被创建之初，组件的属性生效之前
- created	组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用
- beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用
- mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
- beforeUpdate	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前
- update	组件数据更新之后
- activited	keep-alive专属，组件被激活时调用
- deadctivated	keep-alive专属，组件被销毁时调用
- beforeDestory	组件销毁前调用
- destoryed	组件销毁后调用

```
由于Vue会在初始化实例时对属性执行getter/setter转化，
所以属性必须在data对象上存在才能让Vue将它转换为响应式的。
Vue提供了$set方法用来触发视图更新

export default {
    data(){
        return {
            obj: {
                name: 'fei'
            }
        }
    },
    mounted(){
        this.$set(this.obj, 'sex', 'man')
    }

}
```

什么是vue生命周期？
- Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

vue生命周期的作用是什么？
- 它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

vue生命周期总共有几个阶段？
- 它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。

第一次页面加载会触发哪几个钩子？
- 会触发下面这几个beforeCreate、created、beforeMount、mounted 。

DOM 渲染在哪个周期中就已经完成？
- DOM 渲染在 mounted 中就已经完成了

```
beforeCreate:
在实例初始化之后，数据观测 (data observer) 和 event/watcher 
事件配置之前被调用。

在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西
都还没创建。在beforeCreate生命周期执行的时候，data和methods中的
数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法

created:
在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：
数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。
然而，挂载阶段还没开始，\$el property 目前尚不可用。

data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，
或者操作 data 中的数据，最早可以在这个阶段中操作

beforeMount:
在挂载开始之前被调用：相关的 render 函数首次被调用。

执行到这个钩子的时候，在内存中已经编译好了模板了，
但是还没有挂载到页面中，此时，页面还是旧的

mounted:
实例被挂载后调用，这时 el 被新创建的 vm.\$el 替换了。
如果根实例挂载到了一个文档内的元素上，
当 mounted 被调用时 vm.\$el 也在文档内。

执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件
脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作
页面上的DOM节点，最早可以在这个阶段中进行

beforeUpdate:
当执行这个钩子时，页面中的显示的数据还是旧的，
data中的数据是更新后的， 页面还没有和最新的数据保持同步

updated:
页面显示的数据和data中的数据已经保持同步了，都是最新的

beforeDestroy:
Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 
methods，指令，过滤器……都是处于可用状态，还没有真正被销毁

destroyed:
这个时候上所有的 data 和 methods，指令，过滤器……
都是处于不可用状态，组件已经被销毁了。

activated:
被 `keep-alive` 缓存的组件激活时调用。

deactivated:
被 `keep-alive` 缓存的组件停用时调用。
```

```
init：
1.initLifecycle/Event，往vm上挂载各种属性
2.callHook: beforeCreated: 实例刚创建
3.initInjection/initState: 初始化注入和 data 响应性
4.created: 创建完成，属性已经绑定， 但还未生成真实dom`
5.进行元素的挂载： $el / vm.$mount()
6.是否有template: 解析成 render function
    *.vue文件: vue-loader会将<template>编译成render function
7.beforeMount: 模板编译/挂载之前
8.执行render function，生成真实的dom，并替换到dom tree中
9.mounted: 组件已挂载

update：
1.执行diff算法，比对改变是否需要触发UI更新
2.flushScheduleQueue
3.watcher.before: 触发beforeUpdate钩子 - watcher.run(): 
  执行watcher中的 notify，通知所有依赖项更新UI
4.触发updated钩子: 组件已更新
5.actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活
6.destroy
  beforeDestroy: 销毁开始
  销毁自身且递归销毁子组件以及事件监听
    remove(): 删除节点
    watcher.teardown(): 清空依赖
    vm.$off(): 解绑监听
  destroyed: 完成后触发钩子
  
  
Vue2和Vue3对比：
Vue2	                  Vue3
beforeCreate	          setup(替代)
created	                setup(替代)
beforeMount	            onBeforeMount
mounted	                onMounted
beforeUpdate           	onBeforeUpdate
updated	                nUpdated
beforeDestroy	          onBeforeUnmount
destroyed	              onUnmounted
errorCaptured          	onErrorCaptured
-	                      onRenderTracked
-	                      onRenderTriggered


上面是vue的声明周期的简单梳理，
接下来我们直接以代码的形式来完成vue的初始化：
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```

#### 生命周期详解
init
- initLifecycle/Event，往vm上挂载各种属性
- callHook: beforeCreated: 实例刚创建
- initInjection/initState: 初始化注入和 data 响应性
- created: 创建完成，属性已经绑定， 但还未生成真实dom`
- 进行元素的挂载： $el / vm.$mount()
- 是否有template: 解析成 render function
  - *.vue文件: vue-loader会将<template>编译成render function
- beforeMount: 模板编译/挂载之前
- 执行render function，生成真实的dom，并替换到dom tree中
- mounted: 组件已挂载

update
- 执行diff算法，比对改变是否需要触发UI更新
- flushScheduleQueue
- watcher.before: 触发beforeUpdate钩子 - watcher.run(): 执行watcher中的 notify，通知所有依赖项更新UI
- 触发updated钩子: 组件已更新
- actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活
- destroy
  - beforeDestroy: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听
    - remove(): 删除节点
    - watcher.teardown(): 清空依赖
    - vm.$off(): 解绑监听
  - destroyed: 完成后触发钩子

- 上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化
```
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```

  #### 简述每个周期具体适合哪些场景
- beforecreate : 可以在这加个loading事件，在加载实例时触发
- created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
- mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数
- beforeDestroy : 可以做一个确认停止事件的确认框

> 第一次加载会触发哪几个钩子
> 会触发beforeCreate , created ,beforeMount ,mounted
  
  #### vue组件间传递参数、传值通信
> 组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯

父组件与子组件传值
- 父组件传给子组件：子组件通过props方法接受数据；
- 子组件传给父组件： $emit 方法传递参数

非父子组件间的数据传递，兄弟组件传值
- eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求）


- 1. 父组件给子组件传值
使用props，父组件可以使用props向子组件传递数据。
```
父组件vue模板father.vue:
<template>
    <child :msg="message"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    data () {
        return {
            message: 'father message';
        }
    }
}
</script>
```

子组件vue模板child.vue:
```
<template>
    <div>{{msg}}</div>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    }
}
</script>
```

- 2. 子组件向父组件通信
父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件
```
父组件vue模板father.vue:
<template>
    <child @msgFunc="func"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    methods: {
        func (msg) {
            console.log(msg);
        }
    }
}
</script>
```

子组件vue模板child.vue:
```
<template>
    <button @click="handleClick">点我</button>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    methods () {
        handleClick () {
            //........
            this.$emit('msgFunc');
        }
    }
}
</script>
```

- 3. 非父子, 兄弟组件之间通信
```
vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以
用props和$emit()。如何实现非父子组件间的通信，可以通过实例
一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，
然后通过分别调用Bus事件触发和监听来实现通信和参数传递。

Bus.js可以是这样:
import Vue from 'vue'
export default new Vue()
```

在需要通信的组件都引入Bus.js:
```
<template>
	<button @click="toBus">子组件传给兄弟组件</button>
</template>

<script>
import Bus from '../common/js/bus.js'
export default{
	methods: {
	    toBus () {
	        Bus.$emit('on', '来自兄弟组件')
	    }
	  }
}
</script>
```

另一个组件也import Bus.js 在钩子函数中监听on事件
```
import Bus from '../common/js/bus.js'
export default {
    data() {
      return {
        message: ''
      }
    },
    mounted() {
       Bus.$on('on', (msg) => {
         this.message = msg
       })
     }
   }
```

Vue子组件调用父组件的方法
- 第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法
- 第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。
  
  #### Vue中父子组件生命周期执行顺序
```
在单一组件中，钩子的执行顺序是
beforeCreate-> created -> mounted->... ->destroyed
```

父子组件生命周期执行顺序：

加载渲染过程
  ```txt
  父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
  ```

更新过程
  ```txt
  父beforeUpdate->子beforeUpdate->子updated->父updated
  ```

销毁过程
  ```txt
  父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
  ```

常用钩子简易版
  ```txt
  父create->子created->子mounted->父mounted
  ```

  #### vue双向数据绑定原理
```
vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。
vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

首先我们通过 Object.defineProperty() 方法来对 Model 数据各个
属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据
发生变化的时候，我们可以通过配置的 setter 和 getter 方法来
实现对 View 层数据更新的通知。

数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 
value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。

如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中
去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。
然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化
的时候触发该事件，通知 Model 中的对应的属性的值进行更新。

如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来
替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，
属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象
加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，
Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，
订阅者收到通知后更改自己的数据。
```

```
vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，
通过 Object.defineProperty() 来劫持各个属性的setter，getter，
在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 
Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历
它的属性，用 Object.defineProperty() 将它们转为 getter/setter。
用户看不到 getter/setter，但是在内部它们让 Vue追踪依赖，
在属性被访问和修改时通知变化。
vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，
Compile和Watcher三者，通过Observer来监听自己的model的数据变化，
通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终
利用watcher搭起observer和Compile之间的通信桥梁，达到数据
变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
```
  
  #### v-model双向绑定原理
- v-model本质上是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件

- text 和 textarea 元素使用 value 属性和 input 事件
- checkbox 和 radio 使用 checked 属性和 change 事件
- select 字段将 value 作为 prop 并将 change 作为事件

所以我们可以v-model进行如下改写：
```
<input v-model="sth" />
//  等同于
<input :value="sth" @input="sth = $event.target.value" />
```
- 这个语法糖必须是固定的，也就是说属性必须为value，方法名必须为：input。
- 知道了v-model的原理，我们可以在自定义组件上实现v-model
```
//Parent
<template>
    {{num}}
    <Child v-model="num">
</template>
export default {
    data(){
        return {
            num: 0
        }
    }
}

//Child
<template>
    <div @click="add">Add</div>
</template>
export default {
    props: ['value'],
    methods:{
        add(){
            this.$emit('input', this.value + 1)
        }
    }
}
```

说一下v-model的原理
- v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性

#### v-model中的实现原理及如何自定义v-model
- v-model 可以看成是 value+input 方法的语法糖（组件）。原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来

- 自定义：自己写 model 属性，里面放上 prop 和 event

  #### Vue是如何实现双向绑定的
```
利用Object.defineProperty劫持对象的访问器,在属性值发生
变化时我们可以获取变化,然后根据变化进行后续响应,
在vue3.0中通过Proxy代理对象进行类似的操作。
```

```
// 这是将要被劫持的对象
const data = {
  name: '',
};

function say(name) {
  if (name === '古天乐') {
    console.log('给大家推荐一款超好玩的游戏');
  } else if (name === '渣渣辉') {
    console.log('戏我演过很多,可游戏我只玩贪玩懒月');
  } else {
    console.log('来做我的兄弟');
  }
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function(key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      console.log('get');
    },
    set: function(newVal) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`大家好,我系${newVal}`);
      say(newVal);
    },
  });
});

data.name = '渣渣辉';
//大家好,我系渣渣辉
//戏我演过很多,可游戏我只玩贪玩懒月
```

  #### vuex
vuex是什么？怎么使用？哪种功能场景使用它？
- 只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
- 在main.js引入store，注入。新建了一个目录store，… export
- 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车

- state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。
- mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据
- getters：类似vue的计算属性，主要用来过滤一些数据。
- action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action
```
const store = new Vuex.Store({ //store实例
	state : {
            count: 0
	},
	mutations: {
	    increment (state) { 
		state. count++
	    }
	},
	actions: {
	    increment (context) {
		context. commit( ' inc rement ' )
	    }
	}
})
```

- modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理
```
const moduleA = {
	state : { ... },
	mutations : { ... },
	actions: { ... },
	getters: { ... }
}

const moduleB = {
	state: { ... },
	mutations :{ ... },
	actions: { ... }
}

const store = new Vuex.Store({
	modules: {
		a: modu LeA, 
		b: moduleB
	}
})
```

vuex是什么？怎么使用？哪种功能场景使用它？
```
vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源
存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是
响应式的，vue 组件从store 读取数据，若是 store 中的数据发生改变，
依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 
和 getters 映射到当前组件的 computed 计算属性vuex的使用借助官方提供的来说明:
```

Vuex有5种属性: 分别是 state、getter、mutation、action、module;
state
- Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据

mutations
- mutations定义的方法动态修改Vuex 的 store 中的状态或数据。

getters
- 类似vue的计算属性，主要用来过滤一些数据

action
- actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。
- vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。
- 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题
- vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据 2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态
- 一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：
- 开发时，改变数组或者对象的数据，但是页面没有更新如何解决？
- vue弹窗后如何禁止滚动条滚动？
- 如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件

vuex 是什么？ 有哪几种属性？
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。
- 有 5 种，分别是 state、getter、mutation、action、module
vuex 的 store 是什么？
- vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性

vuex 的 getter 是什么？
- getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters

vuex 的 mutation 是什么？
- 更改Vuex的store中的状态的唯一方法是提交mutation

vuex 的 action 是什么？
- action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作
- vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中

vuex 的 module 是什么？
- 面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。
- 如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回


```
Vuex 集中式存储管理应用的所有组件的状态，
并以相应的规则保证状态以可预测的方式发生变化

核心概念：
state: 状态中心
mutations: 更改状态
actions: 异步更改状态
getters: 获取状态
modules: 将state分成多个modules，便于管理

1.状态 - state
state保存应用状态

export default new Vuex.Store({ state: { counter:0 },})

2.状态变更 - mutations
mutations用于修改状态，store.js

export default new Vuex.Store({
    mutations:
    {
      add(state) {
        state.counter++
      }
    }
  })
  
3.派生状态 - getters
从state派生出新状态，类似计算属性

export default new Vuex.Store({
    getters:
    {
      doubleCounter(state) { // 计算剩余数量 return state.counter * 2;
      }
    }
  })
  
4.动作 - actions
加业务逻辑，类似于controller

export default new Vuex.Store({
    actions:
    {
      add({
        commit
      }) {
        setTimeout(() = >{}
      }
    })
测试代码:

<p @click="$store.commit('add')">counter: {{$store.state.counter}}</p>
<p @click="$store.dispatch('add')">async counter: {{$store.state.counter}}</p>
<p>double:{{$store.getters.doubleCounter}}</p>

vuex原理解析
(1)实现一个插件:声明Store类，挂载$store
(2)Store具体实现:
  创建响应式的state，保存mutations、actions和getters
  实现commit根据用户传入type执行对应mutation
  实现dispatch根据用户传入type执行对应action，同时传递上下文
  实现getters，按照getters定义对state做派生
  
// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法
// 目标2：封装一个插件，使用更容易使用
let Vue;

class Store {
  constructor(options) {
    // 定义响应式的state
    // this.$store.state.xx
    // 借鸡生蛋
    this._vm = new Vue({
      data: {
        $$state: options.state
      }
    })
    
    this._mutations = options.mutations
    this._actions = options.actions

    // 绑定this指向
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }

  // 只读
  get state() {
    return this._vm._data.$$state
  }

  set state(val) {
    console.error('不能直接赋值呀，请换别的方式！！天王盖地虎！！');
    
  }
  
  // 实现commit方法，可以修改state
  commit(type, payload) {
    // 拿出mutations中的处理函数执行它
    const entry = this._mutations[type]
    if (!entry) {
      console.error('未知mutaion类型');
      return
    }

    entry(this.state, payload)
  }

  dispatch(type, payload) {
    const entry = this._actions[type]

    if (!entry) {
      console.error('未知action类型');
      return
    }

    // 上下文可以传递当前store实例进去即可
    entry(this, payload)
  }
}

function install(_Vue){
  Vue = _Vue

  // 混入store实例
  Vue.mixin({
    beforeCreate() {
      if (this.$options.store) {
        Vue.prototype.$store = this.$options.store
      }
    }
  })
}

// { Store, install }相当于Vuex
// 它必须实现install方法
export default { Store, install }
```

#### vuex总结
- state: 状态中心
- mutations: 更改状态
- actions: 异步更改状态
- getters: 获取状态
- modules: 将state分成多个modules，便于管理

#### Vuex工作原理
- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。

状态自管理应用包含以下几个部分：
- state，驱动应用的数据源；
- view，以声明方式将 state 映射到视图；
- actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：

vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：
- 多个视图依赖于同一状态。
- 来自不同视图的行为需要变更同一状态

  #### MVVM
MVVM 由以下三个内容组成
- View：界面
- Model：数据模型
- ViewModel：作为桥梁负责沟通 View 和 Model
```
在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的
DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。
```

MVVM
```
在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的
刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式
就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。
ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，
在这种情况下，View 和 Model 都可以独立出来，任何一方改变了
也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 
ViewModel 中，让多个 View复用这个 ViewModel。
```

- 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

脏数据检测
- 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。

- 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。

数据劫持
- Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。
```
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```
- 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅

```
<div>
    {{name}}
</div>
```
- 在解析如上模板代码时，遇到 {name} 就会给属性 name 添加发布订阅。

```
// 通过 Dep 解耦
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    // sub 是 Watcher 实例
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null

function update(value) {
  document.querySelector('div').innerText = value
}

class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
```
- 接下来,对 defineReactive 函数进行改造

```
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      // 执行 watcher 的 update 方法
      dp.notify()
    }
  })
}
```
- 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加

Proxy 与 Object.defineProperty 对比
```
Object.defineProperty 虽然已经能够实现双向绑定了，
但是他还是有缺陷的。
```
- 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化
- 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack的办法，并且也是有缺陷的。
```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下几个函数
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
methodsToPatch.forEach(function (method) {
  // 获得原生函数
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    // 调用原生函数
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // 触发更新
    ob.dep.notify()
    return result
  })
})
```
- 反观 Proxy就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty
```
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

  #### MVVM和MVC的区别
```
MVC: MVC是应用最广泛的软件架构之一,一般MVC分为:
Model(模型),View(视图),Controller(控制器)。 这主要是
基于分层的目的,让彼此的职责分开.View一般用过Controller来
和Model进行联系。Controller是Model和View的协调者,
View和Model不直接联系。基本都是单向联系。

1. View传送指令到Controller。
2. Controller完成业务逻辑后改变Model状态。
3. Model将新的数据发送至View,用户得到反馈。

MVVM: MVVM是把MVC中的Controller改变成了ViewModel。

View的变化会自动更新到ViewModel,ViewModel的变化
也会自动同步到View上显示,通过数据来显示视图层。

MVVM和MVC的区别:
  MVC中Controller演变成MVVM中的ViewModel
  MVVM通过数据来显示视图层而不是节点操作
  MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,
  加载速度变慢,影响用户体验
```

```
MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller
演变成ViewModel。Model层代表数据模型，View代表UI组件，
ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并
自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。
```

- MVVM 是 Model-View-ViewModel 的缩写
- Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为
- View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View
- ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.
- 总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。

  #### vue的优点
```
轻量级框架
简单易学
双向数据绑定
组件化
视图，数据，结构分离
虚拟 DOM
运行速度更快
```

- 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
- 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
- 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写

  #### Vue.js特点
- 简洁：页面由HTML模板+Json数据+Vue实例组成
- 数据驱动：自动计算属性和追踪依赖的模板表达式
- 组件化：用可复用、解耦的组件来构造页面
- 轻量：代码量小，不依赖其他库
- 快速：精确有效批量DOM更新
- 模板友好：可通过npm，bower等多种方式安装，很容易融入

  #### 开发中常用的指令有哪些
- v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定
- v-html: 更新元素的 innerHTML
- v-show 与 v-if: 条件渲染, 注意二者区别：使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏

- v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数
- v-for:基于源数据多次渲染元素或模板块
- v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM语法：v-bind:title="msg"简写：:title="msg"
  
  #### vue的响应式原理
```
数据发生变化后，会重新对页面渲染，这就是 Vue 响应式

想完成这个过程，我们需要：
  侦测数据的变化
  收集视图依赖了哪些数据
  数据变化时，自动“通知”需要更新的视图部分，并进行更新

对应专业俗语分别是：
数据劫持 / 数据代理
依赖收集
发布订阅模式
```

Vue2.x 响应式原理
```
Vue 采用数据劫持结合发布—订阅模式的方法，通过 
Object.defineProperty() 来劫持各个属性的 setter，
getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
```

- Observer 遍历数据对象，给所有属性加上 setter 和 getter，监听数据的变化
- compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
```
Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情
```
- 在自身实例化时往属性订阅器 (dep) 里面添加自己
- 待属性变动 dep.notice() 通知时，调用自身的 update() 方法，并触发 Compile 中绑定的回调

Vue3.x响应式数据原理
```
Vue3.x改用Proxy替代Object.defineProperty。因为Proxy
可以直接监听对象和数组的变化，并且有多达13种拦截方法。
并且作为新标准将受到浏览器厂商重点持续的性能优化。
```

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
```
判断当前Reflect.get的返回值是否为Object，如果是
则再通过reactive方法做代理， 这样就实现了深度观测。
```

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
```
我们可以判断key是否为当前被代理对象target自身属性，也可以判断
旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger
```

```
Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 
中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了
访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 
中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，
观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,
生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和
旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，
将所有记录的不同点，局部修改到真实 DOM树上。

1.虚拟DOM (Virtaul DOM): 用 js 对象模拟的，保存当前视图内所有 
  DOM 节点对象基本描述属性和节点间关系的树结构。用 js 对象，
  描述每个节点，及其父子关系，形成虚拟 DOM 对象树结构。
2.因为只要在 data 中声明的基本数据类型的数据，基本不存在
  数据不响应问题，所以重点介绍数组和对象在vue中的数据响应问题，
  vue可以检测对象属性的修改，但无法监听数组的所有变动及
  对象的新增和删除，只能使用数组变异方法及$set方法。

总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过
Object.defineProperty() 来劫持各个属性的 setter，getter，
在数据变动时发布消息给订阅者，触发相应的监听回调。

1.Observer 遍历数据对象，给所有属性加上 setter 和 getter，监听数据的变化
2.compile 解析模板指令，将模板中的变量替换成数据，
  然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，
  添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
  
  Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情

1.在自身实例化时往属性订阅器 (dep) 里面添加自己
2.待属性变动 dep.notice() 通知时，调用自身的 update() 方法，
  并触发 Compile 中绑定的回调
  
Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？
  1.可以检测对象中数据发生的修改
  2.对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，
    这样子就需要递归到底，这也是它的缺点。
  3.对于一个对象中，如果你新增加属性，删除属性，
    **Object.defineProperty()**是不能观测到的，那么应该如何解决呢？
    可以通过Vue.set()和Vue.delete()来实现。
// 模拟 Vue 中的 data 选项 
let data = {
    msg: 'hello'
}
// 模拟 Vue 的实例 
let vm = {}
// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作
Object.defineProperty(vm, 'msg', {
  // 可枚举(可遍历)
  enumerable: true,
  // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) 
  configurable: true,
  // 当获取值的时候执行 
  get () {
    console.log('get: ', data.msg)
    return data.msg 
  },
  // 当设置值的时候执行 
  set (newValue) {
    console.log('set: ', newValue) 
    if (newValue === data.msg) {
      return
    }
    data.msg = newValue
    // 数据更改，更新 DOM 的值 
    document.querySelector('#app').textContent = data.msg
  } 
})

// 测试
vm.msg = 'Hello World' 
console.log(vm.msg)

Vue3.x响应式数据原理：
Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以
直接监听对象和数组的变化，并且有多达13种拦截方法。
并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
判断当前Reflect.get的返回值是否为Object，如果是则
再通过reactive方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
我们可以判断key是否为当前被代理对象target自身属性，也可以判断
旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger

// 模拟 Vue 中的 data 选项 
let data = {
  msg: 'hello',
  count: 0 
}
// 模拟 Vue 实例
let vm = new Proxy(data, {
  // 当访问 vm 的成员会执行
  get (target, key) {
    console.log('get, key: ', key, target[key])
    return target[key]
  },
  // 当设置 vm 的成员会执行
  set (target, key, newValue) {
    console.log('set, key: ', key, newValue)
    if (target[key] === newValue) {
      return
    }
    target[key] = newValue
    document.querySelector('#app').textContent = target[key]
  }
})

// 测试
vm.msg = 'Hello World'
console.log(vm.msg)

Proxy 相比于 defineProperty 的优势
数组变化也能监听到
不需要深度遍历监听

Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作

let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` 用来自定义对象中的操作
// 可以很方便的使用 Proxy 来实现一个数据绑定和监听

let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2

总结：
Vue
  记录传入的选项，设置 $data/$el
  把 data 的成员注入到 Vue 实例
  负责调用 Observer 实现数据响应式处理(数据劫持)
  负责调用 Compiler 编译指令/插值表达式等
Observer
  数据劫持
    负责把 data 中的成员转换成 getter/setter
    负责把多层属性转换成 getter/setter
    如果给属性赋值为新对象，把新对象的成员设置为 getter/setter
    添加 Dep 和 Watcher 的依赖关系
    数据变化发送通知
Compiler
  负责编译模板，解析指令/插值表达式
  负责页面的首次渲染过程
  当数据变化后重新渲染
Dep
  收集依赖，添加订阅者(watcher)
  通知所有订阅者
Watcher
  自身实例化的时候往dep对象中添加自己
  当数据变化dep通知所有的 Watcher 实例更新视图
```

  #### 发布订阅模式和观察者模式
```
1. 发布/订阅模式
  发布/订阅模式
    订阅者
    发布者
    信号中心
我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心
"发布"(publish)一个信 号，其他任务可以向信号中心"订阅"(subscribe)
这个信号，从而知道什么时候自己可以开始执行。
这就叫做"发布/订阅模式"(publish-subscribe pattern)

Vue 的自定义事件：
let vm = new Vue()
vm.$on('dataChange', () => { console.log('dataChange')})
vm.$on('dataChange', () => { 
  console.log('dataChange1')
}) 
vm.$emit('dataChange')

兄弟组件通信过程：
// eventBus.js
// 事件中心
let eventHub = new Vue()

// ComponentA.vue
// 发布者
addTodo: function () {
  // 发布消息(事件)
  eventHub.$emit('add-todo', { text: this.newTodoText }) 
  this.newTodoText = ''
}
// ComponentB.vue
// 订阅者
created: function () {
  // 订阅消息(事件)
  eventHub.$on('add-todo', this.addTodo)
}

模拟 Vue 自定义事件的实现：
class EventEmitter {
  constructor(){
    // { eventType: [ handler1, handler2 ] }
    this.subs = {}
  }
  // 订阅通知
  $on(eventType, fn) {
    this.subs[eventType] = this.subs[eventType] || []
    this.subs[eventType].push(fn)
  }
  // 发布通知
  $emit(eventType) {
    if(this.subs[eventType]) {
      this.subs[eventType].forEach(v=>v())
    }
  }
}

// 测试
var bus = new EventEmitter()

// 注册事件
bus.$on('click', function () {
  console.log('click')
})

bus.$on('click', function () {
  console.log('click1')
})

// 触发事件 
bus.$emit('click')

2. 观察者模式
  观察者(订阅者) -- Watcher
    update():当事件发生时，具体要做的事情
  目标(发布者) -- Dep
    subs 数组:存储所有的观察者
    addSub():添加观察者
    notify():当事件发生，调用所有观察者的 update() 方法
  没有事件中心
// 目标(发布者) 
// Dependency
class Dep {
  constructor () {
    // 存储所有的观察者
    this.subs = []
  }
  // 添加观察者
  addSub (sub) {
    if (sub && sub.update) {
      this.subs.push(sub)
    }
  }
  // 通知所有观察者
  notify () {
    this.subs.forEach(sub => sub.update())
  }
}

// 观察者(订阅者)
class Watcher {
  update () {
    console.log('update')
  }
}

// 测试
let dep = new Dep()
let watcher = new Watcher()
dep.addSub(watcher) 
dep.notify()

3. 总结
1.观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用
观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的
2.发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在

```

  #### Object.defineProperty介绍
```
Object.defineProperty 函数一共有三个参数，第一个参数是需要
定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。

一个属性的描述符有一下属性，分别是：
value 属性的值，
writable 属性是否可写，
enumerable 属性是否可枚举，
configurable 属性是否可配置修改。
get属性 当访问该属性时，会调用此函数
set属性 当属性值被修改时，会调用此函数。
```

#### Vue的响应式原理中Object.defineProperty有什么缺陷
- Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
- Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象
- Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性

  #### 使用Object.defineProperty()来进行数据劫持有什么缺点
```
有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改
数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行
代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到
任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。
```

  #### v-if和v-show的区别
```
v-if：每次都会重新删除或创建元素来控制 DOM 结点的存在与否

v-show:是切换了元素的样式 display:none，display: block

因而 v-if 有较高的切换性能消耗，v-show 有较高的初始渲染消耗
```

- v-if按照条件是否渲染，v-show是display的block或none；

  #### vue中created和mounted区别
- created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
- mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

```
其实两者比较好理解，通常created使用的次数多，而mounted通常是
在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: 
var ctx = document.getElementById(ID); 通常会有这一步，
而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，
一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。
```

  #### vue中data和computed区别
data 和 computed都是响应式的，先看看官方的说法：
```
Data:
Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 
getter/setter，从而让 data 的属性能够响应数据变化。

深入理解响应式原理：
当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，
Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 
把这些属性全部转为 getter/setter。

每个组件实例都有相应的 watcher 实例对象，它会在组件渲染
的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，
会通知 watcher 重新计算，从而致使它关联的组件得以更新。
```

2.两者的区别：
```
data中的属性并不会随赋值变量的改动而改动，(赋值变量类似：
num1: aaa.bbb这种，而这种是直接赋值：num1: "aaa")
```

```
当需要这种随赋值变量的改动而改动的时候，还是用计算属性
computed合适如果实在要在data里面声明属性，可以先赋一个值，
然后在methods里面定义方法操作该属性，效果等同，也会有响应式
```

computed:
- 1、基本使用：
```
在computed中定义一个函数(看起来是一个函数，其实是一个属性)，
命名按照属性规范命名(一般为名词)。
```

  - 1.1 应用场景：
```
当数据A的逻辑很复杂时，把A这个数据写在计算属性中。
```

  - 1.2 代码位置：
```
通过选项computed：{计算属性a:值}
```

  - 1.3 值：
```
带有返回值return的函数。
```

```
计算属性a和data中的数据用法一样。计算属性在computed中进行定义，
无需再在data中定义，在template中直接可进行使用，
使用方式与data中定义的数据一样。

{{msg}}
{{str}}

var vm = new Vue({
el: '#app',

data: {
msg: 'abc'
},

computed: {
str: function () {
return this.msg
}
},

methods: {
}

})
```

- 2、复杂操作-结合data中数据：
```
当计算属性b依赖了data中的数据a时，当a变化时，b会自动变化。
这也是在开发中通常用到的情况。比如在购物的时候，下某一订单时，
每选择一件商品(对应data中的数据a)，
合计费用(对应计算属性b)就会跟着变化。
```

```
总价格：{{totalPrice}}
var vm = new Vue({
el: '#app',

data: {
books: [
{ id: 1000, name: 'Linux编程之美', price: 50 },
{ id: 1001, name: 'Java疯狂讲义', price: 60 },
{ id: 1002, name: '深入理解计算机原理', price: 80 },
{ id: 1003, name: '操作系统', price: 30 },
{ id: 1004, name: '数据结构导论', price: 60 },
]
},

computed: {
totalPrice() {
let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;
}

return result
}
},

methods: {
}
})
```

- 3、计算属性写法演变：
  - 3.1 计算属性的setter和getter：
```
computed：{
//computed里面是大括号，本身就是对象。
}
```

完整的计算属性写法：属性+方法
```
computed: {
//定义属性

totalPrice: {
//totalPrice 属性对应的是对象，不是字符串。对象就会有方法。

//该属性对应的set方法 和get方法

//计算属性一般是没有set方法的，是只读属性。

//【此处set测试失败 没有出现预期效果】

set: function (newValue) {
console.log('get方法调用啦', newValue);
},

get: function () {
console.log('计算属性完整写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;
}

return result
}
}
},
```

计算属性一般只有get方法，是只读属性。所以一般写法为：
```
computed: {
totalPrice: function () {
//后面对应的即为get方法。totalPrice就是一个属性，调用时采用属性调用的方式，区别于方法调用()

console.log('计算属性一般写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;

}

return result

}

},
```

语法糖—简化写法：
```
computed: {
totalPrice() {
console.log('计算属性语法糖写法：计算啦');

let result = 0;

for (let i = 0; i < this.books.length; i++) {
result += this.books[i].price;

}

return result

}

},
```

- 4、项目中实例：
```
以上即为计算属性computed的使用方式。最近在项目开发中，
有个需求为:【考试配题模块】配置某一题型(例如选择题/简答题等
某类试题)个数或者每一小题分数时，会实时计算出当前选择的
某类试题拥有的个数和当前题目个数所对应的小题分数的总分之和。
```
```
template中代码：

课程名称：{{ courseName }}
总题数：{{ allQuestion }}个
当前总分：{{ allValue }}分
computed中代码：

allQuestion: function() {
var num = 0;

this.selectedObj.forEach((item) => {
num += item.questionNum; //questionNum为拿到的selectedObj对象中的需要使用的属性

});

return num;

},

//计算总分

allValue: function() {
var source = 0;

this.selectedObj.forEach((item) => {
source += item.questionValue * item.questionNum; //questionValue 为拿到的selectedObj对象中的需要使用的属性

});

return source;

},

},

computed中依赖的data中数据部分：

// 子组件给父组件传过来的对象

selectedObj: [],
```

  #### vue中watch和computed区别
```
watch主要是监听数据变化，可以监听数据来源的三个部分：props,data,computed内的数据，然后它还提供两个参数
（new,old）,顺序一定是新值、旧值。

computed主要是处理逻辑运算，computed来存储需要处理的数据值，
它有存储的机制，只有改变时才执行。
```

computed:
- computed是计算属性,也就是计算值,它更多用于计算值的场景
- computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景

watch:
- 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作
- 无缓存性，页面重新渲染时值不变化也会执行

小结:
- 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed
- 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化


- 当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed
```
Computed本质是一个具备缓存的watcher，依赖的属性发生变化
就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式
过于复杂时，在模板中放入过多逻辑会让模板难以维护，
可以将复杂的逻辑放入计算属性中处理
```

```
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'yu fei',
        }
    },
    computed:{
        fullName: function(){
            return this.firstName + ' ' + this.lastName
        }
    }
}
```

- watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择
```
Watch没有缓存性，更多的是观察的作用，可以监听某些数据
执行回调。当我们需要深度监听对象中的属性时，可以打开
deep：true选项，这样便会对对象中的每一项进行监听。这样会
带来性能问题，优化的话可以使用字符串形式监听，
如果没有写到组件中，不要忘记使用unWatch手动注销
```

```
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'xiao fei',
            fullName: 'xie xiao fei'
        }
    },
    watch:{
        firstName(val) {
            this.fullName = val + ' ' + this.lastName
        },
        lastName(val) {
            this.fullName = this.firstName + ' ' + val
        }
    }
}
```

  #### vue中methods,watch和computer区别
methods,watch和computed都是以函数为基础的，但各自却都不同。

- 一、作用机制上
  - 1.watch和computed都是以Vue的依赖追踪机制为基础的，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
  - 2.对methods:methods里面是用来定义函数的，很显然，它需要手动调用才能执行。而不像watch和computed那样，“自动执行”预先定义的函数。
```

- 二、从性质上
  - 1.methods里面定义的是函数，你显然需要像"fuc()"这样去调用它（假设函数为fuc）。
  - 2.computed是计算属性，事实上和和data对象里的数据属性是同一类的（使用上）。
  - 3.watch:类似于监听机制+事件机制。
```
例如：
watch: {
   firstName: function(val) {this.fullName = val +this.lastName }
}

firstName的改变是这个特殊“事件”被触发的条件，
而firstName对应的函数就相当于监听到事件发生后执行的方法
```

- 三、watch和computed的对比
```
首先它们都是以Vue的依赖追踪机制为基础的，它们的共同点是：
都是希望在依赖数据发生改变的时候，被依赖的数据根据预先定义
好的函数，发生“自动”的变化。我们当然可以自己写代码完成这一切，
但却很可能造成写法混乱，代码冗余的情况。
```
 
但watch和computed也有明显不同的地方：
```
watch和computed各自处理的数据关系场景不同

1.watch擅长处理的场景：一个数据影响多个数据

2.computed擅长处理的场景：一个数据受多个数据影响

相比于watch/computed，methods不处理数据逻辑关系，只提供可调用的函数
```

```
在vue中处理复杂的逻辑的时候，我们经常使用计算属性computer，
但是很多时候，我们会把计算属性、方法和侦听器搞混淆，
在 w3cplus.com的一篇文章中是这样总结这三者的。
```
- methods：正如他的名字一样，它们是挂载在对象上的函数，通常是Vue实例本身或Vue组件。
- computed：属性最初看起来像一个方法，但事实却又不是方法。在Vue中，我们使用data来跟踪对特定属性的更改，得到一定的反应。计算属性允许我们定义一个与数据使用相同方式的属性，但也可以有一些基于其依赖关系的自定义逻辑。你可以考虑计算属性的另一个视图到你的数据。
- watchers：这些可以让你了解反应系统（Reactivity System）。我们提供了一些钩子来观察Vue存储的任何属性。如果我们想在每次发生变化时添加一些功能，或者响应某个特定的变化，我们可以观察一个属性并应用一些逻辑。这意味着观察者的名字必须与我们所观察到的相符。
如果仅仅只是看这段话，可能还是不能很清除的明白三者的区别，我们可以通过相关的实例来对三者进行区分。

computed
计算属性是根据依赖关系进行缓存的计算，并且只在需要的时候进行更新。
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <p>原数据{{message}}</p>
        <p>反转后的数据{{reversedMessage}}</p>
        <button @click="add()">补充货物1</button>
        <div>总价为：{{price}}</div>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘abcdefg‘,
                package: {
                    count: 5,
                    price: 5
                },
              },
              computed:{
                  reversedMessage:function(){
                      return this.message.split(‘‘).reverse().join(‘‘)
                  },
                price: function(){
                     return this.package.count*this.package.price　　
                 }
            },
             methods: {   
                add: function(){
                    this.package.count++
                }
            }    
        })
    </script>    
</body>
</html>
```

```
上面的例子中展示了计算属性的两种用法：一个计算属性里面可以完成
各种复杂的逻辑，最终返回一个结果；计算属性可以依赖多个vue实例的
数据，只要其中一个任何一个数据发生变化，计算属性就会重新执行，视图
也会更新。除此之外，计算属性还可以依赖其他计算属性和其他实例的数据。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="app1">{{text}}</div>
    <div id="app2">{{ reverseText}}</div>
    <script>
        var app1 = new Vue({
           el: ‘#app1‘,
             data: {
                  text: ‘computed‘
            }
        });

        var app2 = new Vue({
            el: ‘#app2‘,
            computed: {
                reverseText: function(){
                    return app1.text.split(‘‘).reverse().join(‘‘);  
                }
            }
        });
    </script>    
</body>
</html>
```

methods
```
在使用vue的时候，可能会用到很多的方法，它们可以将功能连接到
事件的指令，甚至只是创建一个小的逻辑就像其他函数一样被重用。
接下来我们用方法实现上面的字符串反转。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <p>原数据{{message}}</p>
        <p>反转后的数据{{ reversedMessage() }}</p>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘abcdefg‘,
                num:5
              },
              methods:{
                reversedMessage(){
                    return this.message.split(‘‘).reverse().join(‘‘)
                },
            }
        })
    </script>    
</body>
</html>
```

``
虽然使用计算属性和methods方法来实现反转，两种方法得到的结果
是相同的，但本质是不一样的，计算属性是基于它们的依赖进行缓存的。
计算属性只有在它的相关依赖发生改变的时候才会重新求值，这就意味
着只要message还没有发生改变，多次访问reversedMessage计算属性
立即返回的是之前计算的结果，而不会再次执行计算函数，
而对于methods方法，只要发生重新渲染，methods调用总会执行该函数。

如果某个计算属性a需要的遍历一个极大的数组和做大量的计算，
可以减小性能开销，如果不希望有缓存，则用methods。
```

watch
```
watch属性是一个对象，键是需要观察的表达式，值是对应回调函数，
回调函数得到的参数为新值和旧值。值也可以是方法名，或者包含选项
的对象。侦察器对于任何更新的东西都有用——无论是表单输入、异步更新
还是动画。vue实例在实例化时调用$watch()，遍历watch对象的每一个属性。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="demo">
        <button @click=‘a++‘>a加1</button>
        <p>{{message}}</p>
    </div>
    <script>
        var demo = new Vue({
              el: ‘#demo‘,
              data: {
                message :‘‘,
                a:1
              },
              
              watch:{
              a:function(val,oldval){
                this.message = ‘a的旧值为‘ + oldval + ‘,新值为‘ + val;
              }
            }
        })
    </script>    
</body>
</html>
```

- computed：默认computed也是一个watcher具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用computed
- watch：每次都需要执行函数。 watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。
- method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大

  #### 为什么vue组件中的data必须是函数
```
<!-- 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例
用的都是同一个构造函数，如果data是对象的话，对象属性引用类型，
会影响到所有的实例，为了保证组件不同的实例之间的data互不冲突，
data必须是一个函数。 -->

当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，
因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，
则所有的实例将共享引用同一个数据对象！通过提供 data 函数，
每次创建一个新实例后，我们能够调用 data 函数，
从而返回初始数据的一个全新副本数据对象。

简而言之，就是 data 中数据可能会被复用，
要保证不同组件调用的时候数据是相同的。
```

- 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数

  #### vue的activated和deactivated钩子函数
```html
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```

```
`keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

当组件在 `<keep-alive>` 内被切换，它的 `activated` 
和 `deactivated` 这两个生命周期钩子函数将会被对应执行。

`activated`在`keep-alive`组件激活时调用，
该钩子函数在服务器端渲染期间不被调用。
`deactivated`在`keep-alive`组件停用时调用，
该钩子函数在服务端渲染期间不被调用。
```

  #### nextTick用法
- nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
  
官网解释：
```
将回调延迟到下次 DOM 更新循环之后执行。
在修改数据之后立即使用它，然后等待 DOM 更新。
```

```html
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
```

```vue
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```

```
nextTick 可以让我们在下次 DOM 更新循环结束之后
执行延迟回调，用于获得更新后的 DOM

nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

Promise
MutationObserver
setImmediate
如果以上都不行则采用setTimeout
定义了一个异步方法，多次调用nextTick会将方法
存入队列中，通过这个异步方法清空当前队列
```

```
nextTick 可以让我们在下次 DOM 更新循环结束之后
执行延迟回调，用于获得更新后的 DOM
```

nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用
- Promise
- MutationObserver
- setImmediate
- 如果以上都不行则采用setTimeout
```
定义了一个异步方法，多次调用nextTick会将方法
存入队列中，通过这个异步方法清空当前队列
```

  #### vue中key属性的作用
```
一句话 key 的作用主要是为了高效的更新虚拟 DOM

key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 
对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少
动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，
它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。
```

Vue中的key到底有什么用？
- key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速
- diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.

  - diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.

  - 准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1).

  #### Vue中key属性用index为什么不行
这是由于diff算法的机制所决定的，话不多说，直接上反例：
当我们选中某一个（比如第3个），再添加或删除内容的时候就能发现bug了

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

</head>
<body>
    <div id="app">
        <span>ID:</span><input type="text" v-model="id">
        <span>Name:</span><input type="text" v-model="name">
        <button @click="handleClick">添加</button>

        <div v-for="(item, index) in list" :key="index">
            <input type="checkbox" />
            <span @click="handleDelete(index)">{{item.id}} --- {{item.name}}</span>
        </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data: {
                id: '',
                name: '',
                list: [
                    {id: 1, name: '张三'},
                    {id: 2, name: '李四'},
                    {id: 3, name: '王五'},
                    {id: 4, name: '赵六'},
                ]
            },
            methods: {
                handleClick() {
                    this.list.unshift({
                        id: this.id,
                        name: this.name
                    })
                },
                handleDelete(index) {
                    this.list.splice(index, 1)
                }
            },
        })
    </script>
</body>
</html>
```

  #### 路由原理
- 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

  - hash 模式
  - history 模式
- www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。

- History模式是 HTML5 新推出的功能，比之 Hash URL 更加美观

  #### Vue的路由模式
> hash模式 与 history模式
> 
- hash（即地址栏 URL 中的 # 符号)。

```txt
比如这个 URL：www.123.com/#/test，hash 的值为 #/test。

特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP，因为我们hash每次页面切换其实切换的是#之后的内容，而#后内容的改变并不会触发地址的改变，
所以不存在向后台发出请求，对后端完全没有影响，因此改变 hash 不会重新加载页面。

每次hash发生变化时都会调用 onhashchange事件

优点：可以随意刷新
```

- history（利用了浏览器的历史记录栈）

```txt
特点：利用了 HTML5 History Interface 中新增的 
pushState() 和 replaceState() 方法。（需要特定浏览器支持）

在当前已有的 back、forward、go的基础之上，它们提供了对
历史记录进行修改的功能。只是当它们执行修改时，虽然改变了
当前的URL，但浏览器不会立即向后端发送请求。

history：可以通过前进 后退控制页面的跳转，刷新是真是的改变url。

缺点：不能刷新，需要后端进行配置。由于history模式下是可以
自由修改请求url，当刷新时如果不对对应地址进行匹配就会返回404。
但是在hash模式下是可以刷新的，前端路由修改的是#中的信息，
请求时地址是不会变的
```

  #### Vue的路由实现：hash模式和history模式
- hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。

- history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更

#### Vue中hash模式和history模式的区别
- 最明显的是在显示上，hash模式的URL中会夹杂着#号，而history没有。
- Vue底层对它们的实现方式不同。hash模式是依靠onhashchange事件(监听location.hash的改变)，而history模式是主要是依靠的HTML5 history中新增的两个方法，pushState()可以改变url地址且不会发送请求，replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改。
- 当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持。因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。

hash:
```
window.onhashchange = function(event){
  // location.hash获取到的是包括#号的，如"#heading-3"
  // 所以可以截取一下
	let hash = location.hash.slice(1);
}
```

#### 了解history有哪些方法吗？说下它们的区别
- history 这个对象在html5的时候新加入两个api history.pushState() 和 history.repalceState() 这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。

从参数上来说：
```
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录
```

另外还有：
- window.history.back() 后退
- window.history.forward()前进
- window.history.go(1) 前进或者后退几步

从触发事件的监听上来说：
- pushState()和replaceState()不能被popstate事件所监听
- 而后面三者可以，且用户点击浏览器前进后退键时也可以

  #### vue路由的钩子函数
```
首页可以控制导航跳转，beforeEach，afterEach等，一般用于
页面title的修改。一些需要登录才能调整页面的重定向功能。
```

- beforeEach主要有3个参数to，from，next。
- to：route即将进入的目标路由对象。
- from：route当前导航正要离开的路由。
- next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转

  #### 路由之间跳转
> 声明式（标签跳转）
> <router-link :to="index">

> 编程式（ js跳转）
> router.push('index')

  #### vue路由传参数
- 使用query方法传入的参数使用this.$route.query接受
- 使用params方式传入的参数使用this.$route.params接受

  #### vue中$router和$route的区别
- this.\$route：当前激活的路由的信息对象。每个对象都是局部的，
  可以获取当前路由的 path, name, params, query 等属性。
- this.\$router：全局的 router 实例。通过 vue 根实例中注入 
  router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。
  其中包含了很多属性和对象（比如 history 对象），
  任何页面也都可以调用其 push(), replace(), go() 等方法。

- $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
- 而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等

  #### vue3带来的新特性/亮点
1. 压缩包体积更小
```
当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。
Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！
```

2. Object.defineProperty -> Proxy
- Object.defineProperty是一个相对比较昂贵的操作，因为它
  直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，
  在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。
  这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。
- javascript引擎在解析的时候希望对象的结构越稳定越好，
  如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。

3. Virtual DOM 重构
```
vdom的本质是一个抽象层，用javascript描述界面渲染成什么样子。
react用jsx，没办法检测出可以优化的动态代码，所以做时间分片，
vue中足够快的话可以不用时间分片
```

- 传统vdom的性能瓶颈：
  - 虽然 Vue 能够保证触发更新的组件最小化，但在单个组件
    内部依然需要遍历该组件的整个 vdom 树。
  - 传统 vdom 的性能跟模版大小正相关，跟动态节点的数量无关。
    在一些组件整个模版内只有少量动态节点的情况下，
    这些遍历都是性能的浪费。
  - JSX 和手写的 render function 是完全动态的，
    过度的灵活性导致运行时可以用于优化的信息不足

- 那为什么不直接抛弃vdom呢？
  - 高级场景下手写 render function 获得更强的表达力
  - 生成的代码更简洁
  - 兼容2.x
```
vue的特点是底层为Virtual DOM，上层包含有大量静态信息的模版。
为了兼容手写 render function，最大化利用模版静态信息，
vue3.0采用了动静结合的解决方案，将vdom的操作颗粒度变小，
每次触发更新不再以组件为单位进行遍历，主要更改如下
```

- 将模版基于动态节点指令切割为嵌套的区块
- 每个区块内部的节点结构是固定的
- 每个区块只需要以一个 Array 追踪自身包含的动态节点
```
vue3.0将 vdom 更新性能由与模版整体大小相关提升为
与动态内容的数量相关
```

Vue 3.0 动静结合的 Dom diff：
- Vue3.0 提出动静结合的 DOM diff 思想，动静结合的 DOM diff
  其实是在预编译阶段进行了优化。之所以能够做到预编译优化，
  是因为 Vue core 可以静态分析 template，在解析模版时，
  整个 parse 的过程是利用正则表达式顺序解析模板，当解析到
  开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，
  来达到构造 AST 树的目的。
- 借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在
  预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff 时
  就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。
  这也就是动静结合的 DOM diff 将 diff 成本与模版大小正相关
  优化到与动态节点正相关的理论依据。
  
4. Performance
```
vue3在性能方面比vue2快了2倍。
```
- 重写了虚拟DOM的实现
- 运行时编译
- update性能提高
- SSR速度提高

5. Tree-shaking support
```
vue3中的核心api都支持了tree-shaking，这些api都是通过包引入的方式
而不是直接在实例化时就注入，只会对使用到的功能或特性进行打包
（按需打包），这意味着更多的功能和更小的体积。
```

6. Composition API
```
vue2中，我们一般会采用mixin来复用逻辑代码，用倒是挺好用的，不过
也存在一些问题：例如代码来源不清晰、方法属性等冲突。基于此在vue3
中引入了Composition API（组合API），使用纯函数分隔复用代码。
和React中的hooks的概念很相似
```
- 更好的逻辑复用和代码组织
- 更好的类型推导

```
<template>
    <div>X: {{ x }}</div>
    <div>Y: {{ y }}</div>
</template>

<script>
import { defineComponent, onMounted, onUnmounted, ref } from "vue";

const useMouseMove = () => {
    const x = ref(0);
    const y = ref(0);

    function move(e) {
        x.value = e.clientX;
        y.value = e.clientY;
    }

    onMounted(() => {
        window.addEventListener("mousemove", move);
    });

    onUnmounted(() => {
        window.removeEventListener("mousemove", move);
    });

    return { x, y };
};

export default defineComponent({
    setup() {
        const { x, y } = useMouseMove();

        return { x, y };
    }
});
</script>
```

7. 新增的三个组件Fragment、Teleport、Suspense
Fragment
```
在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些
没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的
（这和React中的Fragment组件是一样的）。
```

这意味着现在可以这样写组件了。
```
/* App.vue */
<template>
  <header>...</header>
  <main v-bind="$attrs">...</main>
  <footer>...</footer>
</template>

<script>
export default {};
</script>
```

或者这样
```
// app.js
import { defineComponent, h, Fragment } from 'vue';

export default defineComponent({
    render() {
        return h(Fragment, {}, [
            h('header', {}, ['...']),
            h('main', {}, ['...']),
            h('footer', {}, ['...']),
        ]);
    }
});
```

Teleport
```
Teleport其实就是React中的Portal。Portal 提供了一种将
子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
```

一个 portal 的典型用例是当父组件有 overflow: hidden 或 
z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。
例如，对话框、悬浮卡以及提示框。
```
/* App.vue */
<template>
    <div>123</div>
    <Teleport to="#container">
        Teleport
    </Teleport>
</template>

<script>
import { defineComponent } from "vue";

export default defineComponent({
    setup() {}
});
</script>

/* index.html */
<div id="app"></div>
<div id="container"></div>
```

Suspense
同样的，这和React中的Supense是一样的。
```
Suspense 让你的组件在渲染之前进行“等待”，
并在等待时显示 fallback 的内容
```

```
// App.vue
<template>
    <Suspense>
        <template #default>
            <AsyncComponent />
        </template>
        <template #fallback>
            Loading...
        </template>
    </Suspense>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import AsyncComponent from './AsyncComponent.vue';

export default defineComponent({
    name: "App",
    
    components: {
        AsyncComponent
    }
});
</script>

// AsyncComponent.vue
<template>
    <div>Async Component</div>
</template>

<script lang="ts">
import { defineComponent } from "vue";

const sleep = () => {
    return new Promise(resolve => setTimeout(resolve, 1000));
};

export default defineComponent({
    async setup() {
        await sleep();
    }
});
</script>
```

8. Better TypeScript support
```
在vue2中使用过TypesScript的童鞋应该有过体会，写起来实在是有点难受。
vue3则是使用ts进行了重写，开发者使用vue3时拥有更好的类型支持和更好的编写体验。
```
  
  #### VDOM：三个part
- 虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，
并提供 render 方法，将虚拟节点渲染成真实 DOM
- 节点 diff 比较：对虚拟节点进行 js 层面的计算，
并将不同的操作都记录到 patch 对象
- re-render：解析 patch 对象，进行 re-render

补充1：VDOM 的必要性？
- 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 
仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。
- 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，
让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，
然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，
以减少浏览器的重绘及回流。

补充2：vue 为什么采用 vdom？
```
引入 Virtual DOM 在性能方面的考量仅仅是一方面。
```

- 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。
- Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是：
```
不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高
运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，
运行时效率可以进一步提升；
可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，
Weex等框架应用的就是这一特性。

综上，Virtual DOM 在性能上的收益并不是最主要的，
更重要的是它使得 Vue 具备了现代框架应有的高级特性。
 ``` 
  
  #### 虚拟DOM(Virtual Dom)
为什么需要 Virtual Dom
- 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多
```
// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这里替换上面的 li
[1, 2, 5, 4]
```
- 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。

- 如果以上操作对应到 DOM 中，那么就是以下代码
```
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
```
- 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。

- 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM
- 以下是一个 JS 对象模拟 DOM 对象的简单实现
```
export default class Element {
  /**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */
  constructor(tag, props, children, key) {
    this.tag = tag
    this.props = props
    if (Array.isArray(children)) {
      this.children = children
    } else if (isString(children)) {
      this.key = children
      this.children = null
    }
    if (key) this.key = key
  }
  // 渲染
  render() {
    let root = this._createElement(
      this.tag,
      this.props,
      this.children,
      this.key
    )
    document.body.appendChild(root)
    return root
  }
  create() {
    return this._createElement(this.tag, this.props, this.children, this.key)
  }
  // 创建节点
  _createElement(tag, props, child, key) {
    // 通过 tag 创建节点
    let el = document.createElement(tag)
    // 设置节点属性
    for (const key in props) {
      if (props.hasOwnProperty(key)) {
        const value = props[key]
        el.setAttribute(key, value)
      }
    }
    if (key) {
      el.setAttribute('key', key)
    }
    // 递归添加子节点
    if (child) {
      child.forEach(element => {
        let child
        if (element instanceof Element) {
          child = this._createElement(
            element.tag,
            element.props,
            element.children,
            element.key
          )
        } else {
          child = document.createTextNode(element)
        }
        el.appendChild(child)
      })
    }
    return el
  }
}
```

- Virtual Dom 算法简述
既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。
- DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React团队优化了算法，实现了 O(n) 的复杂度来对比差异。
- 实现O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素

所以判断差异的算法就分为了两步
- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

Virtual Dom 算法实现
树的递归
- 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况
- 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了
- 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树
- 没有新的节点，那么什么都不用做
```
import { StateEnums, isString, move } from './util'
import Element from './element'

export default function diff(oldDomTree, newDomTree) {
  // 用于记录差异
  let pathchs = {}
  // 一开始的索引为 0
  dfs(oldDomTree, newDomTree, 0, pathchs)
  return pathchs
}

function dfs(oldNode, newNode, index, patches) {
  // 用于保存子树的更改
  let curPatches = []
  // 需要判断三种情况
  // 1.没有新的节点，那么什么都不用做
  // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
  // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  if (!newNode) {
  } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) {
    // 判断属性是否变更
    let props = diffProps(oldNode.props, newNode.props)
    if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props })
    // 遍历子树
    diffChildren(oldNode.children, newNode.children, index, patches)
  } else {
    // 节点不同，需要替换
    curPatches.push({ type: StateEnums.Replace, node: newNode })
  }

  if (curPatches.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(curPatches)
    } else {
      patches[index] = curPatches
    }
  }
}
```
判断属性的更改
判断属性的更改也分三个步骤
- 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
- 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
- 在第二步中同时查看是否有属性不存在与旧的属性列列表中
```
function diffProps(oldProps, newProps) {
  // 判断 Props 分以下三步骤
  // 先遍历 oldProps 查看是否存在删除的属性
  // 然后遍历 newProps 查看是否有属性值被修改
  // 最后查看是否有属性新增
  let change = []
  for (const key in oldProps) {
    if (oldProps.hasOwnProperty(key) && !newProps[key]) {
      change.push({
        prop: key
      })
    }
  }
  for (const key in newProps) {
    if (newProps.hasOwnProperty(key)) {
      const prop = newProps[key]
      if (oldProps[key] && oldProps[key] !== newProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      } else if (!oldProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      }
    }
  }
  return change
}
```

判断列表差异算法实现
```
这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 
这里的主要步骤其实和判断属性差异是类似的，也是分为三步
```
- 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
- 遍历新的节点列表，判断是否有新的节点
- 在第二步中同时判断节点是否有移动
PS：该算法只对有 key 的节点做处理
```
function listDiff(oldList, newList, index, patches) {
  // 为了遍历方便，先取出两个 list 的所有 keys
  let oldKeys = getKeys(oldList)
  let newKeys = getKeys(newList)
  let changes = []

  // 用于保存变更后的节点数据
  // 使用该数组保存有以下好处
  // 1.可以正确获得被删除节点索引
  // 2.交换节点位置只需要操作一遍 DOM
  // 3.用于 `diffChildren` 函数中的判断，只需要遍历
  // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要
  // 再去判断一遍
  let list = []
  oldList &&
    oldList.forEach(item => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找新的 children 中是否含有当前节点
      // 没有的话需要删除
      let index = newKeys.indexOf(key)
      if (index === -1) {
        list.push(null)
      } else list.push(key)
    })
  // 遍历变更后的数组
  let length = list.length
  // 因为删除数组元素是会更改索引的
  // 所有从后往前删可以保证索引不变
  for (let i = length - 1; i >= 0; i--) {
    // 判断当前元素是否为空，为空表示需要删除
    if (!list[i]) {
      list.splice(i, 1)
      changes.push({
        type: StateEnums.Remove,
        index: i
      })
    }
  }
  // 遍历新的 list，判断是否有节点新增或移动
  // 同时也对 `list` 做节点新增和移动节点的操作
  newList &&
    newList.forEach((item, i) => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找旧的 children 中是否含有当前节点
      let index = list.indexOf(key)
      // 没找到代表新节点，需要插入
      if (index === -1 || key == null) {
        changes.push({
          type: StateEnums.Insert,
          node: item,
          index: i
        })
        list.splice(i, 0, key)
      } else {
        // 找到了，需要判断是否需要移动
        if (index !== i) {
          changes.push({
            type: StateEnums.Move,
            from: index,
            to: i
          })
          move(list, index, i)
        }
      }
    })
  return { changes, list }
}

function getKeys(list) {
  let keys = []
  let text
  list &&
    list.forEach(item => {
      let key
      if (isString(item)) {
        key = [item]
      } else if (item instanceof Element) {
        key = item.key
      }
      keys.push(key)
    })
  return keys
}
```
遍历子元素打标识
对于这个函数来说，主要功能就两个
- 判断两个列表差异
  - 给节点打上标记
  - 总体来说，该函数实现的功能很简单
```
function diffChildren(oldChild, newChild, index, patches) {
  let { changes, list } = listDiff(oldChild, newChild, index, patches)
  if (changes.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(changes)
    } else {
      patches[index] = changes
    }
  }
  // 记录上一个遍历过的节点
  let last = null
  oldChild &&
    oldChild.forEach((item, i) => {
      let child = item && item.children
      if (child) {
        index =
          last && last.children ? index + last.children.length + 1 : index + 1
        let keyIndex = list.indexOf(item.key)
        let node = newChild[keyIndex]
        // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
        if (node) {
          dfs(item, node, index, patches)
        }
      } else index += 1
      last = item
    })
}
```
渲染差异
```
通过之前的算法，我们已经可以得出两个树的差异了。
既然知道了差异，就需要局部去更新 DOM 了，
下面就让我们来看看 Virtual Dom 算法的最后一步骤
```
这个函数主要两个功能
- 深度遍历树，将需要做变更操作的取出来
- 局部更新 DOM
```
let index = 0
export default function patch(node, patchs) {
  let changes = patchs[index]
  let childNodes = node && node.childNodes
  // 这里的深度遍历和 diff 中是一样的
  if (!childNodes) index += 1
  if (changes && changes.length && patchs[index]) {
    changeDom(node, changes)
  }
  let last = null
  if (childNodes && childNodes.length) {
    childNodes.forEach((item, i) => {
      index =
        last && last.children ? index + last.children.length + 1 : index + 1
      patch(item, patchs)
      last = item
    })
  }
}

function changeDom(node, changes, noChild) {
  changes &&
    changes.forEach(change => {
      let { type } = change
      switch (type) {
        case StateEnums.ChangeProps:
          let { props } = change
          props.forEach(item => {
            if (item.value) {
              node.setAttribute(item.prop, item.value)
            } else {
              node.removeAttribute(item.prop)
            }
          })
          break
        case StateEnums.Remove:
          node.childNodes[change.index].remove()
          break
        case StateEnums.Insert:
          let dom
          if (isString(change.node)) {
            dom = document.createTextNode(change.node)
          } else if (change.node instanceof Element) {
            dom = change.node.create()
          }
          node.insertBefore(dom, node.childNodes[change.index])
          break
        case StateEnums.Replace:
          node.parentNode.replaceChild(change.node.create(), node)
          break
        case StateEnums.Move:
          let fromNode = node.childNodes[change.from]
          let toNode = node.childNodes[change.to]
          let cloneFromNode = fromNode.cloneNode(true)
          let cloenToNode = toNode.cloneNode(true)
          node.replaceChild(cloneFromNode, toNode)
          node.replaceChild(cloenToNode, fromNode)
          break
        default:
          break
      }
    })
}
```
Virtual Dom 算法的实现也就是以下三步
- 通过 JS 来模拟创建 DOM 对象
- 判断两个对象的差异
- 渲染差异
```
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])

let test1 = new Element('div', { class: 'my-div' }, [test4])

let test2 = new Element('div', { id: '11' }, [test5, test4])

let root = test1.render()

let pathchs = diff(test1, test2)
console.log(pathchs)

setTimeout(() => {
  console.log('开始更新')
  patch(root, pathchs)
  console.log('结束更新')
}, 1000)
```
  
  #### 为什么使用虚拟DOM(Virtual DOM)
- 手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 
jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升
- 为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题
- 为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是Virtual DOM 出现了
- Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述DOM，Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM
- 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态
- 通过比较前后两次状态的差异更新真实 DOM

虚拟 DOM 的作用
- 维护视图和状态的关系
- 复杂视图情况下提升渲染性能
- 除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等
img

  #### Compositon api
Composition API也叫组合式API，是Vue3.x的新特性。
```
通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到
可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和
灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能
是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。
在处理如此大的应用程序时，共享和重用代码变得尤为重要
```

通俗的讲：
```
没有Composition API之前vue相关业务的代码需要配置到option的
特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的
维护性比较复杂，同时代码可复用性不高。Vue3.x中的
composition-api就是为了解决这个问题而生的
```

compositon api提供了以下几个函数：
- setup
- ref
- reactive
- watchEffect
- watch
- computed
- toRefs
- 生命周期的hooks

  #### Vue diff算法详解
- updateChildren
- 
> 这个函数是用来比较两个结点的子节点

```js
updateChildren(parentElm, oldCh, newCh) {
    let oldStartIdx = 0,
        newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx
    let idxInOld
    let elmToMove
    let before
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) { // 只有 oldS>oldE 或者 newS>newE 才会终止循环
        if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null
            oldStartVnode = oldCh[++oldStartIdx]
        } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx]
        } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx]
        } else if (newEndVnode == null) { // 到这里是找到第一个不为null的oldStartVnode oldEndVnode newStartVnode newEndVnode
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldStartVnode, newStartVnode)) { // oldS指针和newS指针对应的结点相同时，将oldS和newS指针同时向后移一位
            patchVnode(oldStartVnode, newStartVnode)
            oldStartVnode = oldCh[++oldStartIdx]
            newStartVnode = newCh[++newStartIdx]
        } else if (sameVnode(oldEndVnode, newEndVnode)) { // oldE指针和newE指针对应的结点相同时，将oldE和newE指针同时向前移一位
            patchVnode(oldEndVnode, newEndVnode)
            oldEndVnode = oldCh[--oldEndIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // oldS指针和newE指针对应的结点相同时，将oldS指针对应结点移动到oldE指针之后，同时将oldS指针向后移动一位，newE指针向前移动一位
            patchVnode(oldStartVnode, newEndVnode)
            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
            oldStartVnode = oldCh[++oldStartIdx]
            newEndVnode = newCh[--newEndIdx]
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // oldE指针和newS指针对应的结点相同时，将oldE指针对应的结点移动到oldS指针之前，同时将oldE指针向前移动一位，newS指针想后移动一位
            patchVnode(oldEndVnode, newStartVnode)
            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
            oldEndVnode = oldCh[--oldEndIdx]
            newStartVnode = newCh[++newStartIdx]
        } else { // 使用key时的比较
            if (oldKeyToIdx === undefined) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
            }
            idxInOld = oldKeyToIdx[newStartVnode.key]
            if (!idxInOld) {
                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                newStartVnode = newCh[++newStartIdx]
            } else {
                elmToMove = oldCh[idxInOld]
                if (elmToMove.sel !== newStartVnode.sel) {
                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                } else {
                    patchVnode(elmToMove, newStartVnode)
                    oldCh[idxInOld] = null
                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
                }
                newStartVnode = newCh[++newStartIdx]
            }
        }
    }
    if (oldStartIdx > oldEndIdx) { // oldVnode遍历结束了，那就将newVnode里newS指针和newE指针之间的结点添加到oldVnode里
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
    } else if (newStartIdx > newEndIdx) { // newVnode遍历结束了，那就将oldVnonde里oldS指针和oldE指针之间的结点删除
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
    }
}
```

- 时间复杂度： 个树的完全diff 算法是一个时间复杂度为O(n*3） ，vue进行优化转化成O(n) 。

- 理解：
  - 最小量更新，key 很重要。这个可以是这个节点的唯一标识，告诉diff 算法，在更改前后它们是同一个DOM节点
    - 扩展v-for 为什么要有key ，没有key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加key 只会移动减少操作DOM。
  - 只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。
  - 只进行同层比较，不会进行跨层比较。

- diff算法的优化策略：四种命中查找，四个指针
  - 旧前与新前（先比开头，后插入和删除节点的这种情况）
  - 旧后与新后（比结尾，前插入或删除的情况）
  - 旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）
  - 旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）

  #### 移动端适配的方法
```
起因:手机设备屏幕尺寸不一，做移动端的Web页面，需要考虑安卓/IOS的
各种尺寸设备上的兼容，针对移动端设备的页面，设计与前端实现怎样做
能更好地适配不同屏幕宽度的移动设备；
```

- 1. flex 弹性布局
- 2. viewport 适配

    ```html
    <meta name="viewport" content="width=750,initial-scale=0.5">
    ```

    initial-scale = 屏幕的宽度 / 设计稿的宽度

- 3. rem 弹性布局
- 4. rem + viewport 缩放

```
这也是淘宝使用的方案，根据屏幕宽度设定 rem 值，需要适配的元素都
使用 rem 为单位，不需要适配的元素还是使用 px 为单位。（1em = 16px）
```

  #### rem原理
```
rem 布局的本质是等比缩放

rem 是（根）字体大小相对单位，也就是说跟当前元素的 
font-size 没有关系，而是跟整个 body 的 font-size 有关系。
```

  #### rem和em的区别
> 一句话概括：em相对于父元素，rem相对于根元素。

- em
  ```css
  子元素字体大小的 em 是相对于父元素字体大小
  元素的width/height/padding/margin用em的话是
  相对于该元素的font-size
  ```

- rem
  ```js
  rem 是全部的长度都相对于根元素，根元素是谁？<html>元素。
  通常做法是给html元素设置一个字体大小，
  然后其他元素的长度单位就为rem。
  ```

  #### 移动端300ms延迟的原因以及解决方案
```
移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，
因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，
来判断这次操作是不是双击。
```

有三种办法来解决这个问题：
- 1. 通过 meta 标签禁用网页的缩放。

    ```html
    <meta name="viewport" content="user-scalable=no">
    ```

- 2. 更改默认的视口宽度
    ```html
    <meta name="viewport" content="width=device-width">
    ```

- 3. 调用一些 js 库，比如 FastClick
```
   FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒
   点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是
   在检测到 touchend 事件的时候，会通过 DOM 自定义事件
   立即出发模拟一个 click 事件，
   并把浏览器在 300ms 之后的click 事件阻止掉。
```

  #### vue和react技术选型
相同点：
- 数据驱动页面，提供响应式的试图组件
- 都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
- 数据流动单向，都支持服务器的渲染SSR
- 都有支持native的方法，react有React native， vue有wexx

不同点：
- 数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
- 数据渲染：大规模的数据渲染，react更快
- 使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目

```
vue是采用webpack +vue-loader单文件组件格式，html, js, css同一个文件
```

  #### Vue和React数据驱动的区别
```
在数据绑定上来说，vue的特色是双向数据绑定，
而在react中是单向数据绑定。

vue中实现数据绑定靠的是
数据劫持（Object.defineProperty()）+发布-订阅模式
```

vue中实现双向绑定
```html
<input v-model="msg" />
```

react中实现双向绑定
```html
<input value={this.state.msg} onChange={() => this.handleInputChange()} />
```

  #### 如何让CSS只在当前组件中起作用
- 将当前组件的<style>修改为<style scoped>

  #### <keep-alive></keep-alive>的作用是什么
```
keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载

<keep-alive></keep-alive> 包裹动态组件时，会缓存
不活动的组件实例,主要用于保留组件状态或避免重新渲染
比如有一个列表和一个详情，那么用户就会
经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情
都是一个频率很高的页面，那么就可以对列表组件
使用<keep-alive></keep-alive>进行缓存，这样用户每次
返回列表的时候，都能从缓存中快速渲染，而不是重新渲染

常用的两个属性include/exclude，允许组件有条件的进行缓存
两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态
```

  #### 指令v-el的作用是什么
- 提供一个在页面上已存在的 DOM元素作为 Vue实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例,

  #### 在Vue中使用插件的步骤
- 采用ES6的import ... from ...语法或CommonJS的require()方法引入插件
- 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })

  #### 请列举出3个Vue中常用的生命周期钩子函数
- created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见
- mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted被调用时 vm.$el 也在文档内。
- activated: keep-alive组件激活时调用

  ##### vue-cli工程技术集合介绍
问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？
- vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。
- vue-router：vue官方推荐使用的路由框架。
- vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。
- axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。
- vuex等：一个专为vue设计的移动端UI组件库。
- 创建一个emit.js文件，用于vue事件机制的管理。
- webpack：模块加载和vue-cli工程打包器。

问题二：vue-cli 工程常用的 npm 命令有哪些？
- 下载 node_modules 资源包的命令：
```
npm install
```

- 启动 vue-cli 开发环境的 npm命令：
```
npm run dev
```

- vue-cli 生成 生产环境部署资源 的 npm命令：
```
npm run build
```

- 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：
```
npm run build --report
```

```
在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、
manifest.js、vendor.js 文件里面所包含代码的页面。可以
具此优化 vue-cli 生产环境部署的静态资源，提升页面的加载速度
```

  #### 实现Vue SSR
SSR了解吗
- SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

- SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求

其基本实现原理
- app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。
- webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。
- 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。
- 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store里取数据。首屏的动态数据通过 window.__INITIAL_STATE__发送到客户端
```
Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的
```

- Vue SSR需要做的事多点（输出完整 HTML），除了complier -> vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。 相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点

  #### Vue组件data为什么必须是函数
- 每个组件都是 Vue 的实例。
- 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他

 #### Vue computed实现
- 建立与其他属性（如：data、 Store）的联系；
- 属性改变后，通知计算属性重新计算

实现时，主要如下
- 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。
- 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。
- Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。
- 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集

  #### Vue complier实现
- 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。
- 总的来说，Vue complier 是将 template 转化成一个 render 字符串。

可以简单理解成以下步骤：
- parse 过程，将 template 利用正则转化成AST 抽象语法树。
- optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。
- generate 过程，生成 render 字符串

  #### 怎么快速定位哪个组件出现性能问题
- 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题

  #### Proxy相比于defineProperty的优势
Object.defineProperty() 的问题主要有三个：
- 不能监听数组的变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套的对象

Proxy 在 ES2015 规范中被正式加入，它有以下几个特点
- 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题
- 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。

除了上述两点之外，Proxy 还拥有以下优势：
- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富
- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。

Proxy的优势如下:
- Proxy可以直接监听对象而非属性
- Proxy可以直接监听数组的变化
- Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

Object.defineProperty的优势如下:
- 兼容性好,支持IE9

Proxy相比于defineProperty的优势
- 数组变化也能监听到
- 不需要深度遍历监听
```
let data = { a: 1 }
let reactiveData = new Proxy(data, {
	get: function(target, name){
		// ...
	},
	// ...
})
```

#### vue-router
mode
- hash
- history

跳转
- this.$router.push()
- <router-link to=""></router-link>

占位
```
<router-view></router-view>
```

  #### vue-router有哪几种导航守卫
- 全局守卫
- 路由独享守卫
- 路由组件内的守卫

全局守卫
```
vue-router全局有三个守卫
```
- router.beforeEach 全局前置守卫 进入路由之前
- router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
- router.afterEach 全局后置钩子 进入路由之后
```
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

路由独享守卫
```
如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫
```
```
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => { 
        // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
        // ...
      }
    }
  ]
})
```

路由组件内的守卫
- beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建
- beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this
- beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this

  #### Vue与Angular以及React的区别
Vue与AngularJS的区别
- Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript
- AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。
- AngularJS社区完善, Vue的学习成本较小

Vue与React的区别
- vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；
- props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；
- 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；
- 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；
- 使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；
- 多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；
- Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；
- react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。
- react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。
- react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin

  #### scoped样式穿透
- scoped虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除scoped属性

- 使用/deep/
```
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
.wrap /deep/ .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

- 使用两个style标签
```
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
//其他样式
</style>
<style lang="scss">
.wrap .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

  #### ref的作用
- 获取dom元素this.$refs.box
- 获取子组件中的datathis.$refs.box.msg
- 调用子组件中的方法this.$refs.box.open()

  #### vue-router守卫
导航守卫 router.beforeEach 全局前置守卫
- to: Route: 即将要进入的目标（路由对象）
- from: Route: 当前导航正要离开的路由
- next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）
- 执行效果依赖 next 方法的调用参数。
- next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
- next(false):取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)
```
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫
```
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

组件内的守卫你可以在路由组件内直接定义以下路由导航守卫
```
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}
```

  #### vue修饰符
- stop：阻止事件的冒泡
- prevent：阻止事件的默认行为
- once：只触发一次
- self：只触发自己的事件行为时，才会执行

  #### vue项目中的性能优化
- 不要在模板里面写过多表达式
- 循环调用子组件时添加key
- 频繁切换的使用v-show，不频繁切换的使用v-if
- 尽量少用float，可以用flex
- 按需加载，可以用require或者import()按需加载需要的组件
- 路由懒加载

代码层面：
- 合理使用 v-if 和 v-show
- 区分 computed 和 watch 的使用
- v-for 遍历为 item 添加 key
- v-for 遍历避免同时使用 v-if
- 通过 addEventListener添加的事件在组件销毁时要用 removeEventListener 手动移除这些事件的监听
- 图片懒加载
- 路由懒加载
- 第三方插件按需引入
- SSR服务端渲染，首屏加载速度快，SEO效果好

Webpack 层面优化：
- 对图片进行压缩
- 使用 CommonsChunkPlugin 插件提取公共代码
- 提取组件的 CSS
- 优化 SourceMap
- 构建结果输出分析，利用 webpack-bundle-analyzer 可视化分析工具

你都做过哪些Vue的性能优化
- 编码阶段
  - 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
  - v-if和v-for不能连用
  - 如果需要使用v-for给每项元素绑定事件时使用事件代理
  - SPA 页面采用keep-alive缓存组件
  - 在更多的情况下，使用v-if替代v-show
  - key保证唯一
  - 使用路由懒加载、异步组件
  - 防抖、节流
  - 第三方模块按需导入
  - 长列表滚动到可视区域动态加载
  - 图片懒加载

- SEO优化
  - 预渲染
  - 服务端渲染SSR

- 打包优化
  - 压缩代码
  - Tree Shaking/Scope Hoisting
  - 使用cdn加载第三方模块
  - 多线程打包happypack
  - splitChunks抽离公共文件
  - sourceMap优化

- 用户体验
  - 骨架屏
  - PWA
```
还可以使用缓存(客户端缓存、服务端缓存)优化、
服务端开启gzip压缩等。
```

#### Vue性能优化
编码优化：
- 事件代理
- keep-alive
- 拆分组件
- key 保证唯一性
- 路由懒加载、异步组件
- 防抖节流

Vue加载性能优化
- 第三方模块按需导入（babel-plugin-component ）
- 图片懒加载

用户体验
- app-skeleton 骨架屏
- shellap p壳
- pwa

SEO优化
- 预渲染

  #### vue.extend和vue.component
- extend是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。
- Vue.component你可以创建 ，也可以取组件。

  #### Vue的SPA如何优化加载速度
- 减少入口文件体积
- 静态资源本地缓存
- 开启Gzip压缩
- 使用SSR,nuxt.js

  #### 移动端如何设计一个比较友好的Header组件
- 当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格

  #### 你是如何理解Vue的响应式系统的
响应式系统简述:
- 任何一个 Vue Component 都有一个与之对应的 Watcher 实例。
- Vue 的 data 上的属性会被添加 getter 和 setter 属性。
- 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)
- data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。

  #### 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异
现代前端框架有两种方式侦测变化,一种是pull一种是push
- pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。
- push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的

  #### Vue为什么没有类似于React中shouldComponentUpdate的生命周期
考点: Vue的变化侦测原理
前置知识: 依赖收集、虚拟DOM、响应式系统
```
根本原因是Vue与React的变化侦测方式有所不同
```
- React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.
- Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.

  #### 说一下vue2.x中如何监测数组变化
- 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

#### vue中是如何检测数组变化的呢
- 数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解

- 是用函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新
- 数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

- vue3：改用 proxy ，可直接监听对象数组的变化

  #### 你的接口请求一般放在哪个生命周期中
- 接口请求一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中

  #### Vue事件绑定原理说一下
- 原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的

#### Vue的事件绑定原理
- 原生 DOM 的绑定：Vue在创建真实DOM时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMLListeners方法，内部会传入 add（） 方法
- 组件绑定事件，原生事件，自定义事件；组件绑定之间是通过Vue中自定义的 $on 方法实现的

- 可以理解为：组件的 nativeOnOn 等价于 普通元素on 组件的on会单独处理

  #### Vue模版编译原理知道吗，能简单说一下吗
```简单说，Vue的编译过程就是将template转化为
render函数的过程。会经历以下阶段：
```
- 生成AST树
- 优化
- codegen
- 首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
- Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
- 编译的最后一步是将优化后的AST树转换为可执行的代码

  #### Vue2.x和Vue3.x渲染器的diff算法分别说一下
简单来说，diff算法有以下过程
- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心diff)
- 递归比较子节点
- 正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。
- Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅
- 在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升

  #### 再说一下虚拟Dom以及key属性的作用
- 由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因
- Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象
- VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段

key的作用是尽可能的复用 DOM 元素
- 新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的
- 需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识

  #### Vue中组件生命周期调用顺序说一下
- 组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。
- 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。

加载渲染过程
```
父beforeCreate->父created->父beforeMount->子beforeCreate->
子created->子beforeMount- >子mounted->父mounted
```

子组件更新过程
```
父beforeUpdate->子beforeUpdate->子updated->父updated
```

父组件更新过程
```
父 beforeUpdate -> 父 updated
```

销毁过程
```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

  #### 请说出vue.cli项目中src目录每个文件夹和文件的用法
- assets文件夹是放静态资源；
- components是放组件；
- router是定义路由相关的配置;
- view视图；
- app.vue是一个应用主组件；
- main.js是入口文件

  #### delete和Vue.delete删除数组的区别
- delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
- Vue.delete直接删除了数组 改变了数组的键值。
```
var a=[1,2,3,4]
var b=[1,2,3,4]
delete a[0]
console.log(a)  //[empty,2,3,4]
this.$delete(b,0)
console.log(b)  //[2,3,4]
```

  #### v-on可以监听多个方法吗
可以
```
<input type="text" :value="name" @input="onInput" @focus="onFocus" @blur="onBlur" />
```

v-on 常用修饰符
- .stop 该修饰符将阻止事件向上冒泡。同理于调用 event.stopPropagation() 方法
- .prevent 该修饰符会阻止当前事件的默认行为。同理于调用 event.preventDefault() 方法
- .self 该指令只当事件是从事件绑定的元素本身触发时才触发回调
- .once 该修饰符表示绑定的事件只会被触发一次

  #### vue如何兼容ie的问题
- babel-polyfill插件

  #### Vue改变数组触发视图更新
- 以下方法调用会改变原始数组：push(), pop(), shift(), unshift(), splice(), sort(), reverse(),Vue.set( target, key, value )

- 调用方法：Vue.set( target, key, value )
  - target：要更改的数据源(可以是对象或者数组)
  - key：要更改的具体数据
  - value ：重新赋的值

  #### DOM渲染在哪个周期中就已经完成
- 在mounted

- 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted
```
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

  #### 动态绑定class
- active classname， isActive 变量
```
<div :class="{ active: isActive }"></div>
```

#### Vue3.0是如何变得更快的
diff方法优化
- Vue2.x 中的虚拟 dom 是进行全量的对比。
- Vue3.0 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化

hoistStatic 静态提升
- Vue2.x : 无论元素是否参与更新，每次都会重新创建。
- Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用

cacheHandlers 事件侦听器缓存
- 默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可

#### 说说你对proxy的理解
vue 的数据劫持有两个缺点
- 无法监听通过索引修改数组的值的变化
- 无法监听 object 也就是对象的值的变化
- 所以 vue2.x 中才会有$set 属性的存在
- proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。

#### Composition API
- Composition API出现就是为了解决Options API导致相同功能代码分散的现象

compositon api提供了以下几个函数：
- setup
- ref
- reactive
- watchEffect
- watch
- computed
- toRefs
- 生命周期的hooks

#### 为什么Vue采用异步渲染呢
- Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick

- dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）

#### 如何从真实DOM到虚拟DOM
涉及到Vue中的模板编译原理，主要过程：
- 将模板转换成ast 树，ast 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）
- 优化树
- 将ast树生成代码

#### 为什么要使用异步组件
- 节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题。
- 核心就是包组件定义变成一个函数，依赖import（） 语法，可以实现文件的分割加载。

#### action与mutation的区别
- mutation 是同步更新，$watch 严格模式下会报错
- action 是同步操作，可以获取数据后调用mutation 提交最终数据

#### 插槽与作用域插槽的区别
插槽
- 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类{a:[vnode],b[vnode]}
- 渲染组件时会拿对应的slot 属性的节点进行替换操作。（插槽的作用域为父组件）

作用域插槽
- 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。
- 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。

#### vue中相同逻辑如何抽离
- 其实就是考察vue.mixin 用法，给组件每个生命周期，函数都混入一些公共逻辑。

#### 谈谈对keep-alive的了解
- keep-alive 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性include/exclude ，2个生命周期activated ，deactivated

#### Vue3.0相对于Vue2.x有哪些不同
performance
- 首先在性能(performance)上有了更多的优化，一方面表现在virtual dom的生成上更快了，另外在底层还做了一些监听的缓存，也就是事件在被创建的时候会被推进一个缓存中，后续没有改变会直接取缓存。

tree-shaking
- tree-shaking它表示的是在打包的时候会去除一些无用的代码。而在Vue3中对它的支持更加友好了，例如像transition、v-model、computed等功能没有用到的话，那么最后打包产生的代码就会将它们去除。也就是说，如果你的Vue项目只写了一个Hello Word的话，那么最后打包的代码中就只有一些核心的代码，如更新算法、响应式等，打包生成的文件可能就只有13.5kb。

Fragments
- 碎片(Fragments)，原本在Vue2.x中每个template下只能允许有一个根节点，但是在Vue3中它可以允许你有多个，用尤大大的话来说就是会将这些内容自动变为一个碎片。

TS
- 再者就是对TS的支持度很好。虽然Vue3本来就是用TS写的，但是不一定要用TS。另外它也支持Class Component，不过不是第一推荐。

Component API
- 语法上，对模版语法是零改变的。只不过更加推荐用Component API来写JS部分。Component API它并不是语法，而是新增的API。它带来的好处一个是逻辑重用，方便我们把一些功能的部分抽离出来。另一个它相对于options来说更加集中，用options来写代码想要追寻一个变量的变化比较麻烦。

关于兼容性
- 目前的Vue3.beta版本是不支持IE11的，因为核心的响应式原理用到了ES6的Proxy，但是以后会去兼容IE11。后面我们在创建一个Vue项目的时候，可以选择不同的版本，支持IE11和不支持IE11的。

什么时候能使用
- 现在的beta版本其实已经可以用了，对于一些新的小的项目可以试试水，这个可以自己评估。正式能够投入到生产使用中可能要等到年中 (终？)。


#### 如何监听pushState和replaceState的变化呢
利用自定义事件new Event()创建这两个事件，并全局监听：
```
<body>
  <button onclick="goPage2()">去page2</button>
  <div>Page1</div>
  <script>
    let count = 0;
    function goPage2 () {
      history.pushState({ count: count++ }, `bb${count}`,'page1.html')
      console.log(history)
    }
    // 这个不能监听到 pushState
    // window.addEventListener('popstate', function (event) {
    //   console.log(event)
    // })
    function createHistoryEvent (type) {
      var fn = history[type]
      return function () {
        // 这里的 arguments 就是调用 pushState 时的三个参数集合
        var res = fn.apply(this, arguments)
        let e = new Event(type)
        e.arguments = arguments
        window.dispatchEvent(e)
        return res
      }
    }
    history.pushState = createHistoryEvent('pushState')
    history.replaceState = createHistoryEvent('replaceState')
    window.addEventListener('pushState', function (event) {
      // { type: 'pushState', arguments: [...], target: Window, ... }
      console.log(event)
    })
    window.addEventListener('replaceState', function (event) {
      console.log(event)
    })
  </script>
</body>
```

#### Vue组件内的导航守卫有哪几个
- beforeRouteEnter
- beforeRouteUpdate
- beforeLeave

#### beforeRouteEnter和另外两个有什么不同吗
- beforeRouteEnter是支持给next传递参数的唯一守卫，因为在这个路由守卫中还不能访问this，而为了能让我们访问组件实例，可以通过传一个回调给next：
```
beforeRouteEnter(to, from, next) {
	next(vm => {
		// vm 就是组件实例
	})	
}
```
而对于另外两个，this已经可用，所以不支持传递回调：
```
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
```
- 离开守卫beforeRouteLeave通常用来禁止用户还未保存修改之前离开，可以通过next(false)来取消：
```
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

#### 完整的导航解析流程
- 导航被触发。
- 在失活的组件里调用离开守卫。
- 调用全局的 beforeEach 守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
- 在路由配置里调用 beforeEnter。
- 解析异步路由组件。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫 (2.5+)。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 触发 DOM 更新。
- 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

#### 你是怎么看Vue和React的
首先它们都是当今比较流行的前端框架。

相同点：
- Virtual DOM。其中最大的一个相似之处就是都使用了Virtual DOM。(当然Vue是在Vue2.x才引用的)也就是能让我们通过操作数据的方式来改变真实的DOM状态。因为其实Virtual DOM的本质就是一个JS对象，它保存了对真实DOM的所有描述，是真实DOM的一个映射，所以当我们在进行频繁更新元素的时候，改变这个JS对象的开销远比直接改变真实DOM要小得多。
- 组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。
- Props。Vue和React中都有props的概念，允许父组件向子组件传递数据。
- 构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，React中可以使用CRA，Vue中可以使用对应的脚手架vue-cli。对于配套框架Vue中有vuex、vue-router，React中有react-router、redux。

不同点
- 模版的编写。最大的不同就是模版的编写，Vue鼓励你去写近似常规HTML的模板，React推荐你使用JSX去书写。
- 状态管理与对象属性。在React中，应用的状态是比较关键的概念，也就是state对象，它允许你使用setState去更新状态。但是在Vue中，state对象并不是必须的，数据是由data属性在Vue对象中进行管理。
- 虚拟DOM的处理方式不同。Vue中的虚拟DOM控制了颗粒度，组件层面走watcher通知，而组件内部走vdom做diff，这样，既不会有太多watcher，也不会让vdom的规模过大。而React走了类似于CPU调度的逻辑，把vdom这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做diff。





### React

  #### React生命周期
react旧版生命周期包含三个过程：
- 1、挂载过程
constructor()
componentWillMount()
componentDidMount()

- 2、更新过程
componentWillReceiveProps(nextProps)
shouldComponentUpdate(nextProps,nextState)
componentWillUpdate (nextProps,nextState)
render()
componentDidUpdate(prevProps,prevState)

- 3、卸载过程
componentWillUnmount()

其具体作用分别为：
- 1、constructor()
完成了React数据的初始化。

- 2、componentWillMount()
组件已经完成初始化数据，但是还未渲染DOM时执行的逻辑，主要用于服务端渲染。

- 3、componentDidMount()
组件第一次渲染完成时执行的逻辑，此时DOM节点已经生成了。

- 4、componentWillReceiveProps(nextProps)
接收父组件新的props时，重新渲染组件执行的逻辑。

- 5、shouldComponentUpdate(nextProps, nextState)
在setState以后，state发生变化，组件会进入重新渲染的流程时执行的逻辑。在这个生命周期中return false可以阻止组件的更新，主要用于性能优化。

- 6、componentWillUpdate(nextProps, nextState)
shouldComponentUpdate返回true以后，组件进入重新渲染的流程时执行的逻辑。

- 7、render()
页面渲染执行的逻辑，render函数把jsx编译为函数并生成虚拟dom，然后通过其diff算法比较更新前后的新旧DOM树，并渲染更改后的节点。

- 8、componentDidUpdate(prevProps, prevState)
重新渲染后执行的逻辑。

- 9、componentWillUnmount()
组件的卸载前执行的逻辑，比如进行“清除组件中所有的setTimeout、setInterval等计时器”或“移除所有组件中的监听器removeEventListener”等操作。

react新版生命周期：
```
react16.4后使用了新的生命周期，使用getDerivedStateFromProps
代替了旧的componentWillReceiveProps及componentWillMount。
使用getSnapshotBeforeUpdate代替了旧的componentWillUpdate。
```

使用getDerivedStateFromProps(nextProps, prevState)的原因：
```
旧的React中componentWillReceiveProps方法是用来判断前后两个 props 
是否相同，如果不同，则将新的 props 更新到相应的 state 上去。
在这个过程中我们实际上是可以访问到当前props的，这样我们可能会对
this.props做一些奇奇怪怪的操作，很可能会破坏 state 数据的
单一数据源，导致组件状态变得不可预测。

而在 getDerivedStateFromProps 中禁止了组件去访问 this.props，
强制让开发者去比较 nextProps 与 prevState 中的值，以确保当
开发者用到 getDerivedStateFromProps 这个生命周期函数时，
就是在根据当前的 props 来更新组件的 state，而不是去访问
this.props并做其他一些让组件自身状态变得更加不可预测的事情。
```

使用getSnapshotBeforeUpdate(prevProps, prevState)的原因：
```
在 React 开启异步渲染模式后，在执行函数时读到的 DOM 元素状态
并不总是渲染时相同，这就导致在 componentDidUpdate 中使用 
componentWillUpdate 中读取到的 DOM 元素状态是不安全的，
因为这时的值很有可能已经失效了。

而getSnapshotBeforeUpdate 会在最终的 render 之前被调用，
也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素
状态是可以保证与componentDidUpdate 中一致的。
```

  #### 组件之间通信
- 父子组件通信
- 自定义事件
- redux和context

context如何运用
- 父组件向其下所有子孙组件传递信息
- 如一些简单的信息：主题、语言
- 复杂的公共信息用redux

  #### 组件的渲染顺序
假如有A,B,C,D组件，层级结构为：
```
   顶层       A
   子组件     B
   子组件   C   D
```

我们知道组件的生命周期为：
挂载阶段：
- constructor()
- componentWillMount()
- render()
- componentDidMount()

更新阶段为：
- componentWillReceiveProps()
- shouldComponentUpdate()
- componentWillUpdate()
- render()
- componentDidUpdate

那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？
```
以render()函数为分界线。从顶层组件开始，一直往下，
直至最底层子组件。然后再往上
```

组件update阶段同理
前面是react16以前的组建渲染方式。这就存在一个问题
```
如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行
```

Fiber架构就是为了解决这个问题
```
fiber架构 组建的渲染顺序

加入fiber的react将组件更新分为两个时期
```

这两个时期以render为分界
- render前的生命周期为phase1,
- render后的生命周期为phase2
```
phase1的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，
去确定是否有其他更重要的任务。此过程，React在 workingProgressTree 
（并不是真实的virtualDomTree）上复用 current 上的 Fiber 数据结构
来一步地（通过requestIdleCallback）来构建新的 tree，
标记处需要更新的节点，放入队列中

phase2的生命周期是不可被打断的，React 将其所有的变更一次性
更新到DOM上
```

这里最重要的是phase1这是时期所做的事。
因此我们需要具体了解phase1的机制
- 如果不被打断，那么phase1执行完会直接进入render函数，构建真实的virtualDomTree
- 如果组件再phase1过程中被打断，即当前组件只渲染到一半（也许是在willMount,也许是willUpdate~反正是在render之前的生命周期），那么react会怎么干呢？ react会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，react通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）

所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来
```
这样的话，就和react16版本之前有很大区别了，因为可能会被执行多次，
那么我们最好就得保证phase1的生命周期每一次执行的结果都是一样的，
否则就会有问题，因此，最好都是纯函数
```
- 如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决
- 所以，facebook在react16增加fiber结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿

  #### React组件和渲染更新过程
渲染和更新过程
- jsx如何渲染为页面
- setState之后如何更新页面
- 面试考察全流程

JSX本质和vdom
- JSX即createElement函数
- 执行生成vnode
- patch(elem,vnode)和patch(vnode,newNode)

组件渲染过程
- props state
- render()生成vnode
- patch(elem, vnode)

组件更新过程
- setState-->dirtyComponents(可能有子组件)
- render生成newVnode
- patch(vnode, newVnode)

  #### React都做过哪些优化
- React渲染页面的两个阶段
  - 调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。
  - 渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上

- React 15 架构
  - React15架构可以分为两层
    - Reconciler（协调器）—— 负责找出变化的组件；
    - Renderer（渲染器）—— 负责将变化的组件渲染到页面上；

```
  在React15及以前，Reconciler采用递归的方式创建虚拟DOM，
递归过程是不能中断的。如果组件树的层级很深，递归会占用线程
很多时间，递归更新时间超过了16ms，用户交互就会卡顿。

  为了解决这个问题，React16将递归的无法中断的更新重构为异步的
可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。
于是，全新的Fiber架构应运而生。
```

- React 16 架构
  - 为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。
  - 从v15到v16，React团队花了两年时间将源码架构中的Stack Reconciler重构为Fiber Reconciler
  - React16架构可以分为三层：
    - Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler；
    - Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构；
    - Renderer（渲染器）—— 负责将变化的组件渲染到页面上。

- React 17 优化
  - 使用Lane来管理任务的优先级。Lane用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。
  - Concurrent Mode的目的是实现一套可中断/恢复的更新机制。其由两部分组成：
    - 一套协程架构：Fiber Reconciler
    - 基于协程架构的启发式更新算法：控制协程架构工作方式的算法

  #### React有哪些优化性能的手段
类组件中的优化手段
- 使用纯组件 PureComponent 作为基类。
- 使用 React.memo 高阶函数包装组件。
- 使用 shouldComponentUpdate 生命周期函数来自定义渲染逻辑。

方法组件中的优化手段
- 使用 useMemo。
- 使用 useCallBack。

其他方式
- 在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
- 必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
- 使用 Suspense 和 lazy 进行懒加载，例如：
```
import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    var ComponentToLazyLoad = null;

    if (this.props.name == "Mayank") {
      ComponentToLazyLoad = lazy(() => import("./mayankComponent"));
    } else if (this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() => import("./anshulComponent"));
    }

    return (
      <div>
        <h1>This is the Base User: {this.state.name}</h1>
        <Suspense fallback={<div>Loading...</div>}>
          <ComponentToLazyLoad />
        </Suspense>
      </div>
    )
  }
}
```

  #### diff算法是怎么运作
```
每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，
react会先比较该节点类型，假如节点类型不一样，那么react会直接
删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，
那么会比较prop是否有更新，假如有prop不一样，那么react会判定
该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，
一层一层往下，直到没有子节点
```

- 把树形结构按照层级分解，只比较同级元素。
- 给列表结构的每个单元添加唯一的key属性，方便比较。
- React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）
- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty的 component重新绘制.
- 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能

优化
```
为了降低算法复杂度，React的diff会预设三个限制：
```
- 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。
- 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
- 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：

Diff的思路
该如何设计算法呢？如果让我设计一个Diff算法，我首先想到的方案是：
```
判断当前节点的更新属于哪种情况
如果是新增，执行新增逻辑
如果是删除，执行删除逻辑
如果是更新，执行更新逻辑
```
- 按这个方案，其实有个隐含的前提——不同操作的优先级是相同的
- 但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。

基于以上原因，Diff算法的整体逻辑会经历两轮遍历：
- 第一轮遍历：处理更新的节点。
- 第二轮遍历：处理剩下的不属于更新的节点。


diff算法的作用
```
计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，
而非重新渲染整个页面。
```

传统diff算法
```
通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3) ，n是树
的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。
即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。
```

React的diff算法
```
什么是调和？
将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。

什么是React diff算法？
diff算法是调和的具体实现。
```

diff策略
```
React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度
```

策略一（tree diff）：
- Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。

策略二（component diff）：
- 拥有相同类的两个组件 生成相似的树形结构，
- 拥有不同类的两个组件 生成不同的树形结构。

策略三（element diff）：
对于同一层级的一组子节点，通过唯一id区分。
tree diff
- React通过updateDepth对Virtual DOM树进行层级控制。
- 对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。
- 只需遍历一次，就能完成整棵DOM树的比较。

那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？
```
答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，
只有创建节点和删除节点的操作。

以A为根节点的整棵树会被重新创建，而不是移动，因此官方建议
不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，
而不是真正地移除、添加DOM节点
```

component diff
```
React对不同的组件间的比较，有三种策略
```

- 同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。
- 同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 shouldComponentUpdate() 来判断是否需要 判断计算。
- 不同类型的组件，将一个（将被改变的）组件判断为dirty component（脏组件），从而替换 整个组件的所有节点。

```
注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。
```

element diff
```
当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。
```
- 插入：组件 C 不在集合（A,B）中，需要插入
- 删除：
  - 组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。
  - 组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。
- 移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即可。

总结
- tree diff：只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动
```
react 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下
的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，
不会用于进一步的比较。

这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

这就意味着，如果 dom 节点发生了跨层级移动，react 会删除旧的节点，
生成新的节点，而不会复用。
```

- component diff：如果不是同一类型的组件，会删除旧的组件，创建新的组件

- element diff：对于同一层级的一组子节点，需要通过唯一 id 进行来区分
```
  如果没有 id 来进行区分，一旦有插入动作，
会导致插入位置之后的列表全部重新渲染

  这也是为什么渲染列表时为什么要使用唯一的 key。
```

diff的不足与待优化的地方
```
尽量减少类似将最后一个节点移动到列表首部的操作，
当节点数量过大或更新操作过于频繁时，会影响React的渲染性能
```

  #### React router
react-router如何配置懒加载
```
import { BrowserRouter as Router, Route, Switch } from ' react- router-dom' ;
import React, { Suspense, lazy } from 'react' ;
const Home = lazy(() => import(' ./ routes/Home'));
const About = lazy(() => import('./ routes/About'));
constApp=()=>(
<Router>
<Suspense fallback= {<div>Loading... </div>}>
<Switch>
<Route exact path="/" component= {Home}/>
Route path=" / about" component= {About}/>
</ Switch>
</ Suspense>
</Route r>
);
```




- [jQuery](#jQuery)
  - [](#)  2 jQuery 的实现原理
  - [](#)  12 针对 jQuery 的优化方法
  - [](#)  17 jQuery对象的特点
  - [](#)  1 你觉得jQuery或zepto源码有哪些写的好的地方
  - [](#)  11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的
  - [](#)  5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝
  - [](#)  6 jQuery 的队列是如何实现的
  - [](#)  10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来
  - [](#)  9 jQuery 通过哪个方法和 Sizzle 选择器结合的
  - [](#)  3 jQuery.fn 的 init 方法返回的 this 指的是什么对象
  - [](#)  4 jQuery.extend 与 jQuery.fn.extend 的区别
  - [](#)  7 jQuery 中的 bind(), live(), delegate(), on()的区别
  - [](#)  8 是否知道自定义事件
  - [](#)  14 jQuery UI 如何自定义组件
  - [](#)  15 jQuery 与 jQuery UI、jQuery Mobile 区别
  - [](#)  13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢
  - [](#)  16 jQuery 和 Zepto 的区别？ 各自的使用场景



#### 针对jQuery的优化方法

```
缓存频繁操作DOM对象
尽量使用id选择器代替class选择器
总是从#id选择器来继承
尽量使用链式操作
使用时间委托 on绑定事件
采用jQuery的内部函数data()来存储数据
使用最新版本的 jQuery
```



- [微信小程序](#微信小程序)
  - [](#)  5 微信小程序与vue区别
  - [](#)  1 微信小程序有几个文件
  - [](#)  2 微信小程序怎样跟事件传值
  - [](#)  3 小程序的 wxss 和 css 有哪些不一样的地方？
  - [](#)  4 小程序关联微信公众号如何确定用户的唯一性



### webpack相关

#### webpack原理简述
#### 核心概念
- JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。

- Entry: 入口文件，Webpack会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

#### 工作流程(加载-编译-输出)
- 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象；
- 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译；
- 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步；
- 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改;
- 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程；

#### 模块包装
```
(function(modules) {
	// 模拟 require 函数，从内存中加载模块；
	function __webpack_require__(moduleId) {
		// 缓存模块
		if (installedModules[moduleId]) {
			return installedModules[moduleId].exports;
		}
		
		var module = installedModules[moduleId] = {
			i: moduleId,
			l: false,
			exports: {}
		};
		
		// 执行代码；
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		
		// Flag: 标记是否加载完成；
		module.l = true;
		
		return module.exports;
	}
	
	// ...
	
	// 开始执行加载入口文件；
	return __webpack_require__(__webpack_require__.s = "./src/index.js");
 })({
 	"./src/index.js": function (module, __webpack_exports__, __webpack_require__) {
		// 使用 eval 执行编译后的代码；
		// 继续递归引用模块内部依赖；
		// 实际情况并不是使用模板字符串，这里是为了代码的可读性；
		eval(`
			__webpack_require__.r(__webpack_exports__);
			//
			var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("test", ./src/test.js");
		`);
	},
	"./src/test.js": function (module, __webpack_exports__, __webpack_require__) {
		// ...
	},
 })
```
总结:
- 模块机制: webpack自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- 文件编译: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

#### webpack的打包原理
- 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- 确定入口：根据配置中的 entry 找出所有的入口文件
- 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

#### 总结
- 初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。
- 开始编译：从上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。
- 确定入口：根scope据配置中的 entry 找出所有的入口文件。
- 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。
- 完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。
- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

#### webpack热更新原理
- 当修改了一个或多个文件；
- 文件系统接收更改并通知 webpack；
- webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；
- HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp
- HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新

#### webpack Loader
- 由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 不同格式文件转换器。其实 Loader 做的事，也并不难理解: 对 Webpack 传入的字符串进行按需修改。例如一个最简单的 Loader:
```
// html-loader/index.js
module.exports = function(htmlSource) {
	// 返回处理后的代码字符串
	// 删除 html 文件中的所有注释
	return htmlSource.replace(/<!--[\w\W]*?-->/g, '')
}
```
- 当然，实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 Babel-loader 会执行以下步骤:

- babylon 将 ES6/ES7 代码解析成 AST
- babel-traverse 对 AST 进行遍历转译，得到新的 AST
- 新 AST 通过 babel-generator 转换成 ES5

Loader 特性:
- 链式传递，按照配置时相反的顺序链式执行；
- 基于 Node 环境，拥有 较高权限，比如文件的增删查改；
- 可同步也可异步；

常用 Loader:
- file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；
- url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；
- babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；
- ts-loader: 加载 ts / tsx 文件，编译 TypeScript；
- style-loader: 将 css 代码以<style>标签的形式插入到 html 中；
- css-loader: 分析@import和url()，引用 css 文件与对应的资源；
- postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；
- less-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；

编写原则:
- 单一原则: 每个 Loader 只做一件事；
- 链式调用: Webpack 会按顺序链式调用每个 Loader；
- 统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

#### webpack Plugin
- 插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。

一个最简单的 plugin 是这样的:
```
class Plugin{
  	// 注册插件时，会调用 apply 方法
  	// apply 方法接收 compiler 对象
  	// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作
  	apply(compiler){
  		// compilation 是监听每次编译循环
  		// 每次文件变化，都会生成新的 compilation 对象并触发该事件
    	compiler.plugin('compilation',function(compilation) {})
  	}
}
```

注册插件:
```
// webpack.config.js
module.export = {
	plugins:[
		new Plugin(options),
	]
}
```

事件流机制:
```
Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 
与 Plugin 的一道道处理，最后输出结果。
```
- 通过链式调用，按顺序串起一个个 Loader；
- 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中；
```
Webpack 事件流编程范式的核心是基础类 Tapable，
是一种观察者模式的实现事件的订阅与广播：
```

```
const { SyncHook } = require("tapable")

const hook = new SyncHook(['arg'])

// 订阅
hook.tap('event', (arg) => {
	// 'event-hook'
	console.log(arg)
})

// 广播
hook.call('event-hook')
```

```Webpack 中两个最重要的类 Compiler 与 Compilation 
便是继承于 Tapable，也拥有这样的事件流机制。
```
- Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递；

- Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子；

- 区别:
  - Compiler 全局唯一，且从启动生存到结束；
  - Compilation对应每次编译，每轮编译循环均会重新创建；

- 常用 Plugin:
  - UglifyJsPlugin: 压缩、混淆代码；
  - CommonsChunkPlugin: 代码分割；
  - ProvidePlugin: 自动加载模块；
  - html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；
  - extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；
  - optimize-css-assets-webpack-plugin: CSS 代码去重；
  - webpack-bundle-analyzer: 代码分析；
  - compression-webpack-plugin: 使用 gzip 压缩 js 和 css；
  - happypack: 使用多进程，加速代码构建；
  - EnvironmentPlugin: 定义环境变量；
- 调用插件 apply 函数传入 compiler 对象
- 通过 compiler 对象监听事件

loader和plugin有什么区别？
- webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。

- loader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。
- plugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。

webpack中都有哪些插件，这些插件有什么作用？
- html-webpack-plugin 自动创建一个HTML文件，并把打包好的JS插入到HTML文件中
- clean-webpack-plugin 在每一次打包之前，删除整个输出文件夹下所有的内容
- mini-css-extrcat-plugin 抽离CSS代码，放到一个单独的文件中
- optimize-css-assets-plugin 压缩css

实现一个编译结束退出命令的插件
```
apply (compiler) {
  const afterEmit = (compilation, cb) => {
    cb()
    setTimeout(function () {
      process.exit(0)
    }, 1000)
  }

  compiler.plugin('after-emit', afterEmit)
}
}

module.exports = BuildEndPlugin
```

```
<script>
export default {
  mounted () {
    var isGithub = location.href.indexOf('FE-Interview-Questions')!==-1
    var sId = isGithub ? '59154049' : '66575297'
    var script = document.createElement("script");
    script.type = "text/javascript"
    script.charset="UTF-8"
    script.src = `http://tajs.qq.com/stats?sId=${sId}`
    document.body.appendChild(script);
  }
}
</script>
```

#### webpack编译优化
代码优化:
- 无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；

- 例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如:
```
var fn = function() {
	return 1;
	// 下面代码便属于 不可能执行的代码；
	// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；
	var a = 1;
	return a;
}
```
- 摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 "摇" 我们打包后的 js 代码，将没有使用到的无用代码 "摇" 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。

- 原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。
- 问题: 具有 副作用 的函数无法被 tree-shaking
  - 在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；
  - 尽量写纯函数，减少函数的副作用；
  - 可使用 webpack-deep-scope-plugin，可以进行作用域分析，减少此类情况的发生，但仍需要注意；
- code-spliting: 代码分割技术，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；
- Webpack 中使用 SplitChunksPlugin 进行拆分；
- 按 页面 拆分: 不同页面打包成不同的文件；
- 按 功能 拆分:
  - 将类似于播放器，计算库等大模块进行拆分后再懒加载引入；
  - 提取复用的业务代码，减少冗余代码；
- 按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；
- scope hoisting: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；

编译性能优化:
- 升级至 最新 版本的 webpack，能有效提升编译性能；
- 使用 dev-server / 模块热替换 (HMR) 提升开发体验；
  - 监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；
- 缩小编译范围
  - modules: 指定模块路径，减少递归搜索；
  - mainFields: 指定入口文件描述字段，减少搜索；
  - noParse: 避免对非模块化文件的加载；
  - includes/exclude: 指定搜索范围/排除不必要的搜索范围；
  - alias: 缓存目录，避免重复寻址；
- babel-loader
  - 忽略node_moudles，避免编译第三方库中已经被编译过的代码
  - 使用cacheDirectory，可以缓存编译结果，避免多次重复编译
- 多进程并发
  - webpack-parallel-uglify-plugin: 可多进程并发压缩 js 文件，提高压缩速度；
  - HappyPack: 多进程并发文件的 Loader 解析；
- 第三方库模块缓存:
  - DLLPlugin 和 DLLReferencePlugin 可以提前进行打包并缓存，避免每次都重新编译；
- 使用分析
  - Webpack Analyse / webpack-bundle-analyzer 对打包后的文件进行分析，寻找可优化的地方
  - 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方
- source-map:
  - 开发: cheap-module-eval-source-map
  - 生产: hidden-source-map；

#### 优化webpack打包速度
- 减少文件搜索范围
  - 比如通过别名
  - loader 的 test，include & exclude
- - Webpack4 默认压缩并行
- Happypack 并发调用
- babel 也可以缓存编译

#### webpack import()原理
#### 动态导入原理
用于动态加载的import()方法
- 这个功能可以实现按需加载我们的代码，并且使用了promise式的回调，获取加载的包
- 在代码中所有被import()的模块，都将打成一个单独的包，放在chunk存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载
```
// 这里是一个简单的demo。
// 可以看到，import()的语法十分简单。该函数只接受一个参数，就是引用包的地址
import('lodash').then(_ => {
  // Do something with lodash (a.k.a '_')...
 })
```

#### webpack中如何实现动态导入
- 使用import(/** webpackChunkName: "lodash" **/ 'lodash').then(_ => {})，同时可以在webpack.config.js中配置一下output的chunkFilename为[name].bunld.js将要导入的模块单独抽离到一个bundle中，以此实现代码分离。
- 使用async，由于import()返回的是一个promise, 因此我们可以使用async函数来简化它，不过需要babel这样的预处理器及处理转换async的插件。const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');

#### webpack有哪几种文件指纹
- hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值。(粒度整个项目)
- chunkhash是根据不同的入口进行依赖文件解析，构建对应的chunk(模块)，生成对应的hash值。只有被修改的chunk(模块)在重新构建之后才会生成新的hash值，不会影响其它的chunk。(粒度entry的每个入口文件)
- contenthash是跟每个生成的文件有关，每个文件都有一个唯一的hash值。当要构建的文件内容发生改变时，就会生成新的hash值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

#### webpack如果使用了hash命名，那是每次都会重写生成hash吗
有三种情况：
- 如果是hash的话，是和整个项目有关的，有一处文件发生更改则所有文件的hash值都会发生改变且它们共用一个hash值；
- 如果是chunkhash的话，只和entry的每个入口文件有关，也就是同一个chunk下的文件有所改动该chunk下的文件的hash值就会发生改变
- 如果是contenthash的话，和每个生成的文件有关，只有当要构建的文件内容发生改变时才会给该文件生成新的hash值，并不会影响其它文件。

#### webpack中如何处理图片的
在webpack中有两种处理图片的loader：
- file-loader：解决CSS等中引入图片的路径问题；(解决通过url,import/require()等引入图片的问题)
- url-loader：当图片小于设置的limit参数值时，url-loader将图片进行base64编码(当项目中有很多图片，通过url-loader进行base64编码后会减少http请求数量，提高性能)，大于limit参数值，则使用file-loader拷贝图片并输出到编译目录中；

#### webpack常用插件总结
1. 功能类
1.1 html-webpack-plugin
```
自动生成html，基本用法：
```
```
new HtmlWebpackPlugin({
  filename: 'index.html', // 生成文件名
  template: path.join(process.cwd(), './index.html') // 模班文件
})
```

1.2 copy-webpack-plugin
```
拷贝资源插件
```
```
new CopyWebpackPlugin([
  {
    from: path.join(process.cwd(), './vendor/'),
    to: path.join(process.cwd(), './dist/'),
    ignore: ['*.json']
  }
])
```

1.3 webpack-manifest-plugin && assets-webpack-plugin
```
俩个插件效果一致，都是生成编译结果的资源单，
只是资源单的数据结构不一致而已
```
webpack-manifest-plugin 基本用法
```
module.exports = {
  plugins: [
    new ManifestPlugin()
  ]
}
```
assets-webpack-plugin 基本用法
```
module.exports = {
  plugins: [
    new AssetsPlugin()
  ]
}
```
1.4 clean-webpack-plugin
```
在编译之前清理指定目录指定内容
```
```
// 清理目录
const pathsToClean = [
  'dist',
  'build'
]
 
// 清理参数
const cleanOptions = {
  exclude:  ['shared.js'], // 跳过文件
}
module.exports = {
  // ...
  plugins: [
    new CleanWebpackPlugin(pathsToClean, cleanOptions)
  ]
}
```
1.5 compression-webpack-plugin
```
提供带 Content-Encoding 编码的压缩版的资源
```
```
module.exports = {
  plugins: [
    new CompressionPlugin()
  ]
}
```
1.6 progress-bar-webpack-plugin
```
编译进度条插件
```
```
module.exports = {
  //...
  plugins: [
    new ProgressBarPlugin()
  ]
}
```
2. 代码相关类
2.1 webpack.ProvidePlugin
```
自动加载模块，如 $ 出现，就会自动加载模块；
$ 默认为'jquery'的exports
```
```
new webpack.ProvidePlugin({
  $: 'jquery',
})
```
2.2 webpack.DefinePlugin
```
定义全局常量
```
```
new webpack.DefinePlugin({
  'process.env': {
    NODE_ENV: JSON.stringify(process.env.NODE_ENV)
  }
})
```
2.3 mini-css-extract-plugin && extract-text-webpack-plugin
```
提取css样式，对比
```
- mini-css-extract-plugin 为webpack4及以上提供的plugin，支持css chunk
- extract-text-webpack-plugin 只能在webpack3 及一下的版本使用，不支持css chunk

基本用法 extract-text-webpack-plugin
```
const ExtractTextPlugin = require("extract-text-webpack-plugin");
 
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",
          use: "css-loader"
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin("styles.css"),
  ]
}
```
基本用法 mini-css-extract-plugin
```
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
    module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '/'  // chunk publicPath
            }
          },
          "css-loader"
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].css", // 主文件名
      chunkFilename: "[id].css"  // chunk文件名
    })
  ]
}
```

3. 编译结果优化类
3.1 wbepack.IgnorePlugin
```
忽略regExp匹配的模块
```
```
new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
```
3.2 uglifyjs-webpack-plugin
```
代码丑化，用于js压缩
```
```
module.exports = {
  //...
  optimization: {
    minimizer: [new UglifyJsPlugin({
      cache: true,   // 开启缓存
      parallel: true, // 开启多线程编译
      sourceMap: true,  // 是否sourceMap
      uglifyOptions: {  // 丑化参数
        comments: false,
        warnings: false,
        compress: {
          unused: true,
          dead_code: true,
          collapse_vars: true,
          reduce_vars: true
        },
        output: {
          comments: false
        }
      }
    }]
  }
};
```
3.3 optimize-css-assets-webpack-plugin
```
css压缩，主要使用 cssnano 压缩器 https://github.com/cssnano/cssnano
```
```
module.exports = {
  //...
  optimization: {
    minimizer: [new OptimizeCssAssetsPlugin({
      cssProcessor: require('cssnano'),   // css 压缩优化器
      cssProcessorOptions: { discardComments: { removeAll: true } } // 去除所有注释
    })]
  }
};
```
3.4 webpack-md5-hash
```
使你的chunk根据内容生成md5，用这个md5取代 webpack chunkhash。
```
```
var WebpackMd5Hash = require('webpack-md5-hash');
 
module.exports = {
  // ...
  output: {
    //...
    chunkFilename: "[chunkhash].[id].chunk.js"
  },
  plugins: [
    new WebpackMd5Hash()
  ]
};
```
3.5 SplitChunksPlugin
- CommonChunkPlugin 的后世，用于chunk切割。
- webpack 把 chunk 分为两种类型，一种是初始加载initial chunk，另外一种是异步加载 async chunk，如果不配置SplitChunksPlugin，webpack会在production的模式下自动开启，默认情况下，webpack会将 node_modules 下的所有模块定义为异步加载模块，并分析你的 entry、动态加载（import()、require.ensure）模块，找出这些模块之间共用的node_modules下的模块，并将这些模块提取到单独的chunk中，在需要的时候异步加载到页面当中，其中默认配置如下
```
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async', // 异步加载chunk
      minSize: 30000,
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '~', // 文件名中chunk分隔符
      name: true,
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,  // 
          priority: -10
        },
        default: {
          minChunks: 2,  // 最小的共享chunk数
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```
4. 编译优化类
4.1 DllPlugin && DllReferencePlugin && autodll-webpack-plugin
- dllPlugin将模块预先编译，DllReferencePlugin 将预先编译好的模块关联到当前编译中，当 webpack 解析到这些模块时，会直接使用预先编译好的模块。
- autodll-webpack-plugin 相当于 dllPlugin 和 DllReferencePlugin 的简化版，其实本质也是使用 dllPlugin && DllReferencePlugin，它会在第一次编译的时候将配置好的需要预先编译的模块编译在缓存中，第二次编译的时候，解析到这些模块就直接使用缓存，而不是去编译这些模块

dllPlugin 基本用法：
```
const output = {
  filename: '[name].js',
  library: '[name]_library',
  path: './vendor/'
}

module.exports = {
  entry: {
    vendor: ['react', 'react-dom']  // 我们需要事先编译的模块，用entry表示
  },
  output: output,
  plugins: [
    new webpack.DllPlugin({  // 使用dllPlugin
      path: path.join(output.path, `${output.filename}.json`),
      name: output.library // 全局变量名， 也就是 window 下 的 [output.library]
    })
  ]
}
```
DllReferencePlugin 基本用法：
```
const manifest = path.resolve(process.cwd(), 'vendor', 'vendor.js.json')

module.exports = {
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: require(manifest), // 引进dllPlugin编译的json文件
      name: 'vendor_library' // 全局变量名，与dllPlugin声明的一致
    }
  ]
}
```
autodll-webpack-plugin 基本用法：
```
module.exports = {
  plugins: [
    new AutoDllPlugin({
      inject: true, // 与 html-webpack-plugin 结合使用，注入html中
      filename: '[name].js',
      entry: {
        vendor: [
          'react',
          'react-dom'
        ]
      }
    })
  ]
}
```
4.2 happypack && thread-loader
```
多线程编译，加快编译速度，thread-loader不可以和 
mini-css-extract-plugin 结合使用
```
happypack 基本用法
```
const HappyPack = require('happypack');
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });
const happyLoaderId = 'happypack-for-react-babel-loader';

module.exports = {
  module: {
    rules: [{
      test: /\.jsx?$/,
      loader: 'happypack/loader',
      query: {
        id: happyLoaderId
      },
      include: [path.resolve(process.cwd(), 'src')]
    }]
  },
  plugins: [new HappyPack({
    id: happyLoaderId,
    threadPool: happyThreadPool,
    loaders: ['babel-loader']
  })]
}
```
thread-loader 基本用法
```
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve("src"),
        use: [
          "thread-loader",
          // your expensive loader (e.g babel-loader)
          "babel-loader"
        ]
      }
    ]
  }
}
```
4.3 hard-source-webpack-plugin && cache-loader
```
使用模块编译缓存，加快编译速度
```
hard-source-webpack-plugin 基本用法
```
module.exports = {
  plugins: [
    new HardSourceWebpackPlugin()
  ]
}
```
cache-loader 基本用法
```
module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          'cache-loader',
          ...loaders
        ],
        include: path.resolve('src')
      }
    ]
  }
}
```
5. 编译分析类
5.1 webpack-bundle-analyzer
```
编译模块分析插件
```
```
new BundleAnalyzerPlugin({
  analyzerMode: 'server',
  analyzerHost: '127.0.0.1',
  analyzerPort: 8889,
  reportFilename: 'report.html',
  defaultSizes: 'parsed',
  generateStatsFile: false,
  statsFilename: 'stats.json',
  statsOptions: null,
  logLevel: 'info'
}),
```
5.2 stats-webpack-plugin && PrefetchPlugin
- stats-webpack-plugin 将构建的统计信息写入文件，该文件可在 http://webpack.github.io/analyse中上传进行编译分析，并根据分析结果，可使用 PrefetchPlugin 对部分模块进行预解析编译

stats-webpack-plugin 基本用法：
```
module.exports = {
  plugins: [
    new StatsPlugin('stats.json', {
      chunkModules: true,
      exclude: [/node_modules[\\\/]react/]
    })
  ]
};
```
PrefetchPlugin 基本用法：
```
module.exports = {
  plugins: [
    new webpack.PrefetchPlugin('/web/', 'app/modules/HeaderNav.jsx'),
    new webpack.PrefetchPlugin('/web/', 'app/pages/FrontPage.jsx')
];
}
```
5.3 speed-measure-webpack-plugin
统计编译过程中，各loader和plugin使用的时间
```
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
 
const smp = new SpeedMeasurePlugin();
 
const webpackConfig = {
  plugins: [
    new MyPlugin(),
    new MyOtherPlugin()
  ]
}
module.exports = smp.wrap(webpackConfig);
```

#### 抽象语法树AST
- 抽象语法树（Abstract Syntax Tree），是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查、代码风格检查、代码格式化、代码高亮、代码错误提示、代码自动补全等等的基础
```
// 转换前
function square(n) {
  return n * n
}

// 转换后
const element = {
  type: "FunctionDeclaration",
  start: 0,
  end: 35,
  id: Identifier,
  expression: false,
  generator: false,
  params: [1, element],
  body: BlockStatement
}
```

#### 使用babel-loader会有哪些问题？可以怎样优化
- 会使得编译很慢。解决办法是可以在webpack的babel-loader配置中使用exclude这个可选项来去除一些不需要编译的文件夹(例如node_modules和bower_components)，另一种可以设置cacheDirectory选项为true, 开启缓存, 转译的结果将会缓存到文件系统中, 这样使babel-loader至少提速两倍(代码量越多效果应该越明显)。
- babel-loader使得打包文件体积过大。Babel 对一些公共方法使用了非常小的辅助代码, 比如 _extend.默认情况下会被添加到每一个需要它的文件中, 所以会导致打包文件体积过大.解决办法: 引入babel runtime作为一个单独的模块, 来避免重复。也就是可以使用@babel/plugin-transform-runtime和babel-runtime。

#### Babel原理
- babel 的编译过程分为三个阶段：parsing、transforming、generating，以 ES6 编译为 ES5 作为例子：

- ES6 代码输入；
- babylon 进行解析得到 AST；
- plugin 用 babel-traverse 对 AST树进行遍历编译，得到新的 AST树；
- 用 babel-generator 通过 AST树生成 ES5 代码。
Babel原理及其使用(opens new window)

#### Babel是如何编译Class的
就拿下面的类来说：
```
class Person {
  constructor ({ name }) {
    this.name = name
    this.getSex = function () {
      return 'boy'
    }
  }
  getName () {
    return this.name
  }
  static getLook () {
    return 'sunshine'
  }
}
```
- 当我们在使用babel的这些plugin或者使用preset的时候，有一个配置属性loose它默认是为false，在这样的条件下：

Class编译后：
- 总体来说Class会被封装成一个IIFE立即执行函数
- 立即执行函数返回的是一个与类同名的构造函数
- 实例属性和方法定义在构造函数内(如name和getSex())
- 类内部声明的属性方法(getName)和静态属性方法(getLook)是会被Object.defineProperty所处理，将其可枚举属性设置为false

编译后的代码：
```
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Person = /*#__PURE__*/ (function () {
  function Person(_ref) {
    var name = _ref.name;

    _classCallCheck(this, Person);

    this.name = name;

    this.getSex = function () {
      return "boy";
    };
  }

  _createClass(
    Person,
    [
      {
        key: "getName",
        value: function getName() {
          return this.name;
        },
      },
    ],
    [
      {
        key: "getLook",
        value: function getLook() {
          return "sunshine";
        },
      },
    ]
  );

  return Person;
})();
```
- 为什么Babel对于类的处理会使用Object.defineProperty这种形式呢？它和直接使用原型链有什么不同吗？

- 通过原型链声明的属性和方法是可枚举的，也就是可以被for...of...搜寻到
- 而类内部声明的方法是不可枚举的

- 所以，babel为了符合ES6真正的语义，编译类时采取了Object.defineProperty来定义原型方法。

- 但是可以通过设置babel的loose模式(宽松模式)为true，它会不严格遵循ES6的语义，而采取更符合我们平常编写代码时的习惯去编译代码，在.babelrc中可以如下设置：
```
{
  "presets": [["env", { "loose": true }]]
}
```
- 比如上述的Person类的属性方法将会编译成直接在原型链上声明方法：
```
"use strict";

var Person = /*#__PURE__*/function () {
  function Person(_ref) {
    var name = _ref.name;
    this.name = name;

    this.getSex = function () {
      return 'boy';
    };
  }

  var _proto = Person.prototype;

  _proto.getName = function getName() {
    return this.name;
  };

  Person.getLook = function getLook() {
    return 'sunshine';
  };

  return Person;
}();
```

总结
- 当使用Babel编译时默认的loose为false，即非宽松模式
- 无论哪种模式，转换后的定义在类内部的属性方法是被定义在构造函数的原型对象上的；静态属性被定义到构造函数上
- 只不过非宽松模式时，这些属性方法会被_createClass函数处理，函数内通过Object.defineProperty()设置属性的可枚举值enumerable为false
- 由于在_createClass函数内使用了Object，所以非宽松模式下是会产生副作用的，而宽松模式下不会。
- webpack中的UglifyJS依旧还是会将宽松模式认为是有副作用的，而rollup有程序流程分析的功能，可以更好的判断代码是否真正产生副作用，所以它会认为宽松模式没有副作用。
- (副作用大致理解为：一个函数会、或者可能会对函数外部变量产生影响的行为。)

#### babel-polyfill是什么
- ployfill是补丁
- babel-polyfill现在已经被弃用

- babel 7.4之后弃用babel-polyfill
- 直接推荐使用core-js和regenerator

babel-polyfill按需引入
- 文件较大
- 只用一部分功能，无需全部引入
- 配置按需引入
 
babel-polyfill的问题
- 会污染全局环境
- 如果做一个独立的web系统，无碍
- 如果做一个第三个的lib，会有问题
 
#### Tree Shaking原理是什么
对tree-shaking的了解
作用：
- 它表示在打包的时候会去除一些无用的代码

原理：
- ES6的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码

特点：
- 在生产模式下它是默认开启的，但是由于经过babel编译全部模块被封装成IIFE，它存在副作用无法被tree-shaking掉
- 可以在package.json中配置sideEffects来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是false则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用
- rollup和webpack中对tree-shaking的层度不同，例如对babel转译后的class，如果babel的转译是宽松模式下的话(也就是loose为true)，webpack依旧会认为它有副作用不会tree-shaking掉，而rollup会。这是因为rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。

原理
- ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
- 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

```
依赖于import/export
```
通过导入所有的包后再进行条件获取。如下：
```
import foo from "foo";
import bar from "bar";

if(condition) {
    // foo.xxxx
} else {
    // bar.xxx
}
```
- ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码

- CommonJS的动态特性模块意味着tree shaking不适用。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：
```
// 不可行，ES6 的import是完全静态的
if(condition) {
    myDynamicModule = require("foo");
} else {
    myDynamicModule = require("bar");
}
```

#### Vite了解吗
- 是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包

Vite 特点
- 快速的冷启动
- 按需编译
- 即时热模块更新

生产环境需要打包吗
- 可以不打包，需要启动server，需要浏览器支持
















### Node
- 当面试官问你node的时候，更多引导面试官用node做前端工程化，去引导到webpack、npm、打包工具上面去说说自己的想法，不要引导到自己会后端，后台不是会一点node语法就能写的

#### package.json版本号规则
major.minor.patch
- 主版本号.次版本号.修补版本号
- patch：修复bug，兼容老版本
- minor：新增功能，兼容老版本
- major：新的架构调整，不兼容老版本

~和^的区别
- ~会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0
- ^会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0

#### npm模块安装机制
- 发出 npm install 命令 1 查询 node_modules 目录之中是否已经存在指定模块
- 若存在，不再重新安装
- 若不存在
- npm 向 registry 查询模块压缩包的网址
- 下载压缩包，存放在根目录下的.npm 目录里
- 解压压缩包到当前项目的 node_modules 目录

#### 模块化的差异AMD CMD COMMONJS ESMODULE
- AMD是依赖前置，define写法
- CMD 语法require
- AMD和CMD是动态引入，运行时才知道的
- ESMODULE是静态引入，好处方便wepback打包依赖图谱分析
- CommonJs 是单个值导出，ES6 Module 可以导出多个
- CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
- CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined

#### Node的Event Loop:6个阶段
- timer 阶段: 执行到期的setTimeout / setInterval队列回调
- I/O 阶段: 执行上轮循环残流的callback
- idle, prepare
- poll: 等待回调
  - 执行回调
  - 执行定时器
    - 如有到期的setTimeout / setInterval， 则返回 timer 阶段
    - 如有setImmediate，则前往 check 阶段
- check
  - 执行setImmediate
- close callbacks

#### Koa相关
koa洋葱模型怎么实现的
- app.use() 把中间件函数存储在middleware数组中，最终会调用koa-compose导出的函数compose返回一个promise，中间函数的第一个参数ctx是包含响应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个promise

如果中间件中的next()方法报错了怎么办
- 中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit('error', err, this)（因为koa继承自events模块，所以有'emit'和on等方法），可以使用app.on('error', (err) => {})，或者app.onerror = (err) => {}进行捕获。

co的原理是怎样的
- co的原理是通过不断调用generator函数的next方法来达到自动执行generator函数的，类似async、await函数自动执行

#### Express、koa实现原理以及对比
- 底层建立在node.js内置的http模块上。http模块生成服务器的原始代码如下
```
var http = require("http");

var app = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.end("Hello world!");
});

app.listen(3000, "localhost");
```
- Express框架的核心是对http模块的再包装
- Express框架等于在http模块之上，加了一个中间层
- 它最大的特点就是，一个中间件处理完，再传递给下一个中间件
- 比如自带 Router、路由规则等
- callback太多

koa2特点
- 洋葱模型
- 没有自带路由，由koa-router管理
- 没有callback








### 小程序
#### 登录
unionid和openid
- 了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识：

- OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。
- UnionId 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通了。

关键Api
- wx.login 官方提供的登录能力
- wx.checkSession校验用户当前的session_key是否有效
- wx.authorize 提前向用户发起授权请求
- wx.getUserInfo 获取用户基本信息

登录流程设计
- 利用现有登录体系
  - 直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可

- 利用OpenId 创建用户体系
  - OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下

- 小程序客户端通过 wx.login 获取 code
- 传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态
- 小程序客户端缓存 （通过storage）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可

利用 Unionid 创建用户体系
- 如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式

- 如果户关注了某个相同主体公众号，或曾经在某个相同主体App、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid
- 结合 wx.getUserInfo 和 <button open-type="getUserInfo"><button/> 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践
  - 调用 wx.login 获取 code，然后从微信后端换取到 session_key，用于解密 getUserInfo返回的敏感数据
  - 使用 wx.getSetting 获取用户的授权情况
    - 如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息；
    - 用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息
  - 获取到用户数据后可以进行展示或者发送给自己的后端。

注意事项
- 需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况
```
wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid
```
- 因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间
- 值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如platform，channel，deviceParam等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。
- openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业

#### 图片导出
- 这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。

基本原理
- 借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （api基本和h5保持一致，但有轻微差异，使用时注意即可
- 借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum （需要授权）保存图片到本地

如何优雅实现
- 绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。
- 结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。
```
class CanvasKit {
   constructor() {
   }
   drawImg(option = {}) {
     ...
     return this
   }
   drawRect(option = {}) {
     return this
   }
   drawText(option = {}) {
     ...
     return this
   }
   static exportImg(option = {}) {
     ...
   }
 }

 let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2)
 drawer.exportImg()
```

注意事项
- 小程序中无法绘制网络图片到canvas上，需要通过downLoadFile 先下载图片到本地临时文件才可以绘制
- 通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（32可见字符）限制，可以借助服务端生成 短链接 的方式来解决

#### 数据统计
- 数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点

设计一个埋点sdk
- 小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对Page进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下
```
// 代码仅供理解思路
 page = function(params) {
   let keys = params.keys()
   keys.forEach(v => {
       if (v === 'onLoad') {
         params[v] = function(options) {
           stat()   //曝光埋点代码
           params[v].call(this, options)
         }
       }
       else if (v.includes('click')) {
         params[v] = funciton(event) {
           let data = event.dataset.config
           stat(data)  // 点击埋点
           param[v].call(this)
         }
       }
   })
 }
```
- 这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。

分析接口
- 对于特殊的一些业务，我们可以采取 接口埋点，什么叫接口埋点呢？很多情况下，我们有的api并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。

微信自定义数据分析
- 微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助小程序数据助手这款小程序可以很方便的查看

#### 工程化
工程化做什么
- 目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：

- 不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率
- 不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）
- 不支持ES7等后续的js特性，好用的async await等特性都无法使用
- 不支持引入外部字体文件，只支持base64
- 没有 eslint 等代码检查工具

方案选型
- 对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp非常的适合处理，并且相对于webpack配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp

具体开发思路
- 通过 gulp 的 task 实现：

- 实时编译 less 文件至相应目录
- 引入支持async，await的运行时文件
- 编译字体文件为base64 并生成相应css文件，方便使用
- 依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录
- 检查代码规范

#### 小程序架构
- 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用。

它们在两个线程里运行。
- 视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理

- 视图层使用 WebView 渲染，iOS中使用自带 WKWebView，在 Android 使用腾讯的 x5内核（基于 Blink）运行。
- 逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android中使用腾讯的 x5 内核（基于 Blink）运行。
- 开发工具使用 nw.js 同时提供了视图层和逻辑层的运行环境。

#### WXML&&WXSS
WXML
- 支持数据绑定
- 支持逻辑算术、运算
- 支持模板、引用
- 支持添加事件（bindtap）
- Wxml编译器：Wcc 把 Wxml文件 转为 JS
- 执行方式：Wcc index.wxml
- 使用 Virtual DOM，进行局部更新

WXSS
- wxss编译器：wcsc 把wxss文件转化为 js
- 执行方式： wcsc index.wxss

尺寸单位 rpx
- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。公式：
```
const dsWidth = 750

export const screenHeightOfRpx = function () {
  return 750 / env.screenWidth * env.screenHeight
}

export const rpxToPx = function (rpx) {
  return env.screenWidth / 750 * rpx
}

export const pxToRpx = function (px) {
  return 750 / env.screenWidth * px
}
```

样式导入
- 使用 @import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束

内联样式
- 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度

全局样式与局部样式
- 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器

#### 小程序的问题
- 小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生）
- 服务端接口返回的头无法执行，比如：Set-Cookie。
- 依赖浏览器环境的 JS库不能使用。
- 不能使用 npm，但是可以自搭构建工具或者使用 mpvue。（未来官方有计划支持）
- 不能使用 ES7，可以自己用babel+webpack自搭或者使用 mpvue。
- 不支持使用自己的字体（未来官方计划支持）。
- 可以用 base64 的方式来使用 iconfont。
- 小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。
- 获取二维码/小程序接口的限制
- 程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId，formId 只有7天有效期。（现在的做法是在每个页面都放入form并且隐藏以此获取更多的 formId。后端使用原则为：优先使用有效期最短的）
- 小程序大小限制 2M，分包总计不超过 8M
- 转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）
- 拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制：
  - 50个移动应用
  - 10个网站
  - 50个同主体公众号
  - 5个不同主体公众号
  - 50个同主体小程序
  - 5个不同主体小程序
- 公众号关联小程序
  - 所有公众号都可以关联小程序。
  - 一个公众号可关联10个同主体的小程序，3个不同主体的小程序。
  - 一个小程序可关联500个公众号。
  - 公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。
- 一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转
- 品牌搜索不支持金融、医疗
- 小程序授权需要用户主动点击
- 小程序不提供测试 access_token
- 安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败
- 开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了wx.checkSession，并且在session_key有效期内，授权获取用户信息也会得到新的session_key

#### 授权获取用户信息流程
- session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长
- 在调用 wx.login 时会直接更新 session_key，导致旧 session_key 失效
- 小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序

面试题：先授权获取用户信息再 login 会发生什么？
- 用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key，这时后端服务从开放平台获取到新 session_key，但是无法对老 session_key 加密过的数据解密，用户信息获取失败
- 在用户信息授权之前先调用 wx.checkSession 呢？wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key，从而再一次导致用户信息解密失败

#### 性能优化
- 我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用

加载优化
- 代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小

优化方式
- 代码压缩。
- 及时清理无用代码和资源文件。
- 减少代码包中的图片等资源文件的大小和数量。
- 分包加载。

首屏加载的体验优化建议
- 提前请求: 异步数据请求不需要等待页面渲染完成。
- 利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。
- 避免白屏：先展示页面骨架页和基础内容。
- 及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应

使用分包加载优化
- 在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本，而分包则是根据开发者的配置进行划分
- 在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。

优点：
- 对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务
- 对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能

限制
- 整个小程序所有分包大小不超过 8M
- 单个分包/主包大小不能超过 2M
- 原生分包加载的配置 假设支持分包的小程序目录结构如下
```
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```
开发者通过在 app.json subPackages 字段声明项目分包结构
```
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subPackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```
分包原则
- 声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中
- app（主包）也可以有自己的 pages（即最外层的 pages 字段
- subPackage 的根目录不能是另外一个 subPackage 内的子目录
- 首页的 TAB页面必须在 app（主包）内

引用原则
- ``packageA无法require packageB JS 文件，但可以require app、自己package内的JS` 文件
- ``packageA无法import packageB的template，但可以require app、自己package内的template`
- ``packageA 无法使用packageB的资源，但可以使用app、自己package` 内的资源

```
官方即将推出 分包预加载
```
独立分包

渲染性能优化
- 每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。
- setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。
- setData 是小程序开发使用最频繁，也是最容易引发性能问题的

避免不当使用 setData
- 使用 data 在方法间共享数据，可能增加 setData传输的数据量。。data 应仅包括与页面渲染相关的数据。
- 使用 setData 传输大量数据，通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。仅传输页面中发生变化的数据，使用 setData 的特殊 key实现局部更新。
- 短时间内频繁调用 setData，操作卡顿，交互延迟，阻塞通信，页面渲染延迟。避免不必要的 setData，对连续的setData调用进行合并。
- 在后台页面进行 setData，抢占前台页面的渲染资源。页面切入后台后的 setData 调用，延迟到页面重新展示时执行。

避免不当使用onPageScroll
- 只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。
- 避免在 onPageScroll 中执行复杂逻辑
- 避免在 onPageScroll 中频繁调用 setData
- 避免滑动时频繁查询节点信息（SelectQuery）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（inersectionObserver）替代

使用自定义组件
- 在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响

#### wepy vs mpvue
数据流管理
- 相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 Web 开发中，随着 Flux、Redux、Vuex 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用

- WePY 默认支持 Redux，在脚手架生成项目的时候可以内置
- Mpvue 作为 Vue 的移植版本，当然支持 Vuex，同样在脚手架生成项目的时候可以内置

组件化
- WePY 类似 Vue实现了单文件组件，最大的差别是文件后缀 .wpy，只是写法上会有差异
```
export default class Index extends wepy.page {}
```
- Mpvue 作为 Vue 的移植版本，支持单文件组件，template、script 和 style 都在一个 .vue 文件中，和 vue 的写法类似，所以对 Vue 开发熟悉的同学会比较适应

工程化
- 所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具

- wepy 内置了构建，通过 wepy init 命令初始化项目，大致流程如下：
  - wepy-cli 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 3 步，反之继续进行。
  - 会从远程仓库下载模版，并保存到本地。
  - 询问开发者 Project name 等问题，依据开发者的回答，创建项目
- mpvue 沿用了 vue 中推崇的 webpack作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如
  - 不再需要 html-webpack-plugin
  - 基于 webpack-dev-middleware 修改成 webpack-dev-middleware-hard-disk
  - 最大的变化是基于 webpack-loader 修改成 mpvue-loader
  - 但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀

#### mpvue
mpvue
- Vue.js 小程序版, fork 自 vuejs/vue@2.4.1，保留了 vue runtime 能力，添加了小程序平台的支持。 mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验

框架原理
两个大方向：
- 通过mpvue提供 mp 的 runtime 适配小程序
- 通过mpvue-loader产出微信小程序所需要的文件结构和模块内容

七个具体问题：
- 要了解 mpvue 原理必然要了解 Vue 原理，这是大前提
现在假设您对 Vue 原理有个大概的了解
- 由于 Vue 使用了 Virtual DOM，所以 Virtual DOM可以在任何支持 JavaScript 语言的平台上操作，譬如说目前 Vue 支持浏览器平台或 weex，也可以是 mp(小程序)。那么最后 Virtual DOM 如何映射到真实的 DOM节点上呢？vue为平台做了一层适配层，浏览器平台见 runtime/node-ops.js、weex平台见runtime/node-ops.js，小程序见runtime/node-ops.js。不同平台之间通过适配层对外提供相同的接口，Virtual DOM进行操作Real DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变
- 所以思路肯定是往增加一个 mp 平台的 runtime方向走。但问题是小程序不能操作 DOM，所以 mp 下的node-ops.js里面的实现都是直接 return obj
- 新 Virtual DOM 和旧 Virtual DOM 之间需要做一个 patch，找出 diff。patch完了之后的 diff 怎么更新视图，也就是如何给这些 DOM 加入 attr、class、style等 DOM 属性呢？ Vue中有 nextTick 的概念用以更新视图，mpvue这块对于小程序的 setData 应该怎么处理呢？
- 另外个问题在于小程序的 Virtual DOM 怎么生成？也就是怎么将 template编译成render function。这当中还涉及到运行时-编译器-vs-只包含运行时，显然如果要提高性能、减少包大小、输出 wxml、mpvue 也要提供预编译的能力。因为要预输出 wxml 且没法动态改变 DOM，所以动态组件，自定义 render，和<script type="text/x-template">字符串模版等都不支持

另外还有一些其他问题，最后总结一下
- 1.如何预编译生成render function
- 2.如何预编译生成 wxml，wxss，wxs
- 3.如何 patch 出 diff
- 4.如何更新视图
- 5.如何建立小程序事件代理机制，在事件代理函数中触发与之对应的vue组件事件响应
- 6.如何建立vue实例与小程序 Page实例关联
- 7.如何建立小程序和vue生命周期映射关系，能在小程序生命周期中触发vue生命周期
```
platform/mp的目录结构
```
```
.
├── compiler //解决问题1，mpvue-template-compiler源码部分
├── runtime //解决问题3 4 5 6 7
├── util //工具方法
├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。
├── entry-runtime.js //对外提供Vue对象，当然是mpvue
└── join-code-in-build.js //编译出SDK时的修复
```
mpvue-loader
- mpvue-loader 是 vue-loader 的一个扩展延伸版，类似于超集的关系，除了vue-loader 本身所具备的能力之外，它还会利用mpvue-template-compiler生成render function

entry
- 它会从 webpack 的配置中的 entry 开始，分析依赖模块，并分别打包。在entry 中 app 属性及其内容会被打包为微信小程序所需要的 app.js／app.json／app.wxss，其余的会生成对应的
- 页面page.js/page.json/page.wxml/page.wxss，如示例的 entry 将会生成如下这些文件，文件内容下文慢慢讲来：
```
// webpack.config.js
{
    // ...
    entry: {
        app: resolve('./src/main.js'),               // app 字段被识别为 app 类型
        index: resolve('./src/pages/index/main.js'),   // 其余字段被识别为 page 类型
        'news/home': resolve('./src/pages/news/home/index.js')
    }
}

// 产出文件的结构
.
├── app.js
├── app.json
├──· app.wxss
├── components
│   ├── card$74bfae61.wxml
│   ├── index$023eef02.wxml
│   └── news$0699930b.wxml
├── news
│   ├── home.js
│   ├── home.wxml
│   └── home.wxss
├── pages
│   └── index
│       ├── index.js
│       ├── index.wxml
│       └── index.wxss
└── static
    ├── css
    │   ├── app.wxss
    │   ├── index.wxss
    │   └── news
    │       └── home.wxss
    └── js
        ├── app.js
        ├── index.js
        ├── manifest.js
        ├── news
        │   └── home.js
        └── vendor.js
```
- wxml 每一个 .vue 的组件都会被生成为一个 wxml 规范的 template，然后通过 wxml 规范的 import 语法来达到一个复用，同时组件如果涉及到 props的 data 数据，我们也会做相应的处理，举个实际的例子：
```
<template>
    <div class="my-component" @click="test">
        <h1>{{msg}}</h1>
        <other-component :msg="msg"></other-component>
    </div>
</template>
<script>
import otherComponent from './otherComponent.vue'

export default {
  components: { otherComponent },
  data () {
    return { msg: 'Hello Vue.js!' }
  },
  methods: {
    test() {}
  }
}
</script>
```
这样一个 Vue的组件的模版部分会生成相应的 wxml
```
<import src="components/other-component$hash.wxml" />
<template name="component$hash">
    <view class="my-component" bindtap="handleProxy">
        <view class="_h1">{{msg}}</view>
        <template is="other-component$hash" wx:if="{{ $c[0] }}" data="{{ ...$c[0] }}"></template>
    </view>
</template>
```
- 可能已经注意到了 other-component(:msg="msg") 被转化成了 。mpvue 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 setData 到 appData,$c是 $children 的缩写。至于那个 0 则是我们的 compiler处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下
```
// 这儿数据结构是一个数组，index 是动态的
{
  $child: {
    '0'{
      // ... root data
      $child: {
        '0': {
          // ... data
          msg: 'Hello Vue.js!',
          $child: {
            // ...data
          }
        }
      }
    }
  }
}
```
wxss
- 这个部分的处理同 web 的处理差异不大，唯一不同在于通过配置生成 .css 为 .wxss ，其中的对于 css的若干处理，在 postcss-mpvue-wxss 和 px2rpx-loader 这两部分的文档中又详细的介绍

- 推荐和小程序一样，将 app.json／page.json 放到页面入口处，使用 copy-webpack-plugin copy 到对应的生成位置。

- 这部分内容来源于 app 和page 的entry 文件，通常习惯是 main.js，你需要在你的入口文件中 export default { config: {} }，这才能被我们的 loader 识别为这是一个配置，需要写成 json 文件
```
import Vue from 'vue';
import App from './app';

const vueApp = new Vue(App);
vueApp.$mount();

// 这个是我们约定的额外的配置
export default {
    // 这个字段下的数据会被填充到 app.json ／ page.json
    config: {
        pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack
        window: {
            backgroundTextStyle: 'light',
            navigationBarBackgroundColor: '##455A73',
            navigationBarTitleText: '美团汽车票',
            navigationBarTextStyle: '##fff'
        }
    }
};
```



- [Bootstrap](#Bootstrap)
  - [](#)  1 什么是Bootstrap？以及为什么要使用Bootstrap？
  - [](#)  2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？
  - [](#)  3 什么是Bootstrap网格系统
  - [](#)  4 Bootstrap 网格系统（Grid System）的工作原理
  - [](#)  5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么
  - [](#)  6 Bootstrap 网格系统列与列之间的间隙宽度是多少
  - [](#)  7 如果需要在一个标题的旁边创建副标题，可以怎样操作
  - [](#)  8 用Bootstrap，如何设置文字的对齐方式？
  - [](#)  9 Bootstrap如何设置响应式表格？
  - [](#)  10 使用Bootstrap创建垂直表单的基本步骤？
  - [](#)  11 使用Bootstrap创建水平表单的基本步骤？
  - [](#)  12 使用Bootstrap如何创建表单控件的帮助文本？
  - [](#)  13 使用Bootstrap激活或禁用按钮要如何操作？
  - [](#)  14 Bootstrap有哪些关于的class？
  - [](#)  15 Bootstrap中有关元素浮动及清除浮动的class？
  - [](#)  16 除了屏幕阅读器外，其他设备上隐藏元素的class？
  - [](#)  17 Bootstrap如何制作下拉菜单？
  - [](#)  18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？
  - [](#)  19 Bootstrap如何设置按钮的下拉菜单？
  - [](#)  20 Bootstrap中的输入框组如何制作？
  - [](#)  21 Bootstrap中的导航都有哪些？
  - [](#)  22 Bootstrap中设置分页的class？
  - [](#)  23 Bootstrap中显示标签的class？
  - [](#)  24 Bootstrap中如何制作徽章？
  - [](#)  25 Bootstrap中超大屏幕的作用是什么？














### GIT
#### git与svn的区别在哪里
   ```
   git 和 svn 最大的区别在于 git 是分布式的，而 svn 是
   集中式的。因此我们不能再离线的情况下使用 svn。如果服务器
   出现问题，我们就没有办法使用 svn 来提交我们的代码。

   svn 中的分支是整个版本库的复制的一份完整目录，而 git 的
   分支是指针指向某次提交，因此 git 的分支创建更加开销更小
   并且分支上的变化不会影响到其他人。svn 的分支变化会
   影响到所有的人。

   svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。
   ```

#### 经常使用的git命令
   ```
   git init                     // 新建 git 代码库
   git add                      // 添加指定文件到暂存区
   git rm                       // 删除工作区文件，并且将这次删除放入暂存区
   git commit -m [message]      // 提交暂存区到仓库区
   git branch                   // 列出所有分支
   git checkout -b [branch]     // 新建一个分支，并切换到该分支
   git status                   // 显示有变更的文件
   ```

#### git pull和git fetch的区别
   ```
   git fetch 只是将远程仓库的变化下载下来，
   并没有和本地分支合并。

   git pull 会将远程仓库的变化下载下来，并和当前分支合并。
   ```

#### git rebase和git merge的区别
   ```
   git merge 和 git rebase 都是用于分支合并，
   关键在 commit 记录的处理上不同。

   git merge 会新建一个新的 commit 对象，然后两个分支
   以前的 commit 记录都指向这个新 commit 记录。
   这种方法会保留之前每个分支的 commit 历史。

   git rebase 会先找到两个分支的第一个共同的 commit 
   祖先记录，然后将提取当前分支这之后的所有 commit 记录，
   然后将这个 commit 记录添加到目标分支的最新提交后面。
   经过这个合并后，两个分支合并后的 commit 记录
   就变为了线性的记录了。
   ```

   
   
   
   
   
   
   
   
   
   
   
   
   
 
