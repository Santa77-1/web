## HTML 面试知识点总结

整理了 HTML 面试的部分知识点

### 目录

- [html5新特性、移除了哪些元素？](#html5新特性-移除了哪些元素)
- [html5元素分类](#html5元素分类)
- [行内元素、块级元素、空元素](#行内元素-块级元素-空元素)
- [语义化](#语义化)
- [优化](#优化)
  - [前端需要注意哪些SEO](#前端需要注意哪些SEO)
  - [如何进行网站性能优化](#如何进行网站性能优化)
  - [前端性能优化](#前端性能优化)
  - [渲染优化](#渲染优化)
  - [关键渲染路径优化（浏览器渲染过程）](#关键渲染路径优化浏览器渲染过程)
  - [大量图片加载慢如何优化](#大量图片加载慢如何优化)
- [cookies、sessionStorage、localStorage的区别](#cookiessessionStoragelocalStorage的区别)
- [重绘和回流（浏览器绘制过程）](#重绘和回流浏览器绘制过程)
  - [如何减少回流（浏览器绘制过程）](#如何减少回流浏览器绘制过程)




#### html5新特性 移除了哪些元素

   ```
    HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

    新增的有：
    绘画 canvas;
    用于媒体播放的 video 和 audio 元素;
    本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
    sessionStorage 的数据在浏览器关闭后自动删除;
    语意化更好的内容元素，比如 article、footer、header、nav、section;
    表单控件，calendar、date、time、email、url、search;
    多任务 webworker；全双工通信协议 websocket；
    新的文档属性 document.visibilityState
    页面可见性改变事件 visibilitychange
    新增选择器 document.querySelector、document.querySelectorAll
    拖拽释放(Drag and drop) API
    离线应用 manifest
    桌面通知 Notifications
    地理位置 Geolocation
    历史管理 history
    跨域资源共享(CORS) Access-Control-Allow-Origin
    跨窗口通信 PostMessage
    Form Data 对象

    移除的元素有：
    纯表现的元素：basefont，big，center，font, s，strike，tt，u;
    对可用性产生负面影响的元素：frame，frameset，noframes；
   ```

#### html5元素分类

   ```
   HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，
   前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值
   设定为 inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。
   因此，简单地把 HTML 元素划分为 inline 与 block 已经不再符合实际需求。
   
   HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive
   ```

#### 行内元素 块级元素 空元素

   ```
   HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。
   
   一个行内元素只占据它对应标签的边框所包含的空间。行内元素不可以设置宽高，不独占一行
   常见的行内元素有 a b span img strong sub sup button input label select textarea
   
   块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。块级元素可以设置宽高，独占一行
   常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 
   
   （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
   （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
   （3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效
        （可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。
   
   标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。
   常见的空元素有：br hr img input link meta
   ```

#### 语义化

   ```
    （1） 用正确的标签做正确的事情。
    （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
    （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;
    （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;
    （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
   ```

   ```
    我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，
    一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容
    进行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。
    对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，
    使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会
    依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，
    从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、
    footer 这些语义标签，删除了 big 、font 这些没有语义的标签。
   ```

   ```
   所谓“语义”就是为了更易读懂，这要分两部分：让人（写程序、读程序）更易读懂；让机器（浏览器、搜索引擎）更易读懂
   1. 让人更易读懂
   对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，
   定义 CSS class 的时候也一样，例如length list等，而不是使用a b这种谁都看不懂的名称。
   不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。
   2. 让机器更易读懂
   HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。
   问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如p div h1 ul等 —— 就是为了语义化。其实，
   如果你精通 CSS 的话，你完全可以全部用<div>标签来实现所有的网页效果，其他的p h1 ul等标签可以一个都不用。
   但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。
   拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。
   h1标签就代表是标题；p里面的就是段落详细内容，权重肯定没有标题高；ul里面就是列表；strong就是加粗的强调的内容 …… 
   如果我们不按照 HTML 语义化来写，全部都用<div>标签，那搜索引擎将很难理解我们网页的内容。
   为了加强 HTML 语义化，HTML5 标准中又增加了header section article等标签。因此，书写 HTML 时，
   语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。
   ```
   
### 优化

#### 前端需要注意哪些SEO

   ```
    （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，
    重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，
    长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。
    （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。
    （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，
    保证重要内容肯定被抓取。
    （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容
    （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容
    （6）非装饰性图片必须加 alt
    （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标
   ```

#### 如何进行网站性能优化
```
content方面：
减少HTTP请求：合并文件、CSS精灵、inline Image
减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名
减少DOM元素数量

Server方面：
使用CDN
配置ETag
对组件使用Gzip压缩

Cookie方面：
减小cookie大小

css方面：
将样式表放到页面顶部
不使用CSS表达式
使用<link>不使用@import

Javascript方面：
将脚本放到页面底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问

图片方面：
优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
不要在HTML中拉伸图片
```

#### 前端性能优化

   ```
    前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

    第一个方面是页面的内容方面：
    （1）通过文件合并、css 雪碧图(CSS Sprite)、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
    （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
    （3）通过设置缓存策略，对常用不变的资源进行缓存。
    （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
    （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

    第二个方面是服务器方面：
    （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
    （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
    （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

    第三个方面是 CSS 和 JavaScript 方面：
    （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
    （2）避免使用 @import 标签。
    （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
    （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
   ```
   
   用过哪些前端性能优化的方法？
   ```
前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
当需要设置的样式很多时设置className而不是直接操作style
少用全局变量、缓存DOM节点查找的结果。减少IO读取操作
避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)
图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢
   ```
   
   前端性能优化最佳实践？
   ```
性能评级工具（PageSpeed 或 YSlow）
合理设置 HTTP 缓存：Expires 与 Cache-control
静态资源打包，开启 Gzip 压缩（节省响应流量）
CSS3 模拟图像，图标base64（降低请求数）
模块延迟(defer)加载/异步(async)加载
Cookie 隔离（节省请求流量）
localStorage（本地存储）
使用 CDN 加速（访问最近服务器）
启用 HTTP/2（多路复用，并行加载）
前端自动化（gulp/webpack）
   ```
   
性能优化问题：
```
代码层面：避免使用css表达式，避免使用高级选择器，通配选择器
缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等
请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
请求带宽：压缩文件，开启GZIP
```

#### 渲染优化

```
（1）禁止使用iframe（阻塞父文档onload事件）：
   iframe会阻塞主页面的Onload事件
   搜索引擎的检索程序无法解读这种页面，不利于SEO
   iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
   使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
   动态给iframe添加src属性值，这样可以绕开以上两个问题

（2）禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

（3）使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）

（4）对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU
   小图标优势在于：
      减少HTTP请求
      避免文件跨域
      修改及时生效

（5）页面头部的<style></style> <script></script> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）

（6）页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)

（7）网页gzip，CDN托管，data缓存 ，图片服务器

（8）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（9）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能

（10）当需要设置的样式很多时设置className而不是直接操作style

（11）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作

（12）图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳

（13）对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO
```


#### 关键渲染路径优化（浏览器渲染过程）

   ```
    为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：
    （1）关键资源的数量。
    （2）关键路径长度。
    （3）关键字节的数量。

    关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

    同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：
    某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。

    最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。
    要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），
    此外还要压缩和优化各项资源，确保最大限度减小传送大小。

    优化关键渲染路径的常规步骤如下：
    （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
    （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
    （3）优化关键字节数以缩短下载时间（往返次数）。
    （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。
   ```

#### 大量图片加载慢如何优化

```
(1)图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
(2)如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
(3)如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。
(4)如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
(5)如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
```

### cookies、sessionStorage、localStorage的区别

```
    浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。

    cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，
    然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，
    它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

    sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，
    代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，
    它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。

    localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。
    它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

    上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，
    我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。
    它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。
```

```
    SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型
    的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是
    网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源
    （协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。
    
    存储大小：
      	cookie 数据大小不能超过4 k 。
      	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

    有期时间：
      	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
      	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，
                        并且重新加载或恢复页面仍会保持原来的页面会话。
                        在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
      	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
     
    作用域：
        sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
        localStorage    在所有同源窗口中都是共享的。
        cookie          在所有同源窗口中都是共享的。
        
    操作：
        localStroage：localStroage.setItem('a' , '111')
        sessionStroage：sessionStroage.setItem('a' , '111')
```

Cookie的弊端
```
cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的

每个特定的域名下最多生成20个cookie
IE6或更低版本最多20个cookie
IE7和之后的版本最后可以有50个cookie
Firefox最多50个cookie
chrome和Safari没有做硬性限制
IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie
cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节
如果 cookie 被人拦截了，就可以取得所有的 session 信息
```

### 重绘和回流（浏览器绘制过程）
  
```
    重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，
          而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。
    
    回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变
         而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。

    常见引起回流属性和方法：
    任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。
    （1）添加或者删除可见的 DOM 元素；
    （2）元素尺寸改变——边距、填充、边框、宽度和高度
    （3）内容变化，比如用户在 input 框中输入文字
    （4）浏览器窗口尺寸改变——resize事件发生时
    （5）计算 offsetWidth 和 offsetHeight 属性
    （6）设置 style 属性的值
    （7）当你修改网页的默认字体时。

    回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，
    改变父节点里的子节点很可能会导致父节点的一系列回流。
```
   
   常见引起重绘属性和方法：



   常见引起回流属性和方法：



#### 如何减少回流（浏览器绘制过程）
   ```
    （1）使用 transform 替代 top
    （2）不要把节点的属性值放在一个循环里当成循环里的变量
    （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
    （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM
    （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
   ```











