## HTML 面试知识点总结

整理了 HTML 面试的部分知识点

### 目录

- [html5新特性、移除了哪些元素？](#html5新特性-移除了哪些元素)
  - [html5新增的表单元素](#html5新增的表单元素)
  - [如何处理html5新标签的浏览器兼容问题](#如何处理html5新标签的浏览器兼容问题)
- [html5元素分类](#html5元素分类)
  - [行内元素、块级元素、空元素](#行内元素-块级元素-空元素)
- [HTML全局属性(global attribute)有哪些](#HTML全局属性global-attribute有哪些)

- [语义化](#语义化)
- [优化](#优化)
  - [前端需要注意哪些SEO](#前端需要注意哪些SEO)
  - [如何进行网站性能优化](#如何进行网站性能优化)
  - [前端性能优化](#前端性能优化)
  - [渲染优化](#渲染优化)
  - [关键渲染路径优化（浏览器渲染过程）](#关键渲染路径优化浏览器渲染过程)
  - [大量图片加载慢如何优化](#大量图片加载慢如何优化)
 
- [常见的浏览器端的存储技术](#常见的浏览器端的存储技术)
  - [cookies、sessionStorage、localStorage的区别](#cookiessessionStoragelocalStorage的区别)
- [html5的离线储存怎么使用，解释工作原理](#html5的离线储存怎么使用解释工作原理)
- [浏览器是怎么对html5的离线储存资源进行管理和加载的](#浏览器是怎么对html5的离线储存资源进行管理和加载的)

- [重绘和回流（浏览器绘制过程）](#重绘和回流浏览器绘制过程)
  - [如何减少回流（浏览器绘制过程）](#如何减少回流浏览器绘制过程)
- [怎么重构页面](#怎么重构页面)

- [从浏览器地址栏输入url到显示页面的步骤](#从浏览器地址栏输入url到显示页面的步骤)
- [浏览器](#浏览器)
  - [对浏览器的理解](#对浏览器的理解)
  - [对浏览器内核的理解](#对浏览器内核的理解)
  - [常见的浏览器内核比较](#常见的浏览器内核比较)
  - [常见浏览器所用内核](#常见浏览器所用内核)
  - [浏览器的渲染原理](#浏览器的渲染原理)
  - [浏览器架构](#浏览器架构)
  - [如何实现浏览器内多个标签页之间的通信](#如何实现浏览器内多个标签页之间的通信)
- [浏览器解析过程](#浏览器解析过程)
  - [渲染过程中遇到js文件怎么处理？（浏览器解析过程）](#渲染过程中遇到js文件怎么处理浏览器解析过程)
  - [async和defer的作用是什么？有什么区别？（浏览器解析过程）](#async和defer的作用是什么有什么区别浏览器解析过程)
  - [什么是文档的预解析？（浏览器解析过程）](#什么是文档的预解析浏览器解析过程)
  - [css如何阻塞文档解析？（浏览器解析过程）](#css如何阻塞文档解析浏览器解析过程)
- [浏览器渲染过程](#浏览器渲染过程)
  - [渲染页面时常见哪些不良现象？（浏览器渲染过程）](#渲染页面时常见哪些不良现象浏览器渲染过程)
- [浏览器绘制过程](#浏览器绘制过程)
  - [为什么操作DOM慢？（浏览器绘制过程）](#26-为什么操作-dom-慢浏览器绘制过程)
- [DOMContentLoaded事件和Load事件的区别](#domcontentloaded事件和load事件的区别)

- [网页验证码是干嘛的，是为了解决什么安全问题](#网页验证码是干嘛的是为了解决什么安全问题)
- [扫描二维码登录网页是什么原理，前后两个事件是如何联系的](#扫描二维码登录网页是什么原理前后两个事件是如何联系的)

- [SGML、HTML、XML 和 XHTML 的区别](#SGMLHTMLXML-和-XHTML-的区别)
- [DHTML 是什么](#DHTML-是什么)
- [DOCTYPE、标准模式与兼容模式、DTD](#DOCTYPE标准模式与兼容模式DTD)
  - [DOCTYPE 的作用是什么](#DOCTYPE-的作用是什么)
  - [标准模式与兼容模式各有什么区别](#标准模式与兼容模式各有什么区别)
  - [DTD](#DTD)
  - [HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD](#html5-为什么只需要写-doctype-html而不需要引入-dtd)

- [页面导入样式时，使用 link 和 @import 有什么区别](#页面导入样式时使用-link-和-import-有什么区别)
  - [link标签定义](#link标签定义)

- [head标签中必不可少的是](#head标签中必不可少的是)
- [常用的meta标签](#常用的meta标签)
- [用于预格式化文本的标签是](#用于预格式化文本的标签是)
- [iframe有哪些缺点](#iframe有哪些缺点)
- [label的作用是什么？是怎么用的](#label的作用是什么是怎么用的)
- [html5的form的自动完成功能是什么](#html5的form的自动完成功能是什么)

- [title与h1的区别](#title与h1的区别)
- [b与strong的区别、i与em的区别](#b与strong的区别i与em的区别)
- [&lt;img&gt;的title和alt有什么区别](#-img-的title和alt有什么区别)
- [Canvas和SVG有什么区别？](#canvas和svg有什么区别)
- [src与href的区别](#src与href的区别)
- [disabled和readonly的区别](#disabled和readonly的区别)
- [attribute和property的区别](#attribute和property的区别)
- [css reset和normalize.css有什么区别](#css-reset和normalizecss有什么区别)
- [div+css的布局较table布局有什么优点](#divcss的布局较table布局有什么优点)

- [http](#http)
  - [http的几种请求方法用途](#http的几种请求方法用途)
  - [http状态码及其含义](#HTTP状态码及其含义)
  - [html规范中为什么要求引用资源不加协议头http或者https](#html规范中为什么要求引用资源不加协议头http或者https)
  - [HTTP request报文结构是怎样的](#HTTP-request报文结构是怎样的)
  - [HTTP response报文结构是怎样的](#HTTP-response报文结构是怎样的)

- [对web标准、可用性、可访问性的理解](#对web标准可用性可访问性的理解)
- [web开发中会话跟踪的方法有哪些](#web开发中会话跟踪的方法有哪些)
- [IE各版本和Chrome可以并行下载多少个资源](#ie各版本和chrome可以并行下载多少个资源)
- [Chrome中的Waterfall](#chrome中的waterfall)
- [webSocket如何兼容低版本浏览器](#websocket如何兼容低版本浏览器)
- [Flash、Ajax各自的优缺点，在使用中如何取舍](#flashajax各自的优缺点在使用中如何取舍)
- [git fetch和git pull的区别](#git-fetch和git-pull的区别)
- [为什么利用多个域名来存储网站资源会更有效](#为什么利用多个域名来存储网站资源会更有效)
- [页面可见性（Page Visibility API）可以有哪些用途](#页面可见性page-visibility-api-可以有哪些用途)
- [从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理](#从用户刷新网页开始一次js请求一般情况下有哪些地方会有缓存处理)
- [在html5中，哪个方法用于获得用户的当前位置](#在html5中哪个方法用于获得用户的当前位置)
- [渐进增强和优雅降级的定义](#渐进增强和优雅降级的定义)
- [主流浏览器内核私有属性css前缀](#主流浏览器内核私有属性css前缀)
- [简述一下src与href的区别](#简述一下src与href的区别)
- [知道的网页制作会用到的图片格式有哪些](#知道的网页制作会用到的图片格式有哪些)
- [文档的不同注释方式？](#文档的不同注释方式)

- [实现不使用border画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。](#实现不使用border画出1px高的线在不同浏览器的标准模式与怪异模式下都能保持一致的效果)
- [如何在页面上实现一个圆形的可点击区域](#如何在页面上实现一个圆形的可点击区域)

- [常见排序算法的时间复杂度,空间复杂度](#常见排序算法的时间复杂度空间复杂度)


### html5新特性 移除了哪些元素

   ```
    HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

    新增的有：
    绘画 canvas;
    用于媒体播放的 video 和 audio 元素;
    本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
    sessionStorage 的数据在浏览器关闭后自动删除;
    语意化更好的内容元素，比如 article、footer、header、nav、section;
    表单控件，calendar、date、time、email、url、search;
    多任务 webworker；全双工通信协议 websocket；
    新的文档属性 document.visibilityState
    页面可见性改变事件 visibilitychange
    新增选择器 document.querySelector、document.querySelectorAll
    拖拽释放(Drag and drop) API
    离线应用 manifest
    桌面通知 Notifications
    地理位置 Geolocation
    历史管理 history
    跨域资源共享(CORS) Access-Control-Allow-Origin
    跨窗口通信 PostMessage
    Form Data 对象

    移除的元素有：
    纯表现的元素：basefont，big，center，font, s，strike，tt，u;
    对可用性产生负面影响的元素：frame，frameset，noframes；
   ```

#### html5新增的表单元素
   ```
    datalist 规定输入域的选项列表，通过 option 创建！ 
    keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！
    output 元素用于不同类型的输出！
   ```

#### 如何处理html5新标签的浏览器兼容问题
   ```
    （1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器
        支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。

    （2） 当然也可以直接使用成熟的框架，比如 html5shiv ;
         `<!--[if lt IE 9]>
         <script> src="https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js"</script>
         <![endif]-->`

         [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。
   ```

### html5元素分类

   ```
   HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，
   前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值
   设定为 inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。
   因此，简单地把 HTML 元素划分为 inline 与 block 已经不再符合实际需求。
   
   HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive
   ```

#### 行内元素 块级元素 空元素

   ```
   HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。
   
   一个行内元素只占据它对应标签的边框所包含的空间。行内元素不可以设置宽高，不独占一行
   常见的行内元素有 a b span img strong sub sup button input label select textarea
   
   块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。块级元素可以设置宽高，独占一行
   常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 
   
   （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
   （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
   （3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效
        （可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。
   
   标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。
   常见的空元素有：br hr img input link meta
   ```

### HTML全局属性(global attribute)有哪些
```
class:为元素设置类标识
data-*: 为元素增加自定义属性
draggable: 设置元素是否可拖拽
id: 元素id，文档内唯一
lang: 元素内容的的语言
style: 行内css样式
title: 元素相关的建议信息
```

### 语义化

   ```
    （1） 用正确的标签做正确的事情。
    （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
    （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;
    （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;
    （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
   ```

   ```
    我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，
    一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容
    进行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。
    对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，
    使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会
    依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，
    从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、
    footer 这些语义标签，删除了 big 、font 这些没有语义的标签。
   ```

   ```
   所谓“语义”就是为了更易读懂，这要分两部分：让人（写程序、读程序）更易读懂；让机器（浏览器、搜索引擎）更易读懂
   1. 让人更易读懂
   对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，
   定义 CSS class 的时候也一样，例如length list等，而不是使用a b这种谁都看不懂的名称。
   不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。
   2. 让机器更易读懂
   HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。
   问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如p div h1 ul等 —— 就是为了语义化。其实，
   如果你精通 CSS 的话，你完全可以全部用<div>标签来实现所有的网页效果，其他的p h1 ul等标签可以一个都不用。
   但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。
   拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。
   h1标签就代表是标题；p里面的就是段落详细内容，权重肯定没有标题高；ul里面就是列表；strong就是加粗的强调的内容 …… 
   如果我们不按照 HTML 语义化来写，全部都用<div>标签，那搜索引擎将很难理解我们网页的内容。
   为了加强 HTML 语义化，HTML5 标准中又增加了header section article等标签。因此，书写 HTML 时，
   语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。
   ```
   
### 优化

#### 前端需要注意哪些SEO

   ```
    （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，
    重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，
    长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。
    （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。
    （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，
    保证重要内容肯定被抓取。
    （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容
    （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容
    （6）非装饰性图片必须加 alt
    （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标
   ```

#### 如何进行网站性能优化
```
content方面：
减少HTTP请求：合并文件、CSS精灵、inline Image
减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名
减少DOM元素数量

Server方面：
使用CDN
配置ETag
对组件使用Gzip压缩

Cookie方面：
减小cookie大小

css方面：
将样式表放到页面顶部
不使用CSS表达式
使用<link>不使用@import

Javascript方面：
将脚本放到页面底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问

图片方面：
优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
不要在HTML中拉伸图片
```

#### 前端性能优化

   ```
    前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

    第一个方面是页面的内容方面：
    （1）通过文件合并、css 雪碧图(CSS Sprite)、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
    （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
    （3）通过设置缓存策略，对常用不变的资源进行缓存。
    （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
    （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

    第二个方面是服务器方面：
    （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
    （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
    （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

    第三个方面是 CSS 和 JavaScript 方面：
    （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
    （2）避免使用 @import 标签。
    （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
    （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
   ```
   
   用过哪些前端性能优化的方法？
   ```
前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
当需要设置的样式很多时设置className而不是直接操作style
少用全局变量、缓存DOM节点查找的结果。减少IO读取操作
避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)
图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢
   ```
   
   前端性能优化最佳实践？
   ```
性能评级工具（PageSpeed 或 YSlow）
合理设置 HTTP 缓存：Expires 与 Cache-control
静态资源打包，开启 Gzip 压缩（节省响应流量）
CSS3 模拟图像，图标base64（降低请求数）
模块延迟(defer)加载/异步(async)加载
Cookie 隔离（节省请求流量）
localStorage（本地存储）
使用 CDN 加速（访问最近服务器）
启用 HTTP/2（多路复用，并行加载）
前端自动化（gulp/webpack）
   ```
   
性能优化问题：
```
代码层面：避免使用css表达式，避免使用高级选择器，通配选择器
缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等
请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
请求带宽：压缩文件，开启GZIP
```

#### 渲染优化

```
（1）禁止使用iframe（阻塞父文档onload事件）：
   iframe会阻塞主页面的Onload事件
   搜索引擎的检索程序无法解读这种页面，不利于SEO
   iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
   使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
   动态给iframe添加src属性值，这样可以绕开以上两个问题

（2）禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

（3）使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）

（4）对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU
   小图标优势在于：
      减少HTTP请求
      避免文件跨域
      修改及时生效

（5）页面头部的<style></style> <script></script> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）

（6）页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)

（7）网页gzip，CDN托管，data缓存 ，图片服务器

（8）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（9）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能

（10）当需要设置的样式很多时设置className而不是直接操作style

（11）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作

（12）图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳

（13）对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO
```


#### 关键渲染路径优化（浏览器渲染过程）

   ```
    为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：
    （1）关键资源的数量。
    （2）关键路径长度。
    （3）关键字节的数量。

    关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

    同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：
    某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。

    最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。
    要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），
    此外还要压缩和优化各项资源，确保最大限度减小传送大小。

    优化关键渲染路径的常规步骤如下：
    （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
    （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
    （3）优化关键字节数以缩短下载时间（往返次数）。
    （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。
   ```

#### 大量图片加载慢如何优化

```
(1)图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
(2)如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
(3)如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。
(4)如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
(5)如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
```

### 常见的浏览器端的存储技术
   ```
    浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。

    还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。

    IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。
   ```

#### cookies、sessionStorage、localStorage的区别

```
    浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。

    cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，
    然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，
    它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。

    sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，
    代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，
    它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。

    localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。
    它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

    上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，
    我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。
    它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。
```

```
    SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型
    的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是
    网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源
    （协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。
    
    存储大小：
      	cookie 数据大小不能超过4 k 。
      	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

    有期时间：
      	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
      	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，
                        并且重新加载或恢复页面仍会保持原来的页面会话。
                        在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
      	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
     
    作用域：
        sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
        localStorage    在所有同源窗口中都是共享的。
        cookie          在所有同源窗口中都是共享的。
        
    操作：
        localStroage：localStroage.setItem('a' , '111')
        sessionStroage：sessionStroage.setItem('a' , '111')
```

Cookie的弊端
```
cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的

每个特定的域名下最多生成20个cookie
IE6或更低版本最多20个cookie
IE7和之后的版本最后可以有50个cookie
Firefox最多50个cookie
chrome和Safari没有做硬性限制
IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie
cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节
如果 cookie 被人拦截了，就可以取得所有的 session 信息
```

### html5的离线储存怎么使用，解释工作原理






### 浏览器是怎么对html5的离线储存资源进行管理和加载的






### 重绘和回流（浏览器绘制过程）
  
```
    重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，
          而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。
    
    回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变
         而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。

    常见引起回流属性和方法：
    任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。
    （1）添加或者删除可见的 DOM 元素；
    （2）元素尺寸改变——边距、填充、边框、宽度和高度
    （3）内容变化，比如用户在 input 框中输入文字
    （4）浏览器窗口尺寸改变——resize事件发生时
    （5）计算 offsetWidth 和 offsetHeight 属性
    （6）设置 style 属性的值
    （7）当你修改网页的默认字体时。

    回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，
    改变父节点里的子节点很可能会导致父节点的一系列回流。
```

```
   常见引起重绘属性和方法：


   常见引起回流属性和方法：
```

```
重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘
回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流
注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）
     也会引起回流。因为浏览器需要通过回流计算最新值
回流必将引起重绘，而重绘不一定会引起回流
```

如何最小化重绘(repaint)和回流(reflow)：
```
需要要对元素进行复杂的操作时，可以先隐藏(display:"none")，操作完成后再显示
需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document
缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流
尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）
避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）
尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color
批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx
```

#### 如何减少回流（浏览器绘制过程）
   ```
    （1）使用 transform 替代 top
    （2）不要把节点的属性值放在一个循环里当成循环里的变量
    （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
    （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM
    （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
   ```

### 怎么重构页面







### http的几种请求方法用途

```
GET方法：发送一个请求来取得服务器上的某一资源

POST方法：向URL指定的资源提交数据或附加新的数据

PUT方法：跟POST方法很像，也是向服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有

HEAD方法：只请求页面的首部

DELETE方法：删除服务器上的某资源

OPTIONS方法：它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息

TRACE方法：TRACE方法被用于激发一个远程的，应用层的请求消息回路

CONNECT方法：把请求连接转换到透明的TCP/IP通道
```

### 从浏览器地址栏输入url到显示页面的步骤

基础版本
```
浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
载入解析到的资源文件，渲染页面，完成。
```

详细版
```
1.在浏览器地址栏输入URL
2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
  (1)如果资源未缓存，发起新请求
  (2)如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
  (3)检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：
      HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
      HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3.浏览器解析URL获取协议，主机，端口，path
4.浏览器组装一个HTTP（GET）请求报文
5.浏览器获取主机ip地址，过程如下：
  (1)浏览器缓存
  (2)本机缓存
  (3)hosts文件
  (4)路由器缓存
  (5)ISP DNS缓存
  (6)DNS递归查询（可能存在负载均衡导致每次IP不一样）
6.打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
  (1)客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
  (2)服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
  (3)客户端发送ACK=Y+1， Seq=Z
7.TCP链接建立后发送HTTP请求
8.服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9.服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
10.处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11.服务器将响应报文通过TCP连接发送回浏览器
12.浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：
  (1)主动方发送Fin=1， Ack=Z， Seq= X报文
  (2)被动方发送ACK=X+1， Seq=Z报文
  (3)被动方发送Fin=1， ACK=X， Seq=Y报文
  (4)主动方发送ACK=Y， Seq=X报文
13.浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14.如果资源可缓存，进行缓存
15.对响应进行解码（例如gzip压缩）
16.根据资源类型决定如何处理（假设资源为HTML文档）
17.解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释
18.构建DOM树：
  (1)Tokenizing：根据HTML规范将字符流解析为标记
  (2)Lexing：词法分析将标记转换为对象并定义属性和规则
  (3)DOM construction：根据HTML标记关系将对象组成DOM树
19.解析过程中遇到图片、样式表、js文件，启动下载
20.构建CSSOM树：
  (1)Tokenizing：字符流转换为标记流
  (2)Node：根据标记创建节点
  (3)CSSOM：节点创建CSSOM树
21.根据DOM树和CSSOM树构建渲染树 (opens new window):
  (1)从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none
  (2)对每一个可见节点，找到恰当的CSSOM规则并应用
  (3)发布可视节点的内容和计算样式
22.js解析如下：
  (1)浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
  (2)HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。
  这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。
  同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容
  (3)当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，
  但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素
  (4)当文档完成解析，document.readState变成interactive
  (5)所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
  (6)浏览器在Document对象上触发DOMContentLoaded事件
  (7)此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且
  所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件
23.显示页面（HTML解析过程中会逐步显示页面）
```

详细简版
```
1.从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
2.开启网络线程到发出一个完整的HTTP请求（这一部分涉及到dns查询，TCP/IP请求，五层因特网协议栈等知识）
3.从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4.后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
5.单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag，catch-control等）
6.浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，
  然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和DOMContentLoaded等）
7.CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
8.JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
9.其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
```

### 浏览器

#### 对浏览器的理解
   ```
   浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其
   显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。
   用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。

   HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织
   对这些规范进行维护，W3C 是负责制定 web 标准的组织。

   但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。

   简单来说浏览器可以分为两部分，shell 和 内核。

   其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。
   主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。
   内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。
   从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。
   ```

#### 对浏览器内核的理解
   ```
   主要分成两部分：渲染引擎和 JS 引擎。

   渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，
   渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）
   显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。

   JS 引擎：解析和执行 javascript 来实现网页的动态效果。

   最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。
   ```

#### 常见的浏览器内核比较
   ```
   Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，
   以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。
   但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核
   和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者
   公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

   Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，
   可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

   Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，
   这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，
   缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

   Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 
   但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，
   会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，
   可以说 WebKit 是 KHTML 的一个开源的分支。

   Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，
   在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。
   其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。
   Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，
   Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。
   ```

#### 常见浏览器所用内核
   ```
    （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；
    （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；
    （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；
    （4） Safari 浏览器内核：Webkit 内核；
    （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
    （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；
    （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
    （8） 百度浏览器、世界之窗内核：IE 内核；
    （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；
    （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，
          但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。
   ```

#### 浏览器的渲染原理
   ```
    （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

    （2）然后对 CSS 进行解析，生成 CSSOM 规则树。

    （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是
    一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，
    不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，
    它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

    （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，
    就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点
    在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

    （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，
        绘制使用 UI 基础组件。

     值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，
     并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就
     显示一部分内容，同时，可能还在通过网络下载其余内容。
   ```

#### 浏览器架构




#### 如何实现浏览器内多个标签页之间的通信






### 网页验证码是干嘛的，是为了解决什么安全问题
   ```
    （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
    （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试
   ```  

### 扫描二维码登录网页是什么原理，前后两个事件是如何联系的
   ```
    核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，
    从长连接中获得客户端上报给 server的帐号信息进行展示。并在客户端点击确认后，
    获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，
    此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。

    我的理解：
    二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。
    对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，
    但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只有用微信识这个二维码才有效。
    当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页
    根据先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。
    当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。
    由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。并且在超时、
    网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。
   ```

### 页面导入样式时，使用 link 和 @import 有什么区别

   ```
   （1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；
   link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。
   （2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。
   （3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；
   link 标签作为 HTML 元素，不存在兼容性问题。
   （4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；
   由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。
   ```
   
```
link是HTML方式， @import是CSS方式
link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC(文档样式短暂失效)
link可以通过rel="alternate stylesheet"指定候选样式
浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式
@import必须在样式规则之前，可以在css文件中引用其他文件
总体来说：link优于@import
```

#### link标签定义
   ```
   link 标签定义文档与外部资源的关系。
   link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。
   link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。
   ```

### SGML、HTML、XML 和 XHTML 的区别

   ```
   SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。
   
   HTML 是超文本标记语言，主要是用于规定怎么显示网页。
   
   XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 
   XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。
   
   XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，
   用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。
   ```

xhtml和html有什么区别：
```
一个是功能上的差别：
主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页

另外是书写习惯的差别：
XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素
```

### DHTML 是什么

   ```
    DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。
    通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。

    DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、
    排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，
    或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。

    包括：
    （1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。
    （2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、
        字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、
        背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。
   ```

### DOCTYPE、标准模式与兼容模式、DTD

#### DOCTYPE 的作用是什么
   
   ```
   <!DOCTYPE>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会
   以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。
   而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。

   在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过
   指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。
   ```

   ```
   IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。

   <!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。

   DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。
   ```

#### 标准模式与兼容模式各有什么区别
   ``` 
   标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。
   在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。
   ```
   
#### DTD
   ```
   DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中
   所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。
   
   DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。
   ```

#### HTML5 为什么只需要写 `<!DOCTYPE HTML>`，而不需要引入 DTD
   ```
   HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。
   
   而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。
   ```


#### 常用的meta标签
   ```
    <meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。
    <meta> 标签位于文档的头部，不包含任何内容。<meta> 标签的属性定义了与文档相关联的名称/值对。

    <!DOCTYPE html>  H5标准声明，使用 HTML5 doctype，不区分大小写
    <head lang=”en”> 标准的 lang 属性写法
    <meta charset=’utf-8′>    声明文档使用的字符编码
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/>   优先使用 IE 最新版本和 Chrome
    <meta name=”description” content=”不超过150个字符”/>       页面描述
    <meta name=”keywords” content=””/>      页面关键词者
    <meta name=”author” content=”name, email@gmail.com”/>    网页作者
    <meta name=”robots” content=”index,follow”/>      搜索引擎抓取
    <meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> 为移动设备添加 viewport
    <meta name=”apple-mobile-web-app-title” content=”标题”> iOS 设备 begin
    <meta name=”apple-mobile-web-app-capable” content=”yes”/>  添加到主屏后的标题（iOS 6 新增）
    是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏
    <meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”>
    添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）
    <meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
    <meta name=”format-detection” content=”telphone=no, email=no”/>  设置苹果工具栏颜色
    <meta name=”renderer” content=”webkit”>  启用360浏览器的极速模式(webkit)
    <meta http-equiv=”X-UA-Compatible” content=”IE=edge”>     避免IE使用兼容模式
    <meta http-equiv=”Cache-Control” content=”no-siteapp” />    不让百度转码
    <meta name=”HandheldFriendly” content=”true”>     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓
    <meta name=”MobileOptimized” content=”320″>   微软的老式浏览器
    <meta name=”screen-orientation” content=”portrait”>   uc强制竖屏
    <meta name=”x5-orientation” content=”portrait”>    QQ强制竖屏
    <meta name=”full-screen” content=”yes”>              UC强制全屏
    <meta name=”x5-fullscreen” content=”true”>       QQ强制全屏
    <meta name=”browsermode” content=”application”>   UC应用模式
    <meta name=”x5-page-mode” content=”app”>    QQ应用模式
    <meta name=”msapplication-tap-highlight” content=”no”>    windows phone 点击无高光
    设置页面不缓存
    <meta http-equiv=”pragma” content=”no-cache”>
    <meta http-equiv=”cache-control” content=”no-cache”>
    <meta http-equiv=”expires” content=”0″>
   ```

viewport
```
 <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’
    // device-width  设备宽度
    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置
    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数
    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数
    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数
    // user-scalable    是否允许手动缩放
```

延伸提问：怎样处理 移动端 1px 被渲染成 2px问题
```
局部处理：
meta标签中的 viewport属性 ，initial-scale 设置为 1
rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可；

全局处理：
mate标签中的 viewport属性 ，initial-scale 设置为 0.5
rem 按照设计稿标准走即可
```


### src与href的区别

```
src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。
src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；
在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素
<script src ="js.js"></script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，
直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源
嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部

href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）
或当前文档（链接）之间的链接，如果我们在文档中添加
<link href="common.css" rel="stylesheet"/>那么浏览器会识别该文档为css文件，
就会并行下载资源并且不会停止对当前文档的处理。
这也是为什么建议使用link方式来加载css，而不是使用@import方式
```
















