## 计算机网络 面试知识点总结
整理了 计算机网络 面试的部分知识点

### 目录

- [应用层](#应用层)
  - [HTTPS和HTTP区别](#HTTPS和HTTP区别)
  - [http/https协议总结](#httphttps协议总结)
  
  - [HTTP协议](#http协议)
    - [概况](#概况)
    - [HTTP的请求方法](#HTTP的请求方法)
    - [HTTP方法](#HTTP方法)
    - [GET和POST的区别](#GET和POST的区别)
    - [http状态码](#http状态码)
    - [HTTP报文的组成部分](#HTTP报文的组成部分)
      - [HTTP请求报文](#HTTP请求报文)
      - [HTTP响应报文](#HTTP响应报文)
    - [HTTP协议的主要特点](#HTTP协议的主要特点)
    - [HTTP协议优缺点](#HTTP协议优缺点)
    - [HTTP/1.1协议缺点](#HTTP11协议缺点)
    - [HTTP数据传输](#HTTP数据传输)
    - [队头阻塞问题](#队头阻塞问题)
    - [首部行](#首部行) 
    - [HTTP/1.0、HTTP1.1、HTTP2.0版本之间的差异](#HTTP10HTTP11HTTP20版本之间的差异)
    - [持久链接/http长连接](#持久链接http长连接)
    
  - [HTTP/2协议](#HTTP2协议)
    - [对HTTP/2理解](#对HTTP2理解)
    - [二进制协议](#二进制协议)
    - [多路复用](#多路复用)
    - [数据流](#数据流)
    - [头信息压缩](#头信息压缩)
    - [服务器推送](#服务器推送) 
    - [HTTP/2协议缺点](#HTTP2协议缺点)
    - [HTTP/3协议](#HTTP3协议)
    
  - [HTTPS协议](#HTTPS协议)
    - [HTTP存在的问题](#HTTP存在的问题)
    - [HTTPS握手过程](#HTTPS握手过程)
    - [TLS握手过程](#TLS握手过程)
    - [实现原理](#实现原理)
    - [介绍一个HTTPS工作原理](#介绍一个HTTPS工作原理)

  - [DNS协议](#DNS协议)
    - [概况](#概况1)
    - [DNS如何工作的](#DNS如何工作的)
    - [域名的层级结构](#域名的层级结构)
    - [查询过程](#查询过程)
    - [DNS记录和报文](#DNS记录和报文)
    - [递归查询和迭代查询](#递归查询和迭代查询)
    - [DNS缓存](#DNS缓存)
    - [DNS实现负载平衡](#DNS实现负载平衡)


- [传输层](#传输层)
  - [多路复用与多路分解](#多路复用与多路分解)

  - [UDP协议](#UDP协议)
    - [UDP报文段结构](#UDP报文段结构)
    
  - [TCP协议](#TCP协议)
    - [TCP报文段结构](#TCP报文段结构)
    - [TCP三次握手的过程](#TCP三次握手的过程)
    - [TCP为什么要三次握手](#TCP为什么要三次握手)
    - [TCP四次挥手的过程](#TCP四次挥手的过程)
    - [ARQ协议](#ARQ协议)
    - [TCP的可靠运输机制](#TCP的可靠运输机制)
    - [TCP的流量控制机制](#TCP的流量控制机制)
    - [TCP的拥塞控制机制](#TCP的拥塞控制机制)
    
  - [网络层](#网络层)
  
  - [数据链路层](#数据链路层)
  
  - [物理层](#物理层)
  
 
 
- [常考面试题](#常考面试题)
  - [Post和Get的区别](#Post和Get的区别)
  
  - [TLS/SSL中什么一定要用三个随机数，来生成"会话密钥"](#TLSSSL中什么一定要用三个随机数来生成会话密钥)
  
  - [SSL连接断开后如何恢复](#SSL连接断开后如何恢复)
  
  - [RSA算法的安全性保障](#RSA算法的安全性保障)
  
  - [DNS为什么使用UDP协议作为传输层协议](#DNS为什么使用UDP协议作为传输层协议)
  
  - [当你在浏览器中输入Google.com并且按下回车之后发生了什么](#当你在浏览器中输入Googlecom并且按下回车之后发生了什么)
  
  - [CDN服务](#CDN服务)
  
  - [什么是正向代理和反向代理](#什么是正向代理和反向代理)
  
  - [负载平衡的两种实现方式](#负载平衡的两种实现方式)
  
  - [http请求方法options方法有什么用](#http请求方法options方法有什么用)
  
  - [http1.1和http1.0之间有哪些区别](#http11和http10之间有哪些区别)
  
  - [网站域名加www与不加www的区别](#网站域名加www与不加www的区别)
  
  - [即时通讯的实现，短轮询、长轮询、SSE和WebSocket间的区别](#即时通讯的实现短轮询长轮询SSE和WebSocket间的区别)
  
  - [怎么实现多个网站之间共享登录状态](#怎么实现多个网站之间共享登录状态)




- [计算机基础](#计算机基础)
  - [网络](#网络)
    - [1.UDP](#1UDP)
    - [2.TCP](#2TCP)
    - [3.HTTP](#3HTTP)
    - [4.DNS](#4DNS)








## 应用层
```
应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间
如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。
```

### HTTPS和HTTP区别
```
HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， 
HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 
协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。
```

- SSL
```
安全套接层（Secure Sockets Layer）
```

- TLS
```
（传输层安全，Transport Layer Security）
现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 
都被认为是不安全的，在不久的将来会被完全淘汰。

HTTPS 就是身披了一层 SSL 的 HTTP。
```

那么区别有哪些呢
- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的
可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。
- HTTPS标准端口443，HTTP标准端口80。
- HTTPS需要用到SSL证书，而HTTP不用。

我觉得记住以下两点HTTPS主要作用就行
- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
- 对网站服务器进行真实身份认证。


### http/https协议总结
- 1.0 协议缺陷:
  - 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
  - head of line blocking: 线头阻塞，导致请求之间互相影响

- 1.1 改进:
  - 长连接(默认 keep-alive)，复用
  - host 字段指定对应的虚拟站点
  - 新增功能:
    - 断点续传
    - 身份认证
    - 状态管理
    - cache 缓存
      - Cache-Control
      - Expires
      - Last-Modified
      - Etag

- 2.0:
  - 多路复用
  - 二进制分帧层: 应用层和传输层之间
  - 首部压缩
  - 服务端推送

https: 较为安全的网络传输协议
- 证书(公钥)
- SSL 加密
- 端口 443

TCP:
- 三次握手
- 四次挥手
- 滑动窗口: 流量控制
- 拥塞处理
  - 慢开始
  - 拥塞避免
  - 快速重传
  - 快速恢复

缓存策略: 可分为 强缓存 和 协商缓存
- Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires
- 当缓存已经过期时，使用协商缓存
  - 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改
  - 最后一次修改时间: Last-Modified(response) & If-Modified-Since(request，上一次返回的Last-Modified)
    - 如果一致，则直接返回 304 通知浏览器使用缓存
    - 如不一致，则服务端返回新的资源
- Last-Modified 缺点：
  - 周期性修改，但内容未变时，会导致缓存失效
  - 最小粒度只到 s， s 以内的改动无法检测到
- Etag 的优先级高于Last-Modified

### HTTP协议
#### 概况
```
HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文
的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，
保证了数据传输的可靠性。

HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。
非持续连接指的是服务器必须为每一个请求的对象建立和维护一个
全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。
采用持续连接的好处是可以避免每次建立 TCP

连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，
但是可以在请求时，加上 Connection: keep-alive 来要求服务器
不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。
目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。
```

#### HTTP的请求方法
- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

http/1.1规定了以下请求方法(注意，都是大写):
- GET： 请求获取Request-URI所标识的资源
- POST： 在Request-URI所标识的资源后附加新的数据
- HEAD： 请求获取由Request-URI所标识的资源的响应消息报头
- PUT： 请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）
- DELETE： 请求服务器删除对应所标识的资源
- TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT： 建立连接隧道，用于代理服务器
- OPTIONS： 列出可对资源实行的请求方法，用来跨域请求
```
从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如
搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。
```

options 方法有什么用
- OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。
- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

#### HTTP方法
- GET：获取资源
- POST：传输资源
- put：更新资源
- DELETE：删除资源
- HEAD：获得报文首部

```
HTTP方法有很多，但是上面这五个方法，
要求在面试时全部说出来，不要漏掉。
```

- get 和post` 比较常见。
- put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。
- head 可能偶尔用的到。


#### GET和POST的区别
```
本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。
```

具体差别
- 从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。
- 从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。
- GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。
- GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

- GET在浏览器回退时是无害的，而POST会 再次提交请求
- GET产生的UR地址可以被收藏，而POST不可以
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置
- GET请求只能进行ur|编码，而POST支持 多种编码方式
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有限制
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数直接暴露在URL上,所以不能用来传递敏感信息
- GET参数通过URL传递，POST放在Request body中

```
区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。
有一点要强调，get是相对不隐私的，而post是相对隐私的。
```

我们大概要记住以下几点：
- 浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】
- get请求会被浏览器主动缓存，而post不会。【重要】
- get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。
- get请求在url中传递的参数有大小限制，基本是2kb`，不同的浏览器略有不同。而post没有注意。
- get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。

#### http状态码
```
1xx:指示信息-表示请求已接收，继续处理
2xx:成功-表示请求已被成功接收
3xx:重定向-要完成请求必须进行更进一步的操作
4xx:客户端错误-请求有语法错误或请求无法实现
5xx:服务器错误-服务器未能实现合法的请求
```

常见的http状态码：
- 200 OK:客户端请求成功
- 206 Partial Content:客户发送了一个带有Range头的GET请求，服务器完成了它
- 301 Moved Permanently:所请求的页面已经转移至新的url
- 302 Found:所请求的页面已经临时转移至新的url
- 304 Not Modified:客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户,原来缓冲的文档还可以继续使用

部分解释：
- 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。
- 301：重定向（永久）。
- 302：重定向（临时）。
- 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。

- 400 Bad Request:客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized:请求未经授权，这个状态代码必须和WWW-Authenticate报头域-起使用
- 403 Forbidden:对被请求页面的访问被禁止
- 404 Not Found:请求资源不存在
- 500 Internal Server Error:服务器发生不可预期的错误原来缓冲的文档还可以继续使用
- 503 Server Unavailable:请求未完成，服务器临时过载或当机，-段时间后可能恢复正常

- 400和401用的不多,未授权。403指的是请求被拒绝。404指的是资源不存在。

#### HTTP报文的组成部分
```
            请求报文  
请求行   请求头   空行   请求体


            响应报文
状态行   响应头   空行   响应体
```

在回答此问题时，我们要按照顺序回答：
```
先回答的是，http报文包括：请求报文和响应报文。
再回答的是，每个报文包含什么部分。
最后回答，每个部分的内容是什么
```

#### HTTP请求报文
HTTP 报文有两种，一种是请求报文，一种是响应报文。

HTTP 请求报文的格式如下：
```http

GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

POST /chapter17/user. html HTTP/1.1
Accept: image/ jpeg， application/x -ms- -application， ...，*/*
Referer: http:// localhost : 8088/ chapter17/user/register. html?
code= 100&t ime=123123
Accept -Language: zh-CN
User- Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6. 1;
Content- Type: application/x- www- form-ur lencoded
Host: localhost: 8088
Content- Length: 112
Connection: Keep-Alive
Cache -Control: no -cache
Cookie: JSESSI0NID=24DF2688E37EE4F66D9669D2542AC17B
name= tom&password= 1234&realName= tomson
```

```
HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，
首部行后还可以跟一个实体主体。请求首部之后有一个空行，
这个空行不能省略，它用来划分首部与实体。
```

- 请求行：包括请求方法、请求的url、http协议及版本。
- 请求头：一大堆的键值对。
- 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体
- 请求体：数据部分。

请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。
```
方法字段可以取几种不同的值，
一般有 GET、POST、HEAD、PUT 和 DELETE。
一般 GET 方法只被用于向服务器获取数据。

POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。

HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。

PUT 方法用于上传文件到服务器，
DELETE 方法用于删除服务器上的对象。

虽然请求的方法很多，但更多表达的是一种语义上的区别，
并不是说POST 能做的事情，GET 就不能做了，主要看我们如何选择。
```

#### HTTP响应报文
HTTP 报文有两种，一种是请求报文，一种是响应报文。

HTTP 响应报文的格式如下：
```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
Transfer- Encoding: chunked
Date: Mon, 12 Sep 2011 12:41:24 GMT
响应体如下：
6f
{"password'":"1234", "userName":"tom","birthday":null,"salary":0,
"realName":"tomson", "userId":"1000","dept":null}
0

<html>
  <body>Hello World</body>
</html>
```

- 状态行：http协议及版本、状态码及状态描述。
- 响应头
- 空行
- 响应体

```
HTTP 响应报文的第一行叫做状态行，
后面的行是首部行，最后是实体主体。

状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。

实体部分是报文的主要部分，它包含了所请求的对象。
```

常见的状态有
```
200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理
301-永久移动、302-临时移动、304-所请求的资源未修改、
400-客户端请求的语法错误、404-请求的资源不存在
500-服务器内部错误。

一般 1XX 代表服务器接收到请求、2XX 代表成功、
3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。
```

#### HTTP协议的主要特点
- 简单快速
- 灵活
- 无连接
- 无状态
```
通常我们要答出以上四个内容。如果实在记不住，
一定要记得后面的两个：无连接、无状态。
```

我们分别来解释一下。
- 2.1 简单快速
```
简单：每个资源（比如图片、页面）都通过 url 来定位。
这都是固定的，在http协议中，处理起来也比较简单，
想访问什么资源，直接输入url即可。
```

- 2.2 灵活
```
http协议的头部有一个数据类型，通过http协议，
就可以完成不同数据类型的传输。
```

- 2.3 无连接
```
连接一次，就会断开，不会继续保持连接。
```

- 2.4 无状态
```
客户端和服务器端是两种身份。第一次请求结束后，就断开了，
第二次请求时，服务器端并没有记住之前的状态，也就是说，
服务器端无法区分客户端是否为同一个人、同一个身份。

有的时候，我们访问网站时，网站能记住我们的账号，这个是通过
其他的手段（比如 session）做到的，并不是http协议能做到的。
```

#### HTTP协议优缺点
```
超文本传输协议，HTTP 是一个在计算机世界里专门在两点之间
传输文字、图片、音频、视频等超文本数据的约定和规范。
```

- HTTP 特点
  - 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
  - 请求-应答模式，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。
  - 可靠传输，HTTP是基于TCP/IP，因此把这一特性继承了下来。
  - 无状态，这个分场景回答即可。
  
- HTTP 缺点
  - 无状态，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
  - 明文传输，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
  - 队头阻塞，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

http 无状态无连接
- http 协议对于事务处理没有记忆能力
- 对同一个url请求没有上下文关系
- 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况
- 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器
- 人生若只如初见，请求过的资源下一次会继续进行请求

http协议无状态中的 状态 到底指的是什么
- 【状态】的含义就是：客户端和服务器在某次会话中产生的数据
- 那么对应的【无状态】就意味着：这些数据不会被保留
- 通过增加cookie和session机制，现在的网络请求其实是有状态的
- 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话

#### HTTP/1.1协议缺点
```
HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，
但是在同一个 TCP 连接里面，数据请求的通信次序是固定的。
服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，
如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，
这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到
最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。
这就是我们对网站优化时，使用雪碧图、合并脚本的原因。
```

#### HTTP数据传输
```
大概遇到的情况就分为定长数据 与 不定长数据的处理吧。
```

定长数据
```
对于定长的数据包而言，发送端在发送数据的过程中，
需要设置Content-Length,来指明发送数据的长度。

当然了如果采用了Gzip压缩的话，Content-Length
设置的就是压缩后的传输长度。
```

我们还需要知道的是
- Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。
- 如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。
- 那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。
- 在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于Content-Length,若是非Keep-alive，跟前面情况一样，Content-Length可有可无。

那怎么来设置Content-Length？
举个例子来看看：
```
const server = require('http').createServer();
server.on('request', (req, res) => {
  if(req.url === '/index') {
  	// 设置数据类型
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('Content-Length', 10);
    res.write("你好，使用的是Content-Length设置传输数据形式");
  }
})

server.listen(3000, () => {
  console.log("成功启动--TinaTian");
})
```

不定长数据
```
现在采用最多的就是HTTP/1.1版本，来完成传输数据，
在保存Keep-alive状态下，当数据是不定长的时候，
我们需要设置新的头部字段

Transfer-Encoding: chunked
```

通过chunked机制，可以完成对不定长数据的处理，
当然了，你需要知道的是
- 如果头部信息中有Transfer-Encoding,优先采用Transfer-Encoding里面的方法来找到对应的长度。
- 如果设置了Transfer-Encoding，那么Content-Length将被忽视。
- 使用长连接的话，会持续的推送动态内容。

那我们来模拟一下吧
```
const server = require('http').createServer();
server.on('request', (req, res) => {
  if(req.url === '/index') {
  	// 设置数据类型
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    res.setHeader('Content-Length', 10);
    res.setHeader('Transfer-Encoding', 'chunked');
    
    res.write("你好，使用的是Transfer-Encoding设置传输数据形式");
    setTimeout(() => {
      res.write("第一次传输数据给您<br/>");
    }, 1000);
    res.write("骚等一下");
    setTimeout(() => {
      res.write("第一次传输数据给您");
      res.end()
    }, 3000);
  }
})

server.listen(3000, () => {
  console.log("成功启动--TinaTian");
})

上面使用的是nodejs中http模块，有兴趣的小伙伴可以去试一试，
以上就是HTTP对定长数据和不定长数据传输过程中的处理手段。
```

#### 队头阻塞问题
什么是队头阻塞？
```
对于每一个HTTP请求而言，这些任务是会被放入一个任务队列
中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的
请求处理，这就是HTTP队头阻塞问题。
```

有什么解决办法吗
- 并发连接
```
我们知道对于一个域名而言，是允许分配多个长连接的，
那么可以理解成增加了任务队列，也就是说不会导致一个
任务阻塞了该任务队列的其他任务，在RFC规范中规定客户端
最多并发2个连接，不过实际情况就是要比这个还要多，
举个例子，Chrome中是6个。
```

- 域名分片
- 顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。
- 举个例子，比如TianTian.com，可以分出很多二级域名，比如Day1.TianTian.com，Day2.TianTian.com,Day3.TianTian.com,这样子就可以有效解决队头阻塞问题。

#### 首部行
```
首部可以分为四种首部，请求首部、响应首部、通用首部和
实体首部。通用首部和实体首部在请求报文和响应报文中
都可以设置，区别在于请求首部和响应首部。

常见的请求首部有 Accept 可接收媒体资源的类型、
Accept-Charset 可接收的字符集、Host 请求的主机名。

常见的响应首部有 ETag 资源的匹配信息，
Location 客户端重定向的 URI。

常见的通用首部有 Cache-Control 控制缓存策略、
Connection 管理持久连接。

常见的实体首部有 Content-Length 实体主体的大小、Expires 
实体主体的过期时间、Last-Modified 资源的最后修改时间。
```

#### HTTP/1.0、HTTP1.1、HTTP2.0版本之间的差异
- HTTP 0.9：1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。

- HTTP 1.0
  - 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。
  - 除了GET命令，还引入了POST命令和HEAD命令。
  - http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
  - 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
  - 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
  - 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）

- HTTP 1.1 http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。
  - 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置
  - 引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。
  - HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。
  - 支持断点续传，通过使用请求头中的 Range 来实现。
  - 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
  - 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

- http1.x版本问题
  - 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
  - HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。
  - http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

- HTTP 2.0
  - 二进制分帧 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
  - 头部压缩 HTTP 1.1版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
  - 多路复用 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
  - 服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。
  - 请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

#### 持久链接/http长连接
```
如果你能答出持久链接，这是面试官很想知道的一个点。
```

- 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。
- 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。
```
注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以
完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，
Keep-Alive不会永久保持连接，它有一个保持时间，
可以在不同的服务器软件（如Apache）中设定这个时间。
```


### HTTP/2协议
```
2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 
HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上
证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 
HTTP/2 之中得到继承。2015 年，HTTP/2 发布。
```
HTTP/2 主要有以下新的特性：

#### 对HTTP/2理解
```
首先补充一下，http 和 https 的区别，相比于 http,
https 是基于 ssl 加密的 http 协议
```

简要概括:http2.0 是基于 1999 年发布的 http1.0 之后的首次更新
- 提升访问速度(可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0)
- 允许多路复用:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改 善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限 制(连接数量)，超过限制会被阻塞
- 二进制分帧:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二 进制编码
- 首部压缩
- 服务器端推送

头部压缩
```
HTTP 1.1版本会出现 User-Agent、Cookie、Accept、
Server、Range 等字段可能会占用几百甚至几千字节，
而 Body 却经常只有几十字节，所以导致头部偏重。
```
HTTP 2.0 使用 HPACK 算法进行压缩。

多路复用
- HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

HTTP2中：
- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是Stream ID，流标识符，有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。

服务器推送
```
浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。
```

相比较http/1.1的优势
- 推送资源可以由不同页面共享
- 服务器可以按照优先级推送资源
- 客户端可以缓存推送的资源
- 客户端可以拒收推送过来的资源

二进制分帧
```
之前是明文传输，不方便计算机解析，对于回车换行符来说到底
是内容还是分隔符，都需要内部状态机去识别，这样子效率低，
HTTP/2采用二进制格式，全部传输01串，便于机器解码。

这样子一个报文格式就被拆分为一个个二进制帧，用Headers帧存放
头部字段，Data帧存放请求体数据。这样子的话，就是一堆乱序
的二进制帧，它们不存在先后关系，因此不需要排队等待，
解决了HTTP队头阻塞问题。

在客户端与服务器之间，双方都可以互相发送二进制帧，这样子
双向传输的序列，称为流，所以HTTP/2中以流来表示一个
TCP连接上进行多个数据帧的通信，这就是多路复用概念。
```

那乱序的二进制帧，是如何组装成对于的报文呢？
- 所谓的乱序，值的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的。
- 接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文。
- 二进制帧中有一些字段，控制着优先级和流量控制等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。

#### 二进制协议
```
HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息
必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。
HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，
并且统称为"帧"，可以分为头信息帧和数据帧。
帧的概念是它实现多路复用的基础。
```

#### 多路复用
```
HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，
但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，
而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。
```

#### 数据流
```
HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序
发送的，同一个连接里面连续的数据包，可能属于不同的请求。
因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 
将每个请求或回应的所有数据包，称为一个数据流。每个数据流
都有一个独一无二的编号。数据包发送的时候，
都必须标记数据流 ID ，用来区分它属于哪个数据流。
```

#### 头信息压缩
```
HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，
每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，
比如 Cookie 和 User Agent ，一模一样的内容，
每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，
头信息使用 gzip 或 compress 压缩后再发送；另一方面，
客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，
生成一个索引号，以后就不发送同样字段了，只发送索引号，
这样就能提高速度了。
```

#### 服务器推送
```
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做
服务器推送。使用服务器推送，提前给客户端推送必要的资源，
这样就可以相对减少一些延迟时间。这里需要注意的是 http2 
下服务器主动推送的是静态资源，和 WebSocket 以及
使用SSE 等方式向客户端发送即时数据的推送是不同的。
```

#### HTTP/2协议缺点
```
因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要
使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，
遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，
剩下的数据流就没法发出去，这样就导致了后面的所有数据都
会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 
协议的问题，与它本身的实现其实并没有多大关系。
```

#### HTTP/3协议
```
由于 TCP 本身存在的一些限制，Google 就开发了一个基于 
UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC协议
在 UDP 协议上实现了多路复用、有序交付、重传等等功能
```


### HTTPS协议

#### HTTP存在的问题
- 1. HTTP 报文使用明文方式发送，可能被第三方窃听。
- 2. HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。
- 3. HTTP 还存在认证的问题，第三方可以冒充他人参与通信。

#### HTTPS握手过程
```
HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 
协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/SSL 协议，
所有的信息都是加密的，第三方没有办法窃听。并且它提供了
一种校验机制，信息一旦被篡改，通信的双方会立刻发现。
它还配备了身份证书，防止身份被冒充的情况出现。
```
- 第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法
- 第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数
- 第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端
- 第四步，服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
- 第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程

总结
- 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数
- 通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。（既有对称加密，也有非对称加密）

#### TLS握手过程
- 1. 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
- 2. 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
- 3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
- 4. 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
- 5. 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

#### 实现原理
TLS 的握手过程主要用到了三个方法来保证传输的安全。
```
首先是对称加密的方法，对称加密的方法是，双方使用同一个
秘钥对数据进行加密和解密。但是对称加密的存在一个问题，
就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，
一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。
这就要用到非对称加密的方法。
```

```
非对称加密的方法是，我们拥有两个秘钥，一个是公钥，
一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，
只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥
才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，
都可以使用我们提供的公钥对数据进行加密，这样我们就可以
使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密
有一个缺点就是加密的过程很慢，因此如果每次通信都使用
非对称加密的方式的话，反而会造成等待时间过长的问题。
```

```
因此我们可以使用对称加密和非对称加密结合的方式，因为
对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以
非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信
使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。
```

```
但是现在的方法也不一定是安全的，因为我们没有办法确定
我们得到的公钥就一定是安全的公钥。可能存在一个中间人，
截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，
当我们使用他的公钥加密后发送的信息，就可以被他用自己的
私钥解密。然后他伪装成我们以同样的方法向对方发送信息，
这样我们的信息就被窃取了，然而我们自己还不知道。
```

```
为了解决这样的问题，我们可以使用数字证书的方式，首先我们
使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成
一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的
私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，
称为数字证书。当接收方收到数字证书的时候，先根据原始信息
使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来
对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的
摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法
最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的
认证中心的证书，相当于我们自动信任了他们，
只有这样我们才能保证数据的安全。
```

#### 介绍一个HTTPS工作原理
我们可以把HTTPS理解成HTTPS = HTTP + SSL/TLS
```
TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、
对称加密和非对称加密，其利用非对称加密实现身份认证和
密钥协商，对称加密算法采用协商的密钥对数据加密，
基于散列函数验证信息的完整性。
```

1. 对称加密
```
加密和解密用同一个秘钥的加密方式叫做对称加密。
Client客户端和Server端共用一套密钥，这样子的
加密过程似乎很让人理解，但是随之会产生一些问题。
```

- 问题一: WWW万维网有许许多多的客户端，不可能都用秘钥A进行信息加密，这样子很不合理，所以解决办法就是使用一个客户端使用一个密钥进行加密。

- 问题二:既然不同的客户端使用不同的密钥，那么对称加密的密钥如何传输？ 那么解决的办法只能是一端生成一个秘钥，然后通过HTTP传输给另一端，那么这样子又会产生新的问题。

- 问题三: 这个传输密钥的过程，又如何保证加密？如果被中间人拦截，密钥也会被获取, 那么你会说对密钥再进行加密，那又怎么保存对密钥加密的过程，是加密的过程？

到这里，我们似乎想明白了，使用对称加密的方式，行不通，所以我们需要采用非对称加密

2. 非对称加密
```
通过上面的分析，对称加密的方式行不通，那么我们来梳理一下
非对称加密。采用的算法是RSA，所以在一些文章中也会看见
传统RSA握手，基于现在TLS主流版本是1.2，所以接下来梳理
的是TLS/1.2握手过程。
```

非对称加密中，我们需要明确的点是
- 有一对秘钥，公钥和私钥。
- 公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开，这里说的公钥都可以解开，指的是一对秘钥。
- 公钥可以发送给所有的客户端，私钥只保存在服务器端。

3. 主要工作流程
梳理起来，可以把TLS 1.2 握手过程分为主要的五步
- 步骤一：Client发起一个HTTPS请求，连接443端口。这个过程可以理解成是请求公钥的过程。
- 步骤二：Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。
- 步骤三：
  - 浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。
  - 根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。
  - 通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。
- 步骤四：在安全拿到服务器公钥后，客户端Client随机生成一个对称密钥，使用服务器公钥（证书的公钥）加密这个对称密钥，发送给Server(服务器)。
- 步骤五：Server(服务器)通过自己的私钥，对信息解密，至此得到了对称密钥，此时两者都拥有了相同的对称密钥。

接下来，就可以通过该对称密钥对传输的信息加密/解密啦，从上面图举个例子
- Client用户使用该对称密钥加密'明文内容B',发送给Server(服务器)
- Server使用该对称密钥进行解密消息，得到明文内容B。

接下来考虑一个问题，如果公钥被中间人拿到纂改怎么办呢？

客户端可能拿到的公钥是假的，解决办法是什么呢？

3. 第三方认证
```
客户端无法识别传回公钥是中间人的，还是服务器的，
这是问题的根本，我们是不是可以通过某种规范可以让客户端
和服务器都遵循某种约定呢？那就是通过第三方认证的方式
```

```
在HTTPS中，通过 证书 + 数字签名来解决这个问题。

这里唯一不同的是，假设对网站信息加密的算法是MD5，
通过MD5加密后，然后通过第三方机构的私钥再次对其加密，
生成数字签名。
```

这样子的话，数字证书包含有两个特别重要的信息某网站公钥+数字签名
```
我们再次假设中间人截取到服务器的公钥后，去替换成自己的公钥，
因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，
这样子就防止中间人替换公钥的问题。
```

那么客户端是如何去对比两者数字签名的呢？
- 浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。
- 验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。
- 然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。

4. 数字签名作用
```
数字签名：将网站的信息，通过特定的算法加密，比如MD5,
加密之后，再通过服务器的私钥进行加密，形成加密后的数字签名。
```

第三方认证机构是一个公开的平台，中间人可以去获取。
```
如果没有数字签名的话，这样子可以就会有下面情况

从上面我们知道，如果只是对网站信息进行第三方机构
私钥加密的话，还是会受到欺骗。

因为没有认证，所以中间人也向第三方认证机构进行申请，
然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，
并且无法判断这是服务器的还是中间人的，最后造成数据泄露。
```

5. 总结
- HTTPS就是使用SSL/TLS协议进行加密传输
- 大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个对称加密的秘钥，使用该公钥加密，传输给服务端，服务端再通过解密拿到该对称秘钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。
- 第三方认证，最重要的是数字签名，避免了获取的公钥是中间人的。


### DNS协议

#### 概况
```
DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们
常说的域名系统。它是一个由分层的 DNS 服务器组成的
分布式数据库，是定义了主机如何查询这个分布式数据库的方式的
应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号端口。
```

#### DNS如何工作的
```
DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是
我们常说的域名系统。是应用层协议，通常该协议运行
在UDP协议之上，使用的是53端口号。

DNS在本地DNS服务器是如何查询的，
一般向本地DNS服务器发送请求是递归查询的

本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程
```

递归查询和迭代查询
- 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
```
所以一般而言，本地服务器查询是递归查询，而本地 DNS 
服务器向其他域名服务器请求的过程是迭代查询的过程
```

DNS缓存
```
缓存也很好理解，在一个请求中，当某个DNS服务器收到一个
DNS回答后，它能够回答中的信息缓存在本地存储器中。
返回的资源记录中的 TTL 代表了该条记录的缓存的时间。
```

DNS实现负载平衡
```
它是如何实现负载均衡的呢？首先我们得清楚DNS 
是可以用于在冗余的服务器上实现负载平衡。

原因：这是因为一般的大型网站使用多台服务器
提供服务，因此一个域名可能会对应 多个服务器地址。
```

举个例子来说
- 当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
- 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
- 以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。

DNS 为什么使用 UDP 协议作为传输层协议？
```
DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延
```

- 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。
- 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

总结
- DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。
- 查询过程，本地查询是递归查询，依次通过浏览器缓存 —>> 本地hosts文件 —>> 本地DNS解析器 —>>本地DNS服务器 —>> 其他域名服务器请求。 接下来的过程就是迭代过程。
- 递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。

#### 域名的层级结构
域名的层级结构可以如下
```
主机名.次级域名.顶级域名.根域名

# 即

host.sld.tld.root
```

根据域名的层级结构，管理不同层级域名的服务器，
可以分为根域名服务器、顶级域名服务器和权威域名服务器。

#### 查询过程
```
DNS 的查询过程一般为，我们首先将 DNS 请求发送到
本地 DNS 服务器，由本地 DNS 服务器来代为请求。
```

- 1. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
- 2. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
- 3. 从"次级域名服务器"查出"主机名"的 IP 地址。

```
比如我们如果想要查询 www.baidu.com 的 IP 地址，我们首先
会将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会
判断是否存在该域名的缓存，如果不存在，则向根域名服务器
发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器
的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 
.com 的顶级域名服务器发送一个请求，负责 .com
的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 
地址列表。然后本地 DNS 服务器再向其中一个权威域名服
务器发送一个请求，最后权威域名服务器返回一个对应的
主机名的 IP 地址列表。
```

#### DNS记录和报文
```
DNS 服务器中以资源记录的形式存储信息，每一个 DNS 
响应报文一般包含多条资源记录。一条资源记录的具体的格式为

（Name，Value，Type，TTL）

其中 TTL 是资源记录的生存时间，它定义了资源记录
能够被其他的 DNS 服务器缓存多长时间。

常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，
不同 Type 的值，对应资源记录代表的意义不同。
```

- 1. 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。

- 2. 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式查询时，返回下一级需要查询的 DNS 服务器的信息。

- 3. 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。

- 4. 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一样的，都是为了解决规范主机名不利于记忆的缺点。

#### 递归查询和迭代查询
```
递归查询指的是查询请求发出后，域名服务器代为向下一级
域名服务器发出请求，最后向用户返回查询的最终结果。
使用递归查询，用户只需要发出一次查询请求。

迭代查询指的是查询请求后，域名服务器返回单次查询的结果。
下一级的查询由用户自己请求。使用迭代查询，
用户需要发出多次的查询请求。

一般我们向本地 DNS 服务器发送请求的方式就是递归查询，
因为我们只需要发出一次请求，然后本地 DNS 服务器返回给
我们最终的请求结果。而本地 DNS 服务器向其他域名服务器
请求的过程是迭代查询的过程，因为每一次域名服务器只返回
单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。
```

#### DNS缓存
```
DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器
接收到一个 DNS 回答后，它能够将回答中的信息缓存在本地
存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。
```

#### DNS实现负载平衡
```
DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的
大型网站使用多台服务器提供服务，因此一个域名可能会对应
多个服务器地址。当用户发起网站域名的 DNS 请求的时候，
DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，
但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择
排在前面的地址发送请求。以此将用户的请求均衡的分配到
各个不同的服务器上，这样来实现负载均衡。
```


## 传输层
```
传输层协议主要是为不同主机上的不同进程间提供了
逻辑通信的功能。传输层只工作在端系统中。
```

### 多路复用与多路分解
```
将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。

在源主机上从不同的套接字中收集数据，封装头信息生成
报文段后，将报文段传递到网络层，这个过程被称为多路复用。

无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，
一个 UDP 套接字由一个二元组来标识，这个二元组包含了
一个目的地址和一个目的端口号。因此不同源地址和端口号的 
UDP 报文段到达主机后，如果它们拥有相同的目的地址和
目的端口号，那么不同的报文段将会转交到同一个 UDP 套接字中。

面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，
一个 TCP 套接字由一个四元组来标识，这个四元组包含了
源 IP 地址、源端口号、目的地址和目的端口号。因此，
一个 TCP 报文段从网络中到达一台主机上时，该主机使用
全部 4 个值来将报文段定向到相应的套接字。
```

### UDP协议
```
UDP 是一种无连接的，不可靠的传输层协议。它只提供了
传输层需要实现的最低限度的功能，除了复用/分解功能和少量的
差错检测外，它几乎没有对 IP 增加其他的东西。
UDP 协议适用于对实时性要求高的应用场景。
```

特点：
- 1. 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。

- 2. UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。

- 3. UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。

- 4. 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信。

- 5. UDP 首部小，只有 8 个字节。

#### UDP报文段结构
```
UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，
分别是源端口号、目的端口号、长度和检验和，每个字段的
长度为两个字节。长度字段指的是整个报文段的长度，包含了
首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。
虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。
```

### TCP协议
```
TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。
```

特点：
- 1. TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。

- 2. TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。

- 3. TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。

- 4. TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。

- 5. TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。

- 6. TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送速率，避免因为缓存填满而造成的数据包的丢失。

#### TCP报文段结构
```
TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。

源端口和目的端口号用于报文段的多路复用和分解。

32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。

16 比特的接收窗口字段用于实现流量控制，
该字段表示接收方愿意接收的字节的数量。

4 比特的首部长度字段，该字段指示了以 32 比特的
字为单位的 TCP 首部的长度。

6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，
RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字
段指示接收方应该立即将数据交给上层，URG 字段用来指示
报文段里存在紧急的数据。

校验和提供了对数据的差错检测。
```

#### TCP三次握手的过程
- 第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的随机数。它代表的是客户端数据的初始序号。

- 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加一。

- 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。

- 在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。

```
客户端和服务端都需要直到各自可收发，因此需要三次握手

TCP有6种标示:SYN(建立联机) ACK(确认) PSH(传送) FIN(结束) RST(重置) URG(紧急)
```

举例：已失效的连接请求报文段
- client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server
- 本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。
- 假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求
- 但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了
- 采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用

三次握手过程中可以携带数据吗
- 第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击
- 而第三次握手，此时客户端已经处于 ESTABLISHED (已建立连接状态) ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的。

TCP的四次挥手
```
为了确保数据能够完成传输
```
- 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了
- 所以你未必会马上关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

#### TCP四次挥手的过程
```
因为 TCP 连接是全双工的，也就是说通信的双方都可以
向对方发送和接收消息，所以断开连接需要双方的确认。

第一次挥手，客户端认为没有数据要再发送给服务器端，
它就向服务器发送一个 FIN 报文段，申请断开客户端到
服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。

第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端
发送一个确认报文段，表示已经接收到了客户端释放连接的请求，
以后不再接收客户端发送过来的数据。但是因为连接是全双工的，
所以此时，服务器端还可以向客户端发送数据。服务器端进入 
CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。

第三次挥手，服务器端发送完所有数据后，向客户端发送 
FIN 报文段，申请断开服务器端到客户端的连接。
发送后进入 LAST_ACK 状态。

第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个
确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，
这个时间为报文段在网络中的最大生存时间，如果该时间内服务端
没有重发请求的话，客户端进入 CLOSED 的状态。如果收到
服务器的重发请求就重新发送确认报文段。服务器端收到客户端的
确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。

TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，
所以需要双方分别释放到对方的连接，单独一方的连接释放，
只代表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，
是为了防止发送给服务器的确认报文段丢失或者出错，
从而导致服务器端不能正常关闭。
```

#### ARQ协议
```
ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的
可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。
```

它分为停止等待 ARQ 协议和连续 ARQ 协议。
- 一、停止等待 ARQ 协议
```
停止等待 ARQ 协议的基本原理是，对于发送方来说发送方
每发送一个分组，就为这个分组设置一个定时器。当发送分组的
确认回答返回了，则清除定时器，发送下一个分组。如果在规定
的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。

对于接受方来说，每次接受到一个分组，就返回对这个分组的
肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余
分组的确认。当收到分组损坏的情况的时候，直接丢弃。

使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组
确认后才能发送下一个分组，这样会造成信道的利用率过低。
```

- 二、连续 ARQ 协议
```
连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的
利用率过低的问题。它通过连续发送一组分组，然后再等待对
分组的确认回答，对于如何处理分组中可能出现的差错恢复情况，
一般可以使用滑动窗口协议和选择重传协议来实现。
```

- 1. 滑动窗口协议
```
使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口
以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发
送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的
分组是缓存中还不允许发送的分组。当发送方向接收方发送分组时，
会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器
可以理解为是最早发送但未收到确认的分组。如果在定时器的时间
内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到
确认分组的后一个位置，此时如果还有已发送但没有确认的分组，
则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，
则重新发送所有已经发送但还未收到确认的分组。

接收方使用的是累计确认的机制，对于所有按序到达的分组，
接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，
那么接方会直接丢弃，并返回一个最近的按序到达的分组的
肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，
所以发送窗口可以移动到已确认分组的后面。

滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了
只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况的话，
那么滑动窗口协议会重新发送所有的分组，这样就造成了大量
不必要分组的丢弃和重传。
```

- 2. 选择重传协议
```
因为滑动窗口使用累计确认的方式，所以会造成很多不必要
分组的重传。使用选择重传协议可以解决这个问题。

选择重传协议在发送方维护了一个发送窗口。发送窗口的以前
是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，
已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后
的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协议
最大的不同是，发送方发送分组时，为一个分组都创建了一个
定时器。当发送方接受到一个分组的确认应答后，取消该分组的
定时器，并判断接受该分组后，是否存在由窗口首部为首的连续
的确认分组，如果有则向后移动窗口的位置，如果没有则将该分组
标识为已接收的乱序分组。当某一个分组定时器到时后，
则重新传递这个分组。

在接收方，它会确认每一个正确接收的分组，不管这个分组是
按序的还是乱序的，乱序的分组将被缓存下来，直到所有的
乱序分组都到达形成一个有序序列后，再将这一段分组交付给上层。
对于不能被正确接收的分组，接收方直接忽略该分组。
```

#### TCP的可靠运输机制
```
TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。

TCP 协议在发送方维持了一个发送窗口，发送窗口以前的
报文段是已经发送并确认了的报文段，发送窗口中包含了
已经发送但未确认的报文段和允许发送但还未发送的报文段，
发送窗口以后的报文段是缓存中还不允许发送的报文段。
当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，
并且设置一个定时器，这个定时器可以理解为是最早发送但未收到
确认的报文段。

如果在定时器的时间内收到某一个报文段的确认回答，
则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，
此时如果还有已发送但没有确认的报文段，则重新设置定时器，
如果没有了则关闭定时器。如果定时器超时，则重新发送所有
已经发送但还未收到确认的报文段，并将超时的间隔设置为
以前的两倍。当发送方收到接收方的三个冗余的确认应答后，
这是一种指示，说明该报文段以后的报文段很有可能发生丢失了，
那么发送方会启用快速重传的机制，就是当前定时器结束前，
发送所有的已发送但确认的报文段。

接收方使用的是累计确认的机制，对于所有按序到达的报文段，
接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，
那么接方会直接丢弃，并返回一个最近的按序到达的报文段的
肯定回答。使用累计确认保证了返回的确认号之前的报文段都
已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。

发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中
拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来
控制报文段的发送速率。

但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 
TCP 实现会将失序的报文段给缓存起来，并且发生重传时，
只会重传一个报文段，因此 TCP 协议的可靠传输机制更像是
窗口滑动协议和选择重传协议的一个混合体。
```

#### TCP的流量控制机制
```
TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方
的发送速率，保证接收方来得及接收。因为一旦发送的速率大于
接收方所能接收的速率，就会造成报文段的丢失。接收方主要是
通过接收窗口来告诉发送方自己所能接收的大小，发送方根据
接收方的接收窗口的大小来调整发送窗口的大小，以此来达到
控制发送速率的目的。
```

#### TCP的拥塞控制机制
```
TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据
的发送速率，如果网络处于拥塞的状态，发送方就减小发送的
速率，这样一方面是为了避免继续增加网络中的拥塞程度，
另一方面也是为了避免网络拥塞可能造成的报文段丢失。

TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、
快速重传和快速恢复。

慢启动的基本思想是，因为在发送方刚开始发送数据的时候，
并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，
每次收到一个确认报文，就将发动窗口的长度加一，这样每个 
RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小
达到一个阈值的时候就进入拥塞避免算法。

拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小
由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。
这样将窗口的增长速率由指数增长，变为加法线性增长。

快速重传指的是，当发送方收到三个冗余的确认应答时，因为 
TCP 使用的是累计确认的机制，所以很有可能是发生了报文段
的丢失，因此采用立即重传的机制，在定时器结束前发送所有
已发送但还未接收到确认应答的报文段。

快速恢复是对快速重传的后续处理，因为网络中可能已经出现了
拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后
将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，
使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。

TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据
网络中的拥塞程度，通过调整慢启动的阀值，
然后交替使用上面四种机制来达到拥塞控制的目的。
```


### 网络层
```
网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议
一共包含两个主要的组件，一个 IP 网际协议，一个是路由选择协议。

IP 网际协议规定了网络层的编址和转发方式，比如说我们接入
网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用
32 位来分配地址，还有 IPv6 使用 128 位来分配地址。

路由选择协议决定了数据报从源到目的地所流经的路径，
常见的比如距离向量路由选择算法等。
```

### 数据链路层
```
数据链路层提供的服务是如何将数据报通过单一通信链路
从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，
这是由网络适配器决定的，在全世界都是独一无二的。
```

### 物理层
```
物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和
传输介质间的差异，使数据链路层不需要考虑网络的
具体传输介质是什么。
```


## 常考面试题

#### Post和Get的区别
Post 和 Get 是 HTTP 请求的两种方法。
- （1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。

- （2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

- （3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

- （4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。

#### TLS/SSL中什么一定要用三个随机数，来生成"会话密钥"
```
客户端和服务器都需要生成随机数，以此来保证每次生成的
秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任
每个主机都能产生完全随机的数，如果只使用一个伪随机的数
来生成秘钥，就很容易被破解。通过使用三个随机数的方式，
增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于
随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。
```

#### SSL连接断开后如何恢复
```
一共有两种方法来恢复断开的 SSL 连接，一种是使用 
session ID，一种是 session ticket。

使用 session ID 的方式，每一次的会话都有一个编号，
当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器
如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，
而不用重新生成一把。目前所有的浏览器都支持这一种方法。
但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，
如果我们的请求通过负载平衡被转移到了其他的服务器上，
那么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 
是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，
只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥
和加密方法等。这样不管我们的请求是否转移到其他的服务器上，
当服务器将 ticket 解密以后，就能够获取上次对话的信息，
就不用重新生成对话秘钥了。
```

#### RSA算法的安全性保障
```
对极大整数做因数分解的难度决定了 RSA 算法的可靠性。
换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。
现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。
```

#### DNS为什么使用UDP协议作为传输层协议
```
DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 
TCP 协议时造成的连接时延。因为为了得到一个域名的 
IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，
那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，
因为大多数的地址查询请求，都是浏览器请求页面时发出的，
这样会造成网页的等待时间过长。

使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，
物理链路的最小MTU = 576，所以为了限制报文长度不超过576，
UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 
的查询或者应答报文，超过了 512 字节，那么基于 UDP 的
DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 
应答就是不完整的。这里 DNS 报文的长度一旦超过限制，
并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 
协议不会维护连接状态，所以我们没有办法确定那几个报文段
属于同一个数据，UDP 只会将多余的数据给截取掉。
为了解决这个问题，我们可以使用 TCP 协议去请求报文。

DNS 还存在的一个问题是安全问题，就是我们没有办法确定
我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，
所以现在有了 DNS over HTTPS 来解决这个问题。
```

#### 当你在浏览器中输入Google.com并且按下回车之后发生了什么
- （1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字
符，则对非法字符进行转义后再进行下一过程。

- （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

- （3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

- （4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

- （5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

- （6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

- （7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

- （8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

- （9）最后一步是 TCP 断开连接的四次挥手过程。

#### CDN服务
```
CDN 是一个内容分发网络，通过对源网站资源的缓存，
利用本身多台位于不同地域、不同运营商的服务器，
向用户提供资就近访问的功能。也就是说，用户的请求并不是
直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器
将请求定位到最近的含有该资源的服务器上去请求。这样有利于
提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。
```

#### 什么是正向代理和反向代理
```
我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了
真实的请求客户端，服务端不知道真实的客户端是谁，客户端
请求的服务都被代理服务器代替来请求。

反向代理隐藏了真实的服务端，当我们请求一个网站的时候，
背后可能有成千上万台服务器为我们服务，但具体是哪一台，
我们不知道，也不需要知道，我们只需要知道反向代理服务器
是谁就好了，反向代理服务器会帮我们把请求转发到真实的
服务器那里去。反向代理器一般用来实现负载平衡。
```

#### 负载平衡的两种实现方式
```
一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，
然后由反向代理服务器来转发请求到真实的服务器上，以此来实
现集群的负载平衡。

另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上
实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，
因此一个域名可能会对应多个服务器地址。当用户向网站域名
请求的时候，DNS 服务器返回这个域名所对应的服务器 
IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，
用户一般会选择排在前面的地址发送请求。以此将用户的
请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。
这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，
所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 
IP 地址，就会造成访问的问题。
```

#### http请求方法options方法有什么用
```
OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看
服务器的性能。这个方法会请求服务器返回该资源所支持的
所有 HTTP 请求方法，该方法会用'*'来代替资源名称，
向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，
对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，
以判断是否有对指定资源的访问权限。
```

#### http1.1和http1.0之间有哪些区别
http1.1 相对于 http1.0 有这样几个区别：
- （1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。

- （2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- （3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

- （4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。

（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。

#### 网站域名加www与不加www的区别
```
WWW（World Wide Web）简称3W，有时也叫Web，中文译名为万维网，
环球信息网等，WWW由欧洲核物理研究中心（CERN）研制，其目的是为
全球范围的科学家利用Internet进行方便地通信，信息交流和信息查询。
```

WWW是什么意思？
```
首先我们要搞明白，什么是www？当大家习惯性地在访问一个
网站的时候输入“www.”的时候，大家有没有想过到底什么是www呢？

凡是上网的人，谁不知道“WWW”的重要作用？要输入网址，首先
得打出这三个字母来，这三个字母，就是英语的“World Wide Web”
首字母的缩写形式，“WWW”在中国曾被译为“环球网”、“环球信息网”、
“超媒体环球信息网”等，最后经全国科学技术名词审定委员会
定译为“万维网”。

那都是很久以前的事情了，那个时候我们的互联网还很稚嫩，
不同的服务需要不同的工具来完成，不像现在基本上
所有服务都能够通过浏览器来搞定。

那个时候，Internet提供的主要服务有万维网（WWW）、
文件传输（FTP）、电子邮件（E-mail）、远程登录（Telnet）等，
说白了，那个时候的www（World Wide Web）是标识这是一个
需要你用浏览器来访问的网页服务，而不是需要你用telnet访问的bbs，
或者ftp工具访问的文件传输服务，所以那个时候，
网站主页的域名前面要用www。
```

WWW万维网工作原理
```
当年人们对于www的定义是：WWW是建立在客户机/服务器模型之上的，
WWW是以超文本标注语言（标准通用标记语言下的一个应用）与
超文本传输协议为基础，能够提供面向Internet服务的、一致的
用户界面的信息浏览系统，其中WWW服务器采用超文本链路来
链接信息页，这些信息页既可放置在同一主机上，也可放置在
不同地理位置的主机上；本链路由统一资源定位器（URL）维持，
WWW客户端软件（即WWW浏览器）负责信息显示与向服务器发送请求。

world wide web是无数个网络站点和网页的集合，它们在一起
构成了英特网最主要的部分（英特网也包括电子邮件、Usenet
以及新闻组），它实际上是多媒体的集合，是由超级链接连接而成的，
我们通常通过网络浏览器上网观看的，就是万维网的内容。
```

WWW万维网工作原理
```
我们的互联网正是通过链接（http），创造了www（World Wide Web）
这个新的世界，因为链接，一个网站哪怕再小，也不是一座孤岛；
一个网站哪怕再大，也大不过互相链接的整个Web，
两个Web页面跨网站的链接，让整个Web成为一个整体，并获得生命。

链接成为Web上特有的一种礼仪，一段文字或一幅图片，它存在于
哪里并不重要，重要的是，它存在，任何人都可以给它一个链接，
也可以说，链接的出现，让Web成为一个公共领域。

然而在中国，我们的网络却充斥着slw（Self Limited Web）的气氛，
新浪、搜狐、网易、百度的blog仍然无法通过Rss阅读器顺利订阅，
网上无数需要被引用的图片被防盗链功能显示成一个大大的Logo，
无数人每天不厌其烦的将同样的内容从一个网站复制到另一个网站，
随意的关闭服务，更改内容链接地址，随意删除内容，让原有链接失效，
还有那个根本不存在的伟大的墙……。

在这样的环境下，我们更需要时刻提醒大家，你们的“首页”域名
之所以不用http://f9seo.com，不n而是用www.f9seo.com
这样的形式，那是因为你所创建的是一个World Wide Web。
```

#### 即时通讯的实现，短轮询、长轮询、SSE和WebSocket间的区别
```
短轮询和长轮询的目的都是用于实现客户端和服务器端
的一个即时通讯。

短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 
http 请求，服务器端在收到请求后，不论是否有数据更新，
都直接进行响应。这种方式实现的即时通信，本质上还是
浏览器发送请求，服务器接受请求的一个过程，通过让客户端
不断的进行请求，使得客户端能够模拟实时地收到服务器端
的数据的变化。这种方式的优点是比较简单，易于理解。
缺点是这种方式由于需要不断的建立 http 连接，严重浪费了
服务器端和客户端的资源。当用户增加时，服务器端的压力
就会变大，这是很不合理的。

长轮询的基本思路是，首先由客户端向服务器发起请求，
当服务器收到客户端发来的请求后，服务器端不会直接进行响应，
而是先将这个请求挂起，然后判断服务器端数据是否有更新。
如果有更新，则进行响应，如果一直没有数据，则到达一定的
时间限制才返回。
客户端 JavaScript 响应处理函数会在处理完服务器返回的
信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，
它的优点是明显减少了很多不必要的 http 请求次数，相比之下
节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，
http 协议无法做到服务器主动推送信息。但是，有一种变通方法，
就是服务器向客户端声明，接下来要发送的是流信息。也就是说，
发送的不是一次性的数据包，而是一个数据流，会连续不断地
发送过来。这时，客户端不会关闭连接，会一直等着服务器
发过来的新的数据流，视频播放就是这样的例子。SSE 就是
利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，
目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，
不需要建立过多的 http 请求，相比之下节约了资源。

上面三种方式本质上都是基于 http 协议的，我们还可以使用 
WebSocket 协议来实现。WebSocket 是 Html5 定义的一个
新协议，与传统的 http 协议不同，该协议允许由服务器主动
的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端
的配置比较复杂。WebSocket 是一个全双工的协议，也就是
通信双方是平等的，可以相互发送消息，而 SSE 的方式是
单向通信的，只能由服务器端向客户端推送信息，如果客户端
需要发送信息就是属于下一个 http 请求了。
```

#### 怎么实现多个网站之间共享登录状态
```
在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，
用户只需要登录一次就可以访问所有相互信任的应用系统。

我认为单点登录可以这样来实现，首先将用户信息的验证中心
独立出来，作为一个单独的认证中心，该认证中心的作用是
判断客户端发送的账号密码的正确性，然后向客户端返回对应的
用户信息，并且返回一个由服务器端秘钥加密的登录信息的 
token 给客户端，该token 具有一定的有效时限。当一个应用系统
跳转到另一个应用系统时，通过 url 参数的方式来传递 token，
然后转移到的应用站点发送给认证中心，认证中心对 token 
进行解密后验证，如果用户信息没有失效，则向客户端返回对应的
用户信息，如果失效了则将页面重定向会单点登录页面。
```



### 计算机基础
#### 网络
#### 1.UDP
1.1 面向报文
- UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作

具体来说
- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

1.2 不可靠性
- UDP 是无连接的，也就是说通信不需要建立和断开连接。
- UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
- UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP

1.3 高效
- 因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

头部包含了以下几个数据
- 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

1.4 传输方式
- UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能

#### 2.TCP
2.1 头部
- TCP 头部比 UDP 头部复杂的多

- 对于 TCP 头部来说，以下几个字段是很重要的

- Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
- Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
- Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制

标识符
- URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
- ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一 PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
- RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
- SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
- FIN=1：该字段为一表示此报文段是一个释放连接的请求报文

2.2 状态机
- HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态

- TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。
- 在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间

建立连接三次握手
- 在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。
- 起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据

第一次握手
- 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。

第二次握手
- 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

第三次握手
- 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED状态，此时连接建立成功。

- PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie达到减少 RTT 的目的

- 你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？

- 因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误

- 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费

- PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求

断开链接四次握手
- TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

第一次握手
- 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

第二次握手
- B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。

第三次握手
- B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
- PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

第四次握手
- A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。
- 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？
- 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭

#### 3.HTTP
HTTP 协议是个无状态协议，不会保存状态

3.1 Post 和 Get 的区别
- Get请求能缓存，Post 不能
- Post 相对 Get安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body来传输比 Get 更多的数据，Get没有这个技术
- URL有长度限制，会影响 Get请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

3.2 常见状态码
2XX 成功
- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

3XX 重定向
- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

4XX 客户端错误
- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误
- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

3.3 HTTP 首部
```
通用字段	               作用
Cache-Control	         控制缓存的行为
Connection	           浏览器想要优先使用的连接类型，比如 keep-alive
Date	                 创建报文时间
Pragma	               报文指令
Via	                   代理服务器相关信息
Transfer-Encoding	     传输编码方式
Upgrade	               要求客户端升级协议
Warning	               在内容中可能存在错误
```

```
请求字段	                作用
Accept	                能正确接收的媒体类型
Accept-Charset	        能正确接收的字符集
Accept-Encoding	        能正确接收的编码格式列表
Accept-Language	        能正确接收的语言列表
Expect	                期待服务端的指定行为
From	                  请求方邮箱地址
Host	                  服务器的域名
If-Match	              两端资源标记比较
If-Modified-Since	      本地资源未修改返回 304（比较时间）
If-None-Match	          本地资源未修改返回 304（比较标记）
User-Agent	            客户端信息
Max-Forwards	          限制可被代理及网关转发的次数
Proxy-Authorization    	向代理服务器发送验证信息
Range	                  请求某个内容的一部分
Referer	                表示浏览器所访问的前一个页面
TE	                    传输编码方式
```

```
响应字段	                作用
Accept-Ranges	          是否支持某些种类的范围
Age	                    资源在代理缓存中存在的时间
ETag	                  资源标识
Location	              客户端重定向到某个 URL
Proxy-Authenticate	    向代理服务器发送验证信息
Server	                服务器名字
WWW-Authenticate	      获取资源需要的验证信息
```

```
实体字段	               作用
Allow	                 资源的正确请求方式
Content-Encoding	     内容的编码格式
Content-Language	     内容使用的语言
Content-Length	       request body 长度
Content-Location	     返回数据的备用地址
Content-MD5	           Base64加密格式的内容MD5检验值
Content-Range	         内容的位置范围
Content-Type	         内容的媒体类型
Expires	               内容的过期时间
Last_modified	         内容的最后修改时间
```

#### 4.DNS
- DNS 的作用就是通过域名查询到具体的 IP。

- 因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么

- 在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 www.google.com 时，会进行一下操作

- 操作系统会首先在本地缓存中查询
- 没有的话会去系统配置的 DNS 服务器中查询
- 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
- 然后去该服务器查询 google 这个二级域名
- 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP

- 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。







